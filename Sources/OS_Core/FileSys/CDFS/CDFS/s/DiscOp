;-> DiscOp

;***************************************************************************

;***************************************************************************

; This part contains :

;     Entry
;     GetDiscName
;     TestKnowDisc
;     InitialiseBufferForDisc
;     AwkwardMemory
;     ReadMainDirectory
;     StoreDirectory
;     GetUniqueNumber
;     ConvertDriveNumberToDeviceID
;     GetDiscNameNotInBuffer
;     ChangeDiscMode

; Buffer procedures:
; ----------------
;     AddDiscToBufferList
;     ClaimMemoryForBuffer           OK
;     DeleteBuffer           ( by unique number )
;     DisplayBuffers
;     FindDiscInBufferList           OK
;     FindDiscNameInDiscBuffer
;     AddDirectoryToBuffer

;***************************************************************************


;***************************************************************************
TestKnowDisc ROUT; R0 = drive number, RETURNS R1 -> buffer, RETURNS R2=number
;***************************************************************************

; no parameters, or returns

; If the disc is found to be changed THEN
;    {
;     Read name of disc
;     If not same as disc in memory THEN
;     ELSE
;         {
;          Store this name as the new disc
;          Find disc type, block size
;          Find start LBA of main directory
;          Read in main directory into memory buffer
;         }
;     }

; R4 = disc number
; R7 -> control block for drive

 STASH "R0, R3 - R7, R14"

;*********************
; R7 -> control block for drive
;*********************

; ADD R7, R12, #sparecontrolblock_offset
 BL PreConvertDriveNumberToDeviceID    ; R0 = drive, R7 -> control block
 BVS Error

;*********************
; Check to see if I know the disc
;*********************
 [ demoversion=ON
 LDR R14, demotries                     ; For demo version
 ADD R14, R14, #1                       ; Lock up if done enough
 STR R14, demotries                     ;
 CMP R14, #NUMBEROFDEMOTRIES            ;
 MOVGE R14, #0                          ;
 MOVGE PC, R14                          ;
 ]

 Debug " Test know disc "

;*********************
; Make sure that drive is not busy
;*********************

; R5 = end time if need to retry


 STASH R0

; Read monotonic time into R5
; R5=R5 + BUSYRETRYTIME

 SWI XOS_ReadMonotonicTime         ; returns R0 = time
 ADD R5, R0, #BUSYRETRYTIME

;repeat
01

 SWI XCD_DriveReady
 BVS Error

 TEQ R0, #READY
; BEQ %FT02

; If busy then read monotonic time into R0
; If R0 < R5 and busy THEN retry

 SWINE XCD_StopDisc
 SWINE XOS_ReadMonotonicTime         ; returns R0 = time

 CMPNE R0, R5
 BLT %BT01

02

 GRAB R0

;*********************


; MOV R2, #0
 BL PreGetUniqueNumber ; R0 = drive number, RETURNS R1 = unique number
                           ; R2 = 0, report errors

; LDR R2, =ListOfDiscsInDrives_offset
; ADD R2, R2, R12
; LDR R1, [ R2, R0, ASL #2 ]        ; R1 = unique disc number


; Preserve disc changed flag
 MOV    r6, r2

; Preserve drive number
 STASH       r0

 MOV R0, R1

 MOV R2, #PVD


 BL FindDiscInBufferList            ; R0 = disc number, RETURNS R1 -> buffer
                                    ; R2 = block ( main dir = PVD )
                                    ; C set if not found, else C clear

 MOV R2, R0

 GRAB        r0


;----------------------------------------------------------------
; Should only need to set disc mode when disc changed
;----------------------------------------------------------------

         [ RISC_OS=2

         ; old way

 LDRCCB R0, [ R1, #DISCMODEOFFSETINABUFFER ]

 BLCC ChangeDiscMode               ; R0 = disc mode to change to

 GRABS "R0, R3 - R7, PC", CC          ; I know all about the disc

         | ; New way

          BCS           %FT01

          TEQ           r6, #0

          LDRNEB        r0, [ r1, #DISCMODEOFFSETINABUFFER ]

          BLNE          ChangeDiscMode               ; R0 = disc mode to change to

          GRABS         "r0, r3 - r7, pc"

01
         ]

;----------------------------------------------------------------

 Debug " INitialise buffer "

; Find the name of the disc held in memory for the current drive

;( R0 = drive number, RETURNS R1 -> buffer, R2 = unique disc number )


;******************************
; Read main directory into w/s
;******************************

 MOV R4, R2                    ; R4 = unique

 LDR R1, =:INDEX:sparedirectorybuffer ; CANNOT SHORTEN
 ADD R1, R12, R1
 MOV R7, R1                   ; preserve offset for later

 BL ReadMainDirectory         ; R0 = drive, R1 -> buffer, RETURNS R2 = size

;******************************
; Claim space for main directory ( just long enough )
;******************************

 MOV R0, R2

 STASH     r2
 MOV       r2, #0
 BL ClaimMemoryForBuffer      ; R0 = size, RETURNs R1 -> buffer, r2 = 0 (remove PVD)
 GRAB      r2

;******************************
; Add the claimed buffer to to the list
;******************************

 MOV R0, R4

 MOV R3, R2

 MOV R2, #PVD

 BL AddDiscToBufferList       ; R0 = disc, R1 -> buffer, R2 = block

;******************************
; Copy from w/s to claimed area 
;******************************


 LDR R0, discbuffersize          ; Don't need to copy if no buffers
                                 ;
 TEQ R0, #0                      ;

 STASH "R1,R4"

 MOVNE R2, R1

 MOVNE R1, R7

 SWINE     XCD_ByteCopy
; BLNE CopyMemory              ; R1 -> from, R2 -> to
                              ; R3 = length

 GRAB "R1,R2"

 GRABS "R0, R3 - R7, PC"                 ; disc in drive

 LTORG

;***************************************************************************
ReadMainDirectory ROUT;( R0 = drive, R1 -> buffer,
                      ; RETURN R2=size )
;***************************************************************************

; R5 = drive number


 STASH "R0 - R1, R3 - R9, R14"

 MOV R5, R0

; Find disc mode

 STASH R1
; ADD R7, R12, #sparecontrolblock_offset
 BL PreConvertDriveNumberToDeviceID     ; R0 = drive, R7 -> control block
 MOVVC R0, #0
 MOVVC R1, #PVD - 1
 SWIVC XCD_EnquireDataMode             ; RETURNS R0 = disc mode

 BVS Error
 BL ChangeDiscMode                   ; R0 = disc mode ( 1 to 2 )

 LDMFD R13, { R1 }  ; Grab value from stack without moving

; GRAB R1
 STRB R0, [ R1, #DISCMODEOFFSETINABUFFER ]

 MOV R0, R5

; STASH R1

;*******************
; If no buffers configured - disc details might be in temp buffer
;*******************

;*******************
; Find disc number in drive
;*******************

; R0 = drive number, RETURNS R1 = unique number
; R2 =0 to error, R2=1 return R1=0

; MOV R2, #0

; BL GetUniqueNumber

;*******************
; Is it same as disc number in buffer ?
;*******************

; LDR R2, DiscNumberOfDirectoryInBuffer

; TEQ R2, R1

;*******************
; If yes, then it must have the details in mem already, so skip next
;*******************

 LDMFD R13, { R1 }    ; Get value without moving stack

; GRAB R1
; BEQ I_Know_The_Details    - except that something is buggered
; STASH R1

;********************
; This macro will check for ISO / HISIERRA standard
;********************

; R0 = drive number, R1 -> disc buffer  ( It's a macro !!!!!!!! )

 Debug " Check for ISO or HISIERRA "

 CheckForISOOrHisierra


;********************

                                      ; R0 = drive number
 ADD R1, R1, #DISCNAMEOFFSETINABUFFER ; R1 -> disc name in a buffer

 BL GetDiscNameNotInBuffer            ; assumes 'buffer' contains PVD

;******************

 MOV R0, R1

 BL CutSpace

;******************
; Check for ambiguous disc names, ie/ already mounted in another drive
;******************

; BL FindDiscNameInList     ; R0 -> disc name, RETURNS R1 = drive number, or -1

; CMP R1, #-1
; ADRNEL R0, AmbiguousDiscNameError
; BNE Error

;******************
; If a disc in memory has the same name ( not mounted ) then dismount it
;******************

; BL FindDiscNameInDiscBuffer

; CMP R1, #-1

; IF NE then delete PVD buffer ( it's the only one with a name )
; Also remove from discs mounted list

; STASH R2-R5, NE
; LDRNE R2, =:INDEX:DiscNameList   ; R2 -> start of list place to put name
; ADDNE R2, R2, R12                ;
                                ;
; MOVNE R3, #LENGTHOFDISCNAME      ;
; MLANE R4, R1, R3, R2               ; [ yes ] - so crap over it
; MOVNE R5, #0                       ; and also remove the disc mounted
; STRNEB R5, [ R4 ]
; LDRNE R14, =:INDEX:discsMounted
; ADDNE R14, R14, R12
; STRNE R5, [ R14, R1, LSL #2 ]

; MOVNE R0, R1
; MOVNE R1, #PVD
; BLNE DeleteBuffer   ; R0 = disc number, R1 = block

; GRAB R2-R5,NE

;******************

 GRAB R1



I_Know_The_Details

 Debug " I Know "

 LDR R0, [ R1, #LBAOFMAINDIROFFSETINABUFFER ]  ;R0 = start block of main dir

 LDR R4, [ R1, #BLOCKSIZEOFFSETINABUFFER ]     ; R4 = blocksize

 LDRB R3, [ R1, #DISCTYPEOFFSETINABUFFER ]       ; R3 = disc type

 ADD R1, R1, #MAINDIRECTORYOFFSETINABUFFER

; R0 = start LBA, R1 -> place to put, R2 NOT USED
; R3 = disc type, R4 = blocksize, R5 = drive number, RETURNS R6 = size of mem

 MOV R6, #0
 BL StoreDirectory

 ADD R2, R6, #MAINDIRECTORYOFFSETINABUFFER


; --- Find size of disc --- NEED THIS FOR SOFTWARE SOLUTIONS NETWORK ?

 MOV R4, R1

 LDR R1, =:INDEX:buffer
 ADD R1, R12, R1
 MOV R0, #0
 SWI XCD_DiscUsed               ; r0 = 0, R1 -> BUFFER, R7 -> control block
 LDR R14, [ R1, #0 ]            ; number of blocks
 LDR R9, [ R4, #BLOCKSIZEOFFSETINABUFFER - MAINDIRECTORYOFFSETINABUFFER ]
 MUL R8, R9, R14

 STR R8, [ R4, #SIZEOFDISCOFFSETINABUFFER - MAINDIRECTORYOFFSETINABUFFER ]

 GRABS "R0 - R1, R3 - R9, PC"

CDROM = "CDROM"
CD001 = "CD001"
 ALIGN

;***************************************************************************

VeryPreStoreDirectory ; This saves a bit more space

 LDR R0, tempBlock

 LDRB R3, tempDisctype

 LDR R4, tempBlockSize

 LDRB R5, tempdrivenumber

PreStoreDirectory  ; This bit fixs a pointer - saves space ?

 LDR R1, =:INDEX:sparedirectorybuffer + MAINDIRECTORYOFFSETINABUFFER
 ADD R1, R1, R12

StoreDirectory ROUT;
; on entry:
;          R0 = start LBA
;          R1 -> place to put
;          R2  NOT USED
;          R3 = disc type
;          R4 = blocksize
;          R5 = drive number
;          R6 = 0 THEN skip 2 entries, ELSE don't skip any
; on exit:
;          R6 = size of mem, =0 if reached end of directory, =4 if empty dir
;          flags preserved
;***************************************************************************

; temp3 Lobyte = replace _ with !
; temp3+1 = length of name ( - 1 if ';' )
; R5 = tempDiscType
; R6 = last LBA
; R7 =
; R8 = 1 if ARCHY, 0 if PC object
; R9 -> place to put in memory
; R10 -> place to get from ( 'buffer' )

 STASH "R0 - R5, R7 - R11, R14"

 Debug " Store directory "

 MOV R9, R1


; Work out logical sector size from logical block size and block number

 [ myblocksize <> 2048
! 0, " See here in 'StoreDirectory' "
 ]

; R0=( startLBA * log. block size ) / log. sector size

 MUL R8, R0, R4
 MOV R0, R8, LSR #11

 Swap R5, R3

 MOV R2, #1

 BL PreLoadBlockFromDrive  ; R0 = block, R1 -> memory, R2 =length, R3 =drive

 MOV R11, R0
 MOV R10, R1

; --- skip past first 2 null entries ? ---
; ALSO check to see if entry is 0, ie/ no more entries / early end

 TEQ R6, #0

 LDRB R2, [ R10 ]             ; R2 = length of current entry
 LDREQB R2, [ R10, R2 ]!      ; R0 = R0 + R2 = start of next entry
 LDREQB R2, [ R10, R2 ]!      ; R0 = R0 + R2 = start of next entry 

 TEQ R2, #0                           ; empty directory
 STREQ R2, [R9, #0]
 MOVEQ R6, #4
 GRABS "R0-R5,R7-R11,PC", EQ          ; exit on empty directory

;***************
; Set up start of loop stuff
;***************

repeat_get_dir_contents

 ADD R2, R10, #2           ; MUST ALSO PUT IN THE LBA start of file

 LDW R3, R2, R0, R4

;if there is an extended record byte, then add it

 LDRB R2, [ R10, #1 ]
 ADD R3, R3, R2

; If block = 0, then probably because 0 length.
; 0 LBA signifies no more entries !!!!!

 MOVS R3, R3, LSL #8
 MOVEQ  R3, #1:SHL:8

 STR R3, [ R9, #LBASTARTOFFSET ]

;****************
; Copy file name into 'temparea' and convert to uppercase
;****************

 ADD R2, R10, #33                               ; R2 -> name

 LDRB R1, [ R10, #32 ]                          ; R1 -> end of name
 ADD R1, R1, R2

 ADD R4, R12, #:INDEX:TempArea

 MOV R0, R4

; R1 -> end of name
; R2 -> start of name

01

 LDRB R3, [ R2 ], #1

 UpperCase R3, R14

 STRB R3, [ R4 ], #1

 TEQ R2, R1                       ; Termination ?
 TEQNE R3, #";"                   ; [ yes ]

 BNE %BT01


 TEQ R3, #";"                     ; Chop off ';' if there
 MOV R3, #0                       ;
 STREQB R3, [ R4, #-1 ]!          ;
 STRNEB R3, [ R4 ]                ;

 LDRB R3, [ R4, #-1 ]             ; Should not be terminated with '.'
 TEQ R3, #DOT                     ;
 MOVEQ R3, #0                     ;
 STREQB R3, [ R4, #-1 ]!          ;

 SUB R4, R4, R0                   ; Save length of name
 STRB R4, temp3+1                 ;

;******************
; Is it an Archy disc ?
;******************

 LDRB R2, [ R10 ]          ; Is it an Archy file ?

 SUB R2, R2, #ARCHYFIELD

 ADD R1, R2, R10
 ADR R0, ARCHIMEDES
 MOV R2, #:LEN:"ARCHIMEDES"

 MOV R6, R9                       ; R6 -> start of object info

 BL CompareStrings                ; returns 'eq' or 'ne'

; remember if object was Archy or PC (other)

 BICNE  R8, R8, #1
 ORREQ  R8, R8, #1

 BEQ archy_do     ; Branch to extracting Archy info

;****************
; Not an Archy disc, so lie
;****************

; on entry:
; R5 = ISO / HISIERRA disc
; R6 -> start of object info
; R9 -> start of object info

; on exit: ( B archy_done )
; R5 = ISO / HISIERRA disc
; R6 -> start of object info
; R9 -> end of object name

 MOV R3, #RLRL                                  ; NOT ARCHY DISC
 STRB R3, [ R9, #FILEATTRIBUTESOFFSET ]



 ADD R0, R12, #:INDEX:TempArea

 SWI XCDFS_GiveFileType                        ; returns R1 = file type

 TEQ R1, #0

 LDREQ R1, =&FFD                               ; not Archy, so lie

 LDR R3, =&FFF00000

 ORR R3, R3, R1, LSL #8
 STR R3, [ R9, #LOADADDRESSOFFSET ]

 MOV R3, #0
 STR R3, [ R9, #EXECUTIONADDRESSOFFSET ]

;***************
; Copy name into buffer, truncate length, and put in '!' if needed
;***************

; name ( in any case ) is already at 'TempArea'

; R0 -> copy from
; R1 -> copy to
; R2 = 0 if no pling, else pling set

 ADD R9, R9, #OBJECTNAMEOFFSET                  ; copy name

 LDRB R4, [ R10, #32 ]

 ADD R0, R12, #:INDEX:TempArea

;*************
; If no '.' in name
;*************

 LDRB R14, truncation
 LDR R1, [ PC, R14, LSL #2 ]
 ADD PC, PC, R1
jump
 DCD truncate_from_right - jump - 4
 DCD truncate_from_left - jump - 4
 DCD no_truncate - jump - 4

no_truncate
 LDRB R1, [ R0 ], #1
 TEQ R1, #DOT
 MOVEQ R1, #REPLACEMENTFORDOT
 STRB R1, [ R9 ], #1
 TEQ R1, #0
 BNE no_truncate
 
 B done_archy

truncate_from_left
 LDRB R14, temp3+1   ;This truncates from the left
 SUBS R1, R14, #10
 ADDGE R0, R1, R0
 ADDGE R2, R0, #11
 ADDLT R2, R0, R14
 ADDLT R2, R2, #1

; R0 = current char
; R1 = start of name
; R2 -> end of name
; R3 -> char to get next
; R9 -> put name here
; R14 = corrupted

 MOV R1, R0              ;This truncates from the left
01
 LDRB R3, [ R0 ], #1
 TEQ R3, #DOT                          ; Replace '.' with '/'
 MOVEQ R3, #REPLACEMENTFORDOT          ;
 STRB R3, [ R9 ], #1                   ; Save char if not at end
 CMP R0, R2                            ; End of length of name ?
 BLT %BT01                             ; [ no ]
 TEQ R3, #0
 TEQNE R3, #"."
 MOVNE R14, #0
 STRNEB R14, [ R9 ], #1
 B done_archy

truncate_from_right
 LDRB     R2, temp3+1
; CMP      R2, #MAXLENGTHOFNAME + 1
; ADDGE    R2, R0, #MAXLENGTHOFNAME + 1
 CMP      R2, #10 + 1                     ; Max length for Risc OS 2.00
 ADDGE    R2, R0, #10 + 1                 ;
 ADDLT    R2, R2, R0
 ADDLT    R2, R2, #1

;***************
; Sort out name properly
;***************

; R0 = current char
; R1 = start of name
; R2 -> end of name
; R3 -> char to get next
; R9 -> put name here
; R14 = corrupted

; MOV R1, R0              This truncates from the left
;01
; LDRB R3, [ R0 ], #1
; TEQ R3, #DOT                          ; Replace '.' with '/'
; MOVEQ R3, #REPLACEMENTFORDOT          ;
; STRB R3, [ R9 ], #1                   ; Save char if not at end
; CMP R0, R2                            ; End of length of name ?            ; BLT %BT01                             ; [ no ]
; TEQ R3, #0
; TEQNE R3, #"."
; MOVNE R14, #0
; STRNEB R14, [ R9 ], #1
; B done_archy

 MOV R1, R0

01

 LDRB R3, [ R0 ], #1

 TEQ R3, #DOT                          ; Replace '.' with '/'
 MOVEQ R3, #REPLACEMENTFORDOT          ;

 STRB R3, [ R9 ], #1                   ; Save char if not at end

 CMPNE R0, R2                          ; End of length of name or found dot ?
                                       ;
 BLT %BT01                             ; [ no ]

;***************
; If found a dot and length of name > MAXLENGTHOFNAME + 1 THEN truncate
;***************

; If no dot THEN null terminate, go and check extension ( 02 )

 TEQ R3, #REPLACEMENTFORDOT      ; null terminate
 MOVNE R3, #0                    ;
 STRNEB R3, [ R9, #-1 ]
 BNE done_archy

; If name length < MAXNAMELENGTH THEN copy rest of name THEN B %FT02

 LDRB R14, temp3+1                     ; R14 = length of name
; CMP R14, #MAXLENGTHOFNAME + 1         ; If length of name > max length
 CMP    R14, #10 + 1
 BLT %BT01

; NOW -
; 1. Make R0 -> end of object name on disc

 ADD R0, R1, R14

; 2. Is [R0] = ";" - yes then R0 = R0 -1

 LDRB R14, [ R0 ]
 TEQ R14, #";"
 SUBEQ R0, R0, #1

; 3. copy from ( R0 - 3 ) to ( R6 + offset + maxlengthofname - 3 ) length 3
;   check for 'dot' while copying

; R1 = start copying from
; R9 = copy to
; R0 = end of copying from
; R14 = char

; ADD R9, R6, #OBJECTNAMEOFFSET + MAXLENGTHOFNAME - 4
 ADD    R9, R6, #OBJECTNAMEOFFSET + 10 - 4
 SUB R1, R0, #3

 MOV R14, #REPLACEMENTFORDOT
 STRB R14, [ R9 ], #1

06

 LDRB R14, [ R1 ], #1
 TEQ R14, #DOT
 MOVEQ R14, #REPLACEMENTFORDOT
 STRB R14, [ R9 ], #1

 CMP R1, R0
 BLE %BT06

; R9 should point at end of name

 MOV R3, #0 
 STRB R3, [ R9, #-1 ]
 B done_archy

;**************
; It is an Archy prog so ...
;**************

archy_do

 ADD R3, R1, #:LEN:"ARCHIMEDES"

 LDW R4, R3, R2, R14
 STR R4, [ R9, #LOADADDRESSOFFSET ]

 ADD R3, R3, #4

 LDW R4, R3, R2, R14
 STR R4, [ R9, #EXECUTIONADDRESSOFFSET ]

 ADD R3, R3, #4                                 ; Load whole word, but only
 LDW R4, R3, R2, R14                            ; save low byte
                                                ; bit 8 = pling bit
 STRB R4, [ R9, #FILEATTRIBUTESOFFSET ]         ; If pling bit set, then


;********* Archy name copy ( null terminated )

; R0 -> copy from
; R1 -> copy to
; R4 = file attributes + plingbit
; R14 = temp

 ADD R0, R12, #:INDEX:TempArea
 ADD R1, R9, #OBJECTNAMEOFFSET

05

 LDRB R14, [ R0 ], #1
 STRB R14, [ R1 ], #1
 TEQ R14, #0
 BNE %BT05

 TST R4, #PLINGBIT
 MOVNE R4, #"!"
 STRNEB R4, [ R9, #OBJECTNAMEOFFSET ]

 MOV R6, R9

 MOV R9, R1

;****************
; Take care of rest, no matter what type of disc
;****************

done_archy

; on entry:
; R5 = ISO / HISIERRA
; R6 -> start of object info
; R9 -> end of object name in object info

;******************
; File or directory ?
;******************

 TEQ R5, #ISO
 LDREQB R4, [ R10, #ISOFLAGSOFFSET ]
 LDRNEB R4, [ R10, #HISIERRAFLAGSOFFSET ]

 TST R4, #DIRECTORYTYPE
 MOVEQ R4, #FILE
 MOVNE R4, #DIRECTORY
 STRB R4, [ R6, #OBJECTTYPEOFFSET ]


;******************
; Keep data length 
;******************

 ADD R4, R10, #10
 LDW R3, R4, R2, R14


 STR R3, [ R6, #LENGTHOFFSET ]                  ; data length


;******************
; Get archy date from ISO / HISIERRA
;******************

 ADD R0, R10, #18  ; R0 -> 6 byte ISO date block

 ADD R1, R6, #TIMEDATEOFFSET; R1 -> put 5 byte Archy block here

; Work out the date stamped on the ISO / HISIERRA file



 ConvertToArchyDate R0, R1, R2, R3, R4, R11, R7, R14

; If object was not an Archy object, then fake a load/exec address

 TST R8, #1
 ADDEQ R14, R6, #LOADADDRESSOFFSET
 LDMEQIA R14, { R0, R1 }

; CHECK TO SEE IF TIME=0 IF SO, THEN COPY FROM TIMEDATEOFFSET

 TEQEQ R1, #0

 LDREQB R1, [ R6, #TIMEDATEHIBYTEOFFSET ]
 ORREQ R0, R1, R0
 LDREQ R1, =&FFF00000
 ORREQ R0, R0, R1
 LDREQ R1, [ R6, #TIMEDATEOFFSET ]
 STMEQIA R14, { R0, R1 }


;02




;***************
;
;***************

 ALIGNREG R9                                    ; Word align R9

 LDRB R14, [ R10 ]         ; R14 = length of current entry
 LDRB R14, [ R10, R14 ]!   ; R10 = R10 + R14 = start of next entry
 TEQ R14, #0

 BNE repeat_get_dir_contents

01

 STR R14, [ R9, #0 ]                             ; null terminate if last
 ADD R6, R9, #4                                  ; ( allow some room )
 GRAB "R0 - R5, R7- R11, R14"                    ; R6 = size of mem used
 SUB R6, R6, R1                                  ;
 MOVS PC, R14                                    ;

ARCHIMEDES = "ARCHIMEDES", 0
 ALIGN



;***************************************************************************
ClaimMemoryForBuffer ROUT
;
; on entry:
;          r0 = size
;          r2 = disc number of PVD to preserve
; on exit:
;          r1 -> buffer
;          all other regs preserved
;
; History: CDFS 2.16 extra register (r2) added to keep PVDs when searching.
;
;***************************************************************************

; r5 = 0 if remove PVDs, 1 to preserved PVDs

 STASH "R0, R2 - R5, R14"

 MOV       r5, r2

 LDR R2, discbuffersize                 ; If configured buffers = 0
 TEQ R2, #0                             ; then use sparedirectorybuffer for
 LDREQ R1, =:INDEX:sparedirectorybuffer ; it
 ADDEQ R1, R1, R12                      ;
 GRABS "R0, R2 - R5, PC", EQ            ;

 LDRB R2, numberofbuffersused    ; Even if there is enough space for the buf
 LDR R3, maxnumberofbuffers      ; there may not be enough pointer space
 CMP R2, R3                      ;
 BGE fnar_fnar                   ;

; LDR R2, discbufferpointer
; LDR R3, disclastpointer
; LDR R4, discbuffersize
 ADD R2, R12, #:INDEX:discbufferpointer
 LDMIA R2, { R2, R3, R4 }

 SUB R2, R3, R2                  ; R2 = amount of mem used so far
 SUB R4, R4, R2                  ; R4 = amount of mem left for this buffer

 CMP R4, R0                      ; If enough mem left then assign new lot

 MOVGE R1, R3                    ; new disc buffer = bottom of last one

 ADDGE R3, R3, R0                ; move bottom pointer down
 STRGE R3, disclastpointer       ;

 GRABS "R0, R2 - R5, PC", GE

fnar_fnar

; Need to delete an old buffer, so:

; REPEAT
;
; Delete first disc buffer in list
;
; UNTIL disclastpointer - discbufferpointer >= size required
;
; Move R1 = disclastpointer
; Move disclastpointer down by 'size required'

 MOV R4, R0                   ; R4 = size required

 LDR R3, pointerToBufferList        ;R0 = unique disc number of first in list

REPEAT_free_space_enough

 LDR R0, [ R3, #DISC ]
 LDR R1, [ R3, #BLOCK ]

;----------------------------------------
; If it's a PVD then should I remove it ?
;----------------------------------------
 TEQ        r1, #PVD
 TEQEQ      r5, r0
 ADDEQ      r3, r3, #SIZEOFBUFFERENTRY
 BEQ        REPEAT_free_space_enough

;----------------------------------------

 BL DeleteBuffer                    ; R0 = unique disc number, R1 = block


 ADD R0, R12, #:INDEX:discbufferpointer
 LDMIA R0, { R0, R1, R2 }
 SUB R0, R1, R0            ; amount used
 SUB R0, R2, R0            ; amount left
 CMP R4, R0

 BGT REPEAT_free_space_enough

no_sir


; LDR R1, disclastpointer
 ADD R4, R4, R1
 STR R4, disclastpointer


 GRAB "R0, R2 - R5, PC"

;***************************************************************************
AddDiscToBufferList ROUT; R0 = disc, R1 -> buffer, R2 = block number
;***************************************************************************

; This automatically saves the truncation type with the buffer details

 BIC R14, R14, #Overflow_Flag
 STASH "R0 - R7,R14"

 LDR R3, discbuffersize                  ; If configured buffer size = 0
 TEQ R3, #0                              ; then redirect to sparebuffer
; STREQ R0, DiscNumberOfDirectoryInBuffer ;
 GRABS "R0 - R7,PC", EQ                      ;
; BICEQS PC, R14, #Overflow_Flag          ;

; R0 = disc to add
; R1 = buffer to add
; R2 = block
; R3 -> list of discs buffered
; R4 = buffer pointer
; R6 = wasted

 LDR R3, pointerToBufferList             ; Find end of list

01

 LDMIA R3!, { R4, R5, R6, R7 }           ; R3 -> buffer pointer

; [ SIZEOFBUFFERENTRY > 12
; ADD R3, R3, #SIZEOFBUFFERENTRY-12
; ]

 TEQ R5, #0

 BNE %BT01


; STR R0, [ R3, #DISC-SIZEOFBUFFERENTRY ]      ; unique disc number
; STR R1, [ R3, #POINTER-SIZEOFBUFFERENTRY ]   ; buffer
; STR R2, [ R3, #BLOCK-SIZEOFBUFFERENTRY ]     ; block
 SUB R4, R3, #SIZEOFBUFFERENTRY
 LDRB R7, truncation
 STMIA R4, { R0, R1, R2, R7 }

 STR R5, [ R3, #DISC ]                        ; clear last entry
 STR R5, [ R3, #POINTER ]
 STR R5, [ R3, #BLOCK ]


 LDRB R6, numberofbuffersused
 ADD R6, R6, #1
 STRB R6, numberofbuffersused


 GRABS "R0 - R7, PC"

; BICS PC, R14, #Overflow_Flag

;***************************************************************************
DeleteBuffer ROUT; R0 = unique disc number, R1 = block
;***************************************************************************

 STASH "R0 - R9, R14"

 LDR R3, discbuffersize               ; If configured buffer size = 0
 CMP R3, #0                           ; then cannot delete a buffer !
 GRABS "R0 - R9, PC", EQ              ; ( so ignore )
; BICEQS PC, R14, #Overflow_Flag       ;

; R1 = disc number
; R2 = pointer
; R3 -> list of discs
; R4 = block number in list
; R5 -> list of blocks
; R6 = block number to find

 LDR R3, pointerToBufferList

 MOV R6, R1

01

 LDMIA R3!, { R1, R2, R4, R9 }; R1 = disc number; R2 = pointer to disc buffer
                              ; R4 = block, R9=blocky_offset(no limits)

; [ SIZEOFBUFFERENTRY > 12
; ADD R3, R3, #SIZEOFBUFFERENTRY-12
; ]

 TEQ R2, #0                  ; Not found
 GRABS "R0 - R9, PC", EQ     ;

 TEQ R1, R0                  ; Not right disc
 TEQEQ R4, R6                ; Not right block

 BNE %BT01


 ; R1 = disc number, R2 = pointer to buffer, R3 = place found at + 12


 LDRB R4, numberofbuffersused ; numberofbuffers - = 1
 SUB R4, R4, #1               ;
 STRB R4, numberofbuffersused ;

 SUB R4, R3, #SIZEOFBUFFERENTRY

02                          ; Shuffle list over top of deleted entry

 LDMIA R3!, { R0, R1, R6, R9 }      ; R0 = unique, R1 = pointer to disc

; [ SIZEOFBUFFERENTRY > 12
; ADD R3, R3, #SIZEOFBUFFERENTRY-12
; ]

 STMIA R4!, { R0, R1, R6, R9 }      ; R6 = block

; [ SIZEOFBUFFERENTRY > 12
; ADD R4, R4, #SIZEOFBUFFERENTRY-12
; ]

 TEQ R1, #0

 BNE %BT02

                            ; R2 -> disc buffer

; REPEAT
;
; Find next disc buffer in memory
; If there is one THEN {
;                      Copy from that one up to the deleted one
;                      Alter pointer in list for new position ( and number )
;                      }
; UNTIL no disc buffer below

; Adjust pointer to bottom of used disc buffer



;REPEAT_scrub_little_buffer

; R0 = disc buffer from list
; R1 -> current pos. in list
; R2 -> disc buffer to delete                         Delete this buffer
; R3 = next disc buffer ( in ascending memory order ) Move this up
; R4 -> R5 ( = place R5 was from in list )
; R5 = unique disc number of buffer to delete


 MOV R6, R2                   ; R6 -> buffer to delete

move_more

 LDR R3, disclastpointer

 LDR R1, pointerToBufferList
 ADD R1, R1, #POINTER

 MOV R8, #0
 MOV R5, #0
 MOV R4, #0

03                             ; Make R3 = next buffer after R2

 LDR R0, [ R1 ], #SIZEOFBUFFERENTRY

 TEQ R0, #0
 BEQ wish_you_were_here

 CMP R0, R3
 BGE %BT03
 CMP R0, R2
 BLE %BT03

 MOV R3, R0
 LDR R5, [ R1, #DISC - POINTER - SIZEOFBUFFERENTRY ]         ; R5 = disc
 LDR R8, [ R1, #BLOCK - POINTER - SIZEOFBUFFERENTRY ]        ; R8 = block
 LDR R9, [ R1, #BLOCKY_OFFSET - POINTER - SIZEOFBUFFERENTRY ]; R9 = offset
 SUB R4, R1, #(POINTER + SIZEOFBUFFERENTRY )                 ; R4 -> next buf


 B %BT03


wish_you_were_here

 TEQ R5, #0
; BEQ no_more_buffers
 STREQ R6, disclastpointer               ; move bottom of disc pointer up
                                       ;
 GRABS "R0 - R9, PC",EQ                   ;

 LDR R7, disclastpointer

 LDR R1, pointerToBufferList
 ADD R1, R1, #POINTER

04                               ; Make R7 -> buffer after R3

 LDR R0, [ R1 ], #SIZEOFBUFFERENTRY

 CMP R0, #0
 BEQ deal_with_next_buffer

 CMP R0, R7
 BGE %BT04

 CMP R0, R3
 BLE %BT04

 MOV R7, R0
 B %BT04


deal_with_next_buffer


; STR R5, [ R4, #DISC ]
; STR R6, [ R4, #POINTER ]
; STR R8, [ R4, #BLOCK ]
; STR R9, [ R4, #BLOCKY_OFFSET ]
 STMIA R4, { R5, R6, R8, R9 }

; R2 -> buffer to write over ( delete )
; R3 -> next buffer after R2
; R4 -> position in list of R3
; R6 -> position to copy to
; R7 -> next buffer after R3

; Copy from R3 to ( ( R3 - R2 ) + discbufferpointer ), length ( R7 - R3 )

 STASH "R0, R2 - R4"

 MOV R0, R3

 MOV R1, R6

 SUB R2, R7, R3

 ADD R6, R6, R2            ; R6 = R6 + size of buffer

 STASH "R1"

 MOV R3, R2
 MOV R2, R1
 MOV R1, R0

 SWI   XCD_ByteCopy
; BL CopyMemory            ; R1 -> From, R2 -> to, R3 = length

 GRAB "R1"

 GRAB "R0, R2 - R4"

 MOV R2, R3


 B move_more    ; R3 -> next buffer


;no_more_buffers

; STR R6, disclastpointer               ; move bottom of disc pointer up
                                       ;
; GRABS "R0 - R9, PC"                   ;


;***************************************************************************
FindDiscInBufferList ROUT; R0 = disc number, RETURNS R1 -> buffer, R2 =block

; If not found, THEN 'C' set, else 'C' clear
; Other flags knacked though

; THIS AUTOMATICALLY CHECKS TO MAKE SURE THAT THE BUFFER WAS SAVED WITH
; THE CURRENT TRUNCATION METHOD !

;***************************************************************************

 STASH "R0, R2 - R7, R14"

; R0 = disc from list
; R1 -> buffer
; R2 = block to look for
; R3 = disc
; R4 -> list of discs in buffers
; R5 -> list of blocks from which directories came
; R6 = block from list

 LDRB R7, truncation
 LDR R4, pointerToBufferList

 MOV R3, R0

01

 LDMIA R4!, { R0, R1, R5, R6 }   ; R0 = disc number, R1 -> buffer, R5 = block
                                 ; R6=block offset

 SUBS R1, R1, #0                 ; Last entry in list
 GRAB "R0, R2 - R7, PC", EQ      ; [ yes ] - Carry set by test

 TEQ R3, R0                      ; Disc in list = Disc wanted ?
 TEQEQ R2, R5                    ; Right directory ?
 TEQEQ R6, R7                    ; Right truncation method ?
 BNE %BT01                       ; [ no ]

 CLC                             ; R1 -> buffer
 GRAB "R0, R2 - R7, PC"          ; Found it

;***************************************************************************

PreGetUniqueNumber ; Sets up for GetUniqueNumber

 MOV R2, #0

;***************************************************************************
GetUniqueNumber ROUT         ; R0 = drive number, RETURNS R1 = unique number
                             ; R2 =0 to error, R2=1 return R1=0
; Returns: r2 = 0 if disc not changed, else = 1 if changed
;***************************************************************************

; R6 = drive number

 STASH "R0, R3 - R8, R14"

 MOV R6, R0

;******************
; Make a control block from the drive number
;******************

; ADD R7, R12, #:INDEX:sparecontrolblock

; MOV R0, R6


 BL PreConvertDriveNumberToDeviceID ; R0 = drive number, R7 -> block
 BVS Error


;******************
; Has the disc changed since last time I was called ?
;******************

 SWI XCD_DiscChanged

 BVS please_give_disc             ; If error THEN handle it

 TEQ R0, #0                       ; disc has changed if = 1


;******************
; Disc has not changed, so use remembered number
;******************

 LDREQ R7, =:INDEX:ListOfDiscsInDrives            ; see end of this proc 
 ADDEQ R7, R7, R12
 LDREQ R1, [ R7, R6, LSL #2 ]        ; R1 = unique disc number

;------------------------------------------
; Disc not changed
;------------------------------------------

           [ RISC_OS > 2

           MOVEQ      r2, #0

           ]

;------------------------------------------

 GRABS "R0, R3 - R8, PC", EQ

;******************
; Find the size of the disc using the control block
;******************


 [ debug=ON
 SWI XOS_NewLine
 Debug " Disc has changed "
 SWI XOS_NewLine
 SWI XOS_NewLine
 ]

 LDR R1, =:INDEX:buffer
 ADD R1, R12, R1

 MOV R0, #0

 SWI XCD_DiscUsed

 BVS please_give_disc             ; If error THEN handle it

;******************
; R8 = size of disc ( in blocks )
;******************

 LDR R8, [ R1 ]

;******************
; Load PVD from the drive
;******************

 MOV R0, #0
 MOV R1, #PVD
 MOV R2, #1
 LDR R3, =:INDEX:buffer
 ADD R3, R3, R12

 MOV R4, #myblocksize

 SWI XCD_ReadData

;******************
; If everything is well, then CRC data ELSE CRC check = 0
;******************


 MOV R0, #0                        ; Perform cyclic redundancy check on
 MOVVC R1, R3                      ; the first 60 bytes in the PVD
 ADDVC R2, R1, #60                 ;
 MOVVC R3, #1                      ;


 SWIVC XOS_CRC                     ; RETURNS R0 = CRC value

;******************
; Exclusive OR the redundancy check with the size of the disc
;******************

 EOR R1, R0, R8


;******************
; Check that disc has not already been mounted
;******************

; R1 = disc number
; R4 -> disc number for drive
; R5 = number left to look at
; R6 = drive number
; R7 -> control block
; R8 -> disc number list
; R14 = temp disc number

 LDR R4, =:INDEX:ListOfDiscsInDrives            ; see end of this proc.
 ADD R4, R4, R12
; SUB R8, R4, #4
; ADD R4, R4, R6, ASL #2

;; MOV R5, #MAXNUMBEROFDRIVESSUPPORTED - 1
; LDRB    R5, numberofdrives

;01

; LDR R14, [ R8, #4 ]!
; TEQ R4, R8                        ; Skip drive number
; BEQ %BT01
; TEQ R14, R1                       ; Found more than one occurence ?
; SWIEQ XCD_DiscHasChanged          ; [ yes - so ambiguous disc ]
; addr R0, AmbiguousDiscNameError, EQ
; BEQ Error

; SUBS R5, R5, #1
; BGT %BT01

;******************
; Save the value
;******************

; STR R1, [ R4 ]                    ; R1 = unique disc number
 STR    R1, [ R4, R6, LSL #2 ]

;******************
; EXIT
;******************

;------------------------
; Disc changed
;------------------------

           [ RISC_OS > 2

           MOV        r2, #1

           ]

;------------------------

 GRABS "R0, R3 - R8, PC"

;******************
; Test the error ( if drive empty THEN caller may want to know )
;******************

please_give_disc

 Debug " Please give DISC "

 LDR R14, [ R0 ]

 LDR R1, =NoCaddyNumber           ; is the error no disc ?
 TEQ R1, R14                      ; 
 TEQNE R2, #1                     ; was R2 specified anyway ?
 BNE Error                        ; [ no ]

 MOV R1, #0                       ; indicate that an error occured (no disc)

;******************
; EXIT
;******************

;------------------------
; Disc changed
;------------------------

           [ RISC_OS > 2

           MOV        r2, #1

           ]

;------------------------

 GRABS "R0, R3 - R8, PC"

;***************************************************************************

PreConvertDriveNumberToDeviceID  ; This sets R7->controlblock

 ADD R7, R12, #:INDEX:sparecontrolblock ; IMPORTANT r7 right on exit

;***************************************************************************
ConvertDriveNumberToDeviceID ROUT; R0 = drive number, R7 -> controlblock
;***************************************************************************

 STASH "R1 - R5, R7, R14"

;This should:

;            1. Check to make sure that many drives are attached
;            2. Load the corresponding drive number from the list
;            3. Convert the real drive number into device, LUN, card
;            4. Save the device, LUN, card in the block


;****************
; Add another drive ( it won't if it already knows it )
;****************

 BL AnotherDriveHasBeenAdded  ; RETURNS 'V' set if error

 GRAB "R1 - R5, R7, R14", VS
 ORRVSS PC, R14, #Overflow_Flag

;****************
; Convert the drive to control block
;****************

 LDR R1, =:INDEX:ListOfDrivesAttached
 ADD R1, R1, R12

 LDRB R4, [ R1, R0 ]          ; R4 = device id of found drive

 AND R1, R4, #2_111           ; device
 MOV R2, R4, LSR #3           ;
 AND R2, R2, #2_11            ; card
 MOV R3, R4, LSR #5           ;
 AND R3, R3, #2_111           ; LUN

 LDR R5, =:INDEX:DriveTypes   ; drive type
 ADD R5, R5, R12              ;
 LDRB R4, [ R5, R0 ]          ;

 MOV R5, #0                   ; RESERVED

 STMIA R7, { R1 - R5 }

 GRABS "R1 - R5, R7, PC"



;***************************************************************************
GetDiscName ROUT; ( R0 = drive, R1 -> disc name$, R2 -> disc buffer )
;***************************************************************************

 STASH "R0 - R4, R14"

 LDR R4, discbuffersize           ; If no disc buffers used, THEN get name
 TEQ R4, #0                       ;

; --- Already know about this ---

 MOVNE R3, R1

 ADDNE R1, R2, #DISCNAMEOFFSETINABUFFER   ; Copy from

 MOVNE R2, R3                             ; Copy to

 MOVNE R3, #LENGTHOFDISCNAME - 2          ; Copy length

                                          ; Read disc name into area
; BLNE CopyMemory
 SWINE   XCD_ByteCopy

 TEQ R4, #0

 GRABS "R0 - R4, PC", NE

 ; ******* Load name from drive if no buffer *******

 MOV R3, R0
 MOV R0, #PVD
; LDR R1, =buffer_offset
; ADD R1, R1, R12
 MOV R2, #1

 BL PreLoadBlockFromDrive       ; R0 = block, R1 = memory, R2 = no. blocks
                                ; R3 = drive

 GRAB "R0 - R4, R14"   ; Allow to roll on

;***************************************************************************
GetDiscNameNotInBuffer ROUT    ; R0 = drive, R1 -> name of disc in drive
;***************************************************************************

; R7 -> place to put disc name

; This expects the PVD to be loaded into 'buffer_offset'

 STASH "R0 - R7, R14"

 MOV R7, R1

 MOV R5, R1

 MOV R3, R0

 LDR R1, =:INDEX:buffer + 9
 ADD R1, R1, R12

;*****************************  ; Find disc type ( ISO / HISIERRA )

 addr R0, CDROM

 MOV R2, #5

 BL CompareStrings   ; returns 'eq' or 'ne'

 ADDEQ R1, R1, #HISIERRASTARTOFDISCNAMEINPVD - 9 ;[ is HISIERRA ]
 BEQ matched                                     ;

 SUB R1, R1, #8               ; ISO 9660

 addr R0, CD001

 MOV R2, #5

 BL CompareStrings    ; returns 'eq' or 'ne'

 [ RISC_OS=2
 addr R0, DataModeError, NE     ; Unknown format
 BNE Error                    ;
 |
        MOVNE        r0, #ERROR_NOTISO
        BNE          Error
 ]


 ADD R1, R1, #ISOSTARTOFDISCNAMEINPVD - 1

matched                       ; R1 -> disc name

 ADD R2, R1, #28              ; R2 -> end of disc name


 MOV R14, R5


; R4 -> last position that was not a 0 or a space

 MOV R4, R14

; If disc name is a number, then !!!!!!!!!!!! aaarr

 LDRB R3, [ R1 ]
 CMP R3, #"0"                 ; Character was a digit
 RSBGES R3, R3, #"9"
 MOVGE R3, #"Q"
 STRGEB R3, [ R14 ], #1
 ADDGE R1, R1, #1

01

 LDRB R3, [ R1 ], #1          ; copy name to caller
 STRB R3, [ R14 ], #1         ;

 TEQ R3, #SPACE
 TEQNE R3, #0                 ; The SUN CD is dodgy - name = 0's !!!

 MOVNE R4, R14

 TEQ R1, R2
 BNE %BT01

;****************
; null terminate entry
;****************

 MOV R3, #0
 STRB R3, [ R14 ]

;****************
; If 'VS' then disc had no name !
;****************


;****************
; Give disc with no name a name
;****************

; R5 -> place to put disc name

 TEQ R4, R5

 MOVEQ R2, R5
 addr R1, NameForNoName, EQ
 MOVEQ R3, #?NameForNoName
; BLEQ CopyMemory           ; R1 -> from, R2 -> to, R3 = length ( + null )
 SWIEQ  XCD_ByteCopy

 TEQ R4, R5
 GRABS "R0 - R7, PC", EQ

;****************
; A disc name can contain spaces ! ( see SUN OS 4.1 )
; Convert to uppercase ( SUN OS 4.1 seems to break the ISO spec ! )
;****************

; R7 -> start of disc name
; R4 -> last character in disc name
; R5 = scrap
; R14 = scrap

02

 LDRB R14, [ R4, #-1 ]!

 UpperCase R14, R5

 TEQ R14, #SPACE
 MOVEQ R14, #"_"

 STRB R14, [ R4 ]

 CMP R4, R7
 BGT %BT02

 GRABS "R0 - R7, PC"

;***************************************************************************
ChangeDiscMode ROUT; R0 = mode, R7 -> control block
; uses 'buffer'
;***************************************************************************

 STASH "R0 - R5, R14"

 [ debug=ON
 Debug " Change disc mode to"
 MOV R4, R0
 DebugDisplay R4
 ]

; MOV R1, #5              ; Inactivity timer
; MOV R2, #1              ; Read retry count
; MOV R3, R0              ; data mode
; MOV R4, #0              ; RESERVED

 MOV      r3, r0
 LDR R0, =:INDEX:buffer
 ADD R0, R0, R12
 SWI        XCD_GetParameters
 BVS        Error

 STR        r3, [ r0, #8 ]
 SWI        XCD_SetParameters

 BVS        Error

 GRABS "R0 - R5, PC"

;***************************************************************************
 [ bufferlist=ON
DisplayBuffers ROUT  ; Displays buffer pointers, disc names etc;
;***************************************************************************

 STASH "R0 - R6, R14"

; R1 -> disc entry in list ( at buffer pointer )
; R2 -> disc buffer

 LDR R1, pointerToBufferList
 TEQ R1, #0
 GRAB "R0 - R6, PC", EQ


01

 LDMIA R1!, { R2, R3, R4, R6 }; R2 = disc, R3 = pointer, R4 = block,R6=offset

 TEQ R3, #0

 GRABS "R0 - R6, PC", EQ


 SWI XOS_WriteS
 = " block number = ", 0
 ALIGN
 Display R4

 TEQ R4, #PVD
 BNE no_name

 SWI XOS_WriteS
 = " Disc name = ",0
 ALIGN

 ADD R0, R3, #DISCNAMEOFFSETINABUFFER

 SWI XOS_Write0

no_name

 SWI XOS_WriteS
 = " Disc number = &",0
 ALIGN
 MOV R5, R2
 Display R5

 SWI XOS_WriteS
 = "  buffer pointer = ",0
 ALIGN

 MOV R5, R3

 Display R5

 SWI XOS_NewLine

 LDR R5, disclastpointer
 SWI XOS_WriteS
 = " Last pointer = &",0
 ALIGN
 Display R5

 LDRB R5, numberofbuffersused
 SWI XOS_WriteS
 = " Number of buffers = &",0
 ALIGN
 Display R5

 SWI XOS_NewLine

 SWI XOS_WriteS
 = " Blocky offset = ",0
 ALIGN
 Display R6

 SWI XOS_NewLine

 B %BT01

 [ debug=OFF
letters = "0123456789abcdef"
 ]
 ]

;***************************************************************************
FindDiscNameInDiscBuffer ROUT;R0 -> disc name,RETURNS R1 = unique num else -1

;Uses tempbuffer
;***************************************************************************

 STASH "R0, R2 - R9, R14"

 Debug " FindDiscNameInDiscBuffer "

; R2 -> disc name in list
; R5 -> block number list
; R7 -> disc name to search for

 LDR R14, discbuffersize
 TEQ R14, #0
 MOVEQ R1, #-1
 GRABS "R0, R2 - R9, PC", EQ
; MOVEQS PC, R14

 MOV R7, R0

 LDR R2, pointerToBufferList

;****************
; Get a pointer to each discs buffer only if it is the PVD buffer
;****************

01

 LDMIA R2!, { R4, R8, R9, R14 }      ; R4 =disc, R8 -> buffer, R9 = block
                                     ; R14=blocky offset

; [ SIZEOFBUFFERENTRY > 12
; ADD R2, R2, #SIZEOFBUFFERENTRY-12
; ]

 TEQ R8, #0

 MOVEQ R1, #-1                   ; end of list ?
                                 ;
                                 ;
 GRABS "R0, R2 - R9, PC", EQ     ; [ yes ]
; MOVEQS PC, R14                  ;

 TEQ R9, #PVD                    ; Main directory ?
 BNE %BT01                       ; [ no ]

;***************
; Copy the name of the disc into 'tempbuffer'
;***************

 MOV R6, R7

 STASH R2

 ADD R1, R8, #DISCNAMEOFFSETINABUFFER
 ADD R2, R12, #:INDEX:tempbuffer
 MOV R3, #LENGTHOFDISCNAME


 SWI    XCD_ByteCopy

; STASH "R2 - R3"

; BL CopyMemory                  ; R1 -> from, R2 -> to, R3 = length

; GRAB "R2 - R3"


;***************
; Null terminate tempbuffer just in case
;***************

; R0 -> tempbuffer + LENGTHOFDISCNAME - 2

 MOV R0, R2
 MOV R1, #0
 STRB R1, [ R0, #LENGTHOFDISCNAME - 2 ]


;***************

 GRAB R2

; R0 -> disc name

 BL CutSpace

 ADD R4, R0, #LENGTHOFDISCNAME


02                              ; Is disc name in list = disc name ?
                                ;
 Debug " Is discname = listname "

  LDRB R3, [ R0 ], #1           ;
  LDRB R1, [ R6 ], #1           ;

  CMP R0, R4                    ; End of disc name ?
  BGE %BT01                     ; [ yes ]

  TEQ R3, #0                    ;
  TEQEQ R1, #0                  ; If both terminate at same time,must be same
  BEQ %FT03                     ;
                                ;
  TEQ R3, #0                    ;
  TEQEQ R1, #"."                ; If both terminate at same time,must be same
  BEQ %FT03                     ;
                                ;
  TEQ R3, R1                    ;
  BEQ %BT02                     ;
                                ;
                                ; [ no ]

  B %BT01                       ; different, so try another name

03                              ; Found
                                ;
 LDR R1, [ R2, #DISC-SIZEOFBUFFERENTRY ]  ; R1 = disc number


 GRABS "R0, R2 - R9, PC"

;***************************************************************************
AddDirectoryToBuffer ROUT ; R0 = disc, R1 = size, R2 = block, R3->directory
;***************************************************************************

 STASH "R0 - R6, R14"

; Is there enough space to keep the buffer ?

 Debug " KEEP DIRECTORY           "

 LDR R5, disclastpointer
 LDR R14, discbufferpointer
 SUB R5, R5, R14
 LDR R14, discbuffersize

 TEQ R14, #0                  ; No buffer space configured
 GRABS "R0 - R6, PC", EQ      ;

 SUB R5, R14, R5
 ADD R5, R5, #50

 CMP R5, R1                   ; Not enough space left, so try deleting an
 BLLT %FT01                   ; old buffer ( NOT A MAIN DIRECTORY ! )

;****************
; There might be enough space, but are there enough pointers ?
;****************

 LDRB R5, numberofbuffersused
 LDR R14, maxnumberofbuffers
 CMP R5, R14
 BLGE %FT01

;****************

 Debug " PLENTY OF ROOM "

; Claim some space

 STASH "r0, r2"

 MOV       r2, r0

 MOV R0, R1
 BL ClaimMemoryForBuffer       ; R0 = size, RETURNS R1 -> buffer, r2 = disc number

 MOV R4, R0

 GRAB "r0, r2"


; Add the buffer to the list

 BL AddDiscToBufferList     ; R0 = disc, R1 -> buffer, R2 = LBA


; Copy from R3 to the claimed buffer

 MOV R2, R1
 MOV R1, R3
 MOV R3, R4

; BL CopyMemory              ; R1 -> from, R2 -> to, R3 = length
 SWI      XCD_ByteCopy

 GRABS "R0 - R6, PC"


;************************
; This part aims to remove an old buffer that does not hold a main directory
;************************

01

 STASH "R0 - R4, R14"

 Debug "      DELETE OLD BUFFER     "

 LDR R4, pointerToBufferList
 ADD R4, R4, #BLOCK

02

 LDR R1, [ R4 ], #SIZEOFBUFFERENTRY
 LDR       r2, [ R4, #DISC-SIZEOFBUFFERENTRY-BLOCK ]

 TEQ R1, #0                       ; reached end of list with no success
 GRAB "R0 - R3, R14", EQ          ;
 GRABS "R0 - R6, PC", EQ          ;

 TEQ   R1, #PVD                     ; buffer is the main discs directory
 TEQEQ r0, r2
 BEQ %BT02                        ;

; LDR R0, [ R4, #DISC - SIZEOFBUFFERENTRY ]
 LDR R0, [ R4, #DISC-SIZEOFBUFFERENTRY-BLOCK ]

 BL DeleteBuffer                  ; R0 = disc, R1 = block

 Debug " DELETED "

 GRAB "R0 - R4, R14"

 LDR R5, disclastpointer
 LDR R6, discbufferpointer
 SUB R5, R5, R6                  ; R5 = amount used so far
 LDR R6, discbuffersize
 SUB R5, R6, R5
 CMP R5, R1

 GRABS "R0 - R6, PC", LT          ; Still not enough memory

 MOVS PC, R14

;***************************************************************************

 LTORG


 END
