; >Filer

;**************************************************************************
;**************************************************************************
;     This contains the routines called by 'FileMan'
;**************************************************************************
;**************************************************************************

; routines in here:

;                   SetDir                   ; RISC OS 2 only
;                   SetLib                   ; RISC OS 2 only
;                   Nothing
;                   Catalogue                ; RISC OS 2 only
;                   EX                       ; RISC OS 2 only
;                   LCAT                     ; RISC OS 2 only
;                   LEX                      ; RISC OS 2 only
;                   Info                     ; RISC OS 2 only
;                   Boot
;                   ReadBoot
;                   CurrentDirectory
;                   ReadLIBName
;                   CurrentDirObjects
;                   ObjectInfo
;                   ReadEntriesAndLength
;                   CanoncaliseName          ; RISC OS 3 only
;                   ResolveWildcard          ; RISC OS 3 only

;                   SearchRoutine ( see ReadEntriesAndLength etc; )

; DO NOT USE STASHALL UNLESS DIRECTLY AFTER A GRABALL !!!!!!!!1


;**************************************************************************
SetDIR ROUT                 ; 0    *DIR ( pathname$ )
;**************************************************************************

; entry:
;       R0 = 0
;       R1 -> pointer to wildcarded directory name
;       R6 -> special field ( if present )

; exit:
;       ------- nothing

; R6 != 0 to call 'OS_FSControl 0' to set current directory, else == 0 to not set it

; First move to the correct directory, also expand name to whole path
; eg '%.fred' = '$.image03.fred'

; Then save this whole path as the current directory name IF VALID

;--- If '*dir' then *dir &

 log_on

 LDRB R14, [ R1 ]
 TEQ R14, #0
 ADREQ R0, BlankUrd

 MOVNE R0, R1


 [ Version >= 220
      MOV       r6, #1
 ]


SetDir_fixed_for_mount
SetDir_fixed_for_drive

 log_on


;-------------------------------
; Set the current directory.
; This has to ---- around with the stack 'cause of the way that it is abused.
;-------------------------------
 [ Version >= 220

      TEQ       r6, #1

      STASH     "r0-r1", NE
      MOVNE     r1, r0

      LDRNE     r8, stackreturn
      SUBNE     r8, r8, #4*20
      STRNE     r8, stackreturn

      MOVNE     r0, #0
      SWINE     XOS_FSControl

      ADDNE     r8, r8, #4*20
      STRNE     r8, stackreturn

      GRAB      "r0-r1", NE
 ]

;-------------------------------


;************************
; Dir: ( pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number
 MOV R1, #1 ; Looking for a directory
 BL Dir
;************************

 TEQ R2, #DIRECTORY          ; If it is a file, or not found then error
 [ RISC_OS=2
 ADRNEL R0, NotFound
 BNE Error
 |
       MOVNE      r0, #ERROR_NOTFOUND
       BNE        Error
 ]


 LDRB R14, CurrentDriveNumber    ; Preserve drive number for *DIR \

 STRB R14, olddrivenumber        ; used by *DIR \

 STRB R4, CurrentDriveNumber     ; change to that drive

 STASH R0

 MOV R0, R4
 BL PreGetUniqueNumber           ; R0 = drive number, RETURNS R1 = number

 STR R1, CSDDiscNumber

;--- Update the list of discs mounted

 LDR R14, =:INDEX:discsMounted
 ADD R14, R14, R12
 STR R1, [ R14, R0, LSL #2 ]

;--- 

 ; keep the full pathname, eg :FreddyDisc.$.pathname

 [ RISC_OS=2

 LDR R1, =:INDEX:CSD_path ; Copy full path into DIR_path
 ADD R1, R1, R12          ; prefixed with ':'
 MOV R0, #":"             ;
 STRB R0, [ R1 ], #1      ;

 |
  [ Version >= 202
       ADR      r1, TempArea
  ]
 ]

 MOV R0, R4               ; Keep the name of the CSD disc
 MOV R2, R3
 BL GetDiscName           ; R0 = drive, R1 -> place to put name, R2 -> buffer
 MOV R0, R1               ;
 BL CutSpace              ;

 STASH R0                 ; R0 = drive number
 MOV R0, R4               ; R1 -> disc name
 BL AddDiscNameInList     ;
 GRAB R0                  ;

 [ Version < 220
 LengthOfString R1, R2, R3
 ADD R1, R1, R2
 MOV R0, #"."
 STRB R0, [ R1, #-1 ]
 ]

 GRAB R0

;*****************
; Keep a copy of the old directory so that it can be swapped '\'
;*****************

;1. copy from 'CSDPath' to 'BackPath'

; R2 -> CSDPath
; R3 -> BackPath
; R4 = byte


 [ RISC_OS=2

 LDR R2, =:INDEX:CSD_path
 ADD R2, R2, R12

 LDR R3, =:INDEX:BackPath
 ADD R3, R3, R12


01

 LDRB R4, [ R2 ], #1
 STRB R4, [ R3 ], #1
 TEQ R4, #0

 BNE %BT01

;****************
;2. copy from 'Fullpathname' to 'CSDPath'
;****************

; R0 -> FullPathName
; R1 -> CSDPath
; R4 = byte

copy_preserve_path

 LDRB R4, [ R0 ], #1
 STRB R4, [ R1 ], #1
 TEQ R4, #0

 BNE copy_preserve_path
 ] ; RISC OS 2 only




;********************
; Mark the CSD as being selected
;********************

; MOV R0, #SELECTED
; STRB R0, CSDSelected

 GRABALL
 BICS PC, R14, #Overflow_Flag

BlankUrd = "&", 0
 ALIGN


 [ RISC_OS = 2

;**************************************************************************
SetLIB ROUT                ; 1
;**************************************************************************

; on entry:
;          R0 = 1
;          R1 -> wildcarded directory name
;          R6 -> pointer to special field ( 0 if not present )

 log_on

 MOV R0, R1

;*************************
; Dir: ( pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number
 MOV R1, #1  ; looking for a directory
 BL Dir
;*************************
 TEQ R2, #DIRECTORY
 ADRNEL R0, NotFound
 BNE Error

; STRB R4, LibraryDriveNumber ; keep the drive number of the library disc

 ; keep the full pathname, eg :FreddyDisc.$.pathname

;********************
; Copy the name of the disc into the library for that drive
;********************

 STASH R0

 LDR R1, pointertolibandurd ; R1 -> place to put library path in
 MOV R2, #LIBLENGTH         ;
 MLA R1, R2, R4, R1         ;

 MOV R0, #":"             ;
 STRB R0, [ R1 ], #1      ;
 MOV R0, R4               ; Keep the name of the library disc
 MOV R2, R3
 BL GetDiscName           ; R0 = drive, R1 -> place to put name, R2->buffer
 MOV R0, R1               ;
 BL CutSpace              ;

 LengthOfString R1, R2, R3
 ADD R1, R1, R2
 MOV R0, #"."
 STRB R0, [ R1, #-1 ]

 GRAB R0

;****************
;2. copy from 'Fullpathname' to 'LIBPath'
;****************

; R0 -> FullPathName
; R1 -> LIBPath
; R4 = byte

01

 LDRB R4, [ R0 ], #1
 STRB R4, [ R1 ], #1
 TEQ R4, #0

 BNE %BT01             ; ALLOW TO RUN ON !!!!!!!!!!

 ]

;**************************************************************************
Nothing ROUT
;**************************************************************************

 log_on

 GRABALL
 BICS PC, R14, #Overflow_Flag




 [ RISC_OS = 2

;**************************************************************************
LCAT ROUT              ; 4
;**************************************************************************

; on entry:
;          R0 = 4
;          R1 -> path name
;          R6 -> special field ( or 0 )

; on exit:
;         ----------------------- nothing

 log_on

 MOV R0, R1

 LDRB R1, [ R0 ]  ; The offset must be from the library directory
 TEQ R1, #"%"     ; not from the CSD directory
 TEQNE R1, #"\"   ;
 TEQNE R1, #"$"   ;
 TEQNE R1, #"&"   ;
 TEQNE R1, #"@"   ; if 'EQ' then doesn't matter

 BEQ %FT02

 TEQ R1, #0       ; see below

 ADD R1, R12, #:INDEX:tempbuffer ; Prefix path with '%.'

 MOV R3, R1

 MOV R2, #"%"                 ;
 STRB R2, [ R1 ], #1          ; "%."


 MOVNE R2, #"."               ; "below"
 STRNEB R2, [ R1 ], #1        ;


01                            ; R0 -> get path, R1 -> put path, R2 = temp

 LDRB R2, [ R0 ], #1
 STRB R2, [ R1 ], #1
 TEQ R2, #0

 BNE %BT01

 MOV R0, R3


02                    ; R1 -> path

 MOV R1, R0           ; ALLOW TO RUN ON !!!!!!!!!!


 ]


 [ RISC_OS = 2

;**************************************************************************
Catalogue ROUT            ; 2    *CAT ( pathname$ )
;**************************************************************************

; on entry:
;          R0 = 2
;          R1 -> wildcarded directory name ( null terminated )
;          R6 = pointer to special field

; on exit:
;         -------- nothing

 log_on

 MOV R0, R1

;**********************
; Dir: ( pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number
 MOV R1, #1 ; Looking for a directory
 BL Dir
;**********************
 TEQ R2, #DIRECTORY
 ADRNEL R0, NotFound
 BNE Error

 STRB R4, tempdrivenumber

 STASH R1

 MOV R1, R4

 MOV R2, R3
 BL DisplayHeader           ; R0 -> pathname, R1 = drive number see (Open)
                            ; R2 -> disc buffer
 GRAB R1

09

 LDR R2, =:INDEX:buffer
 ADD R2, R2, R12

 LDR R3, [ R1, #0 ]
 TEQ R3, #0
 BEQ %FT05                 ; display_directory

01

 ADD R4, R1, #OBJECTNAMEOFFSET

 ADD R7, R2, #MAXLENGTHOFNAME + 2

02                             ; copy file name into buffer

 LDRB R3, [ R4 ], #1
 TEQ R3, #0
 STRNEB R3, [ R2 ], #1
 BNE %BT02

 MOV R3, #HARDSPACE

03

 STRB R3, [ R2 ], #1
 CMP R2, R7
 BLE %BT03

 LDRB R3, [ R1, #OBJECTTYPEOFFSET ]
 TEQ R3, #FILE
 MOVNE R5, #"D"
 BNE %FT04

 LDRB R3, [ R1, #FILEATTRIBUTESOFFSET ]  ; file attributes
 TST R3, #1                              ; 2_11001 read / not
 MOVNE R5, #"R"
 MOVEQ R5, #HARDSPACE

04

 STRB R5, [ R2 ], #1

 TST R3, #2_1000             ; locked / not
 MOVNE R5, #"L"
 MOVEQ R5, #HARDSPACE
 STRB R5, [ R2 ], #1

 MOV R3, #SPACE
 STRB R3, [ R2 ], #1

 ALIGNREG R4

 LDR R3, [ R4, #0 ]
 TEQ R3, #0
 MOVNE R1, R4
 BNE %BT01

05             ; display_directory

 STRB R3, [ R2 ]



 LDR R0, =:INDEX:buffer
 ADD R0, R0, R12

 MOV R2, R0

 SWI XOS_PrettyPrint              ; Print contents of buffer

; --- Any more blocks in the directory to do ? ---

 LDR R0, tempBlockSize

 CMP   R0, #myblocksize
 MOVLT R0, #myblocksize

 LDR R14, tempLength

 SUBS R14, R14, R0

end_of_cat
 SWILE XOS_NewLine                 ; [ no ]
                                   ;
 GRABALL LE                        ;
 BICLES PC, R14, #Overflow_Flag    ;

 STR R14, tempLength

; Space out the text a bit

 SWI &100+32

 LDR R2, tempBlock
 ADD R2, R2, #MAX_BLOCKS_BUFFERED
 STR R2, tempBlock

 LDR R0, DiscNumberOfDirectoryInBuffer
 BL FindDiscInBufferList                 ; Found details ?
                                         ; RETURNS r1->buffer

 BCC %BT09

 MOV R6, #2

 BL VeryPreStoreDirectory         ; RETURNS EQ if end of dir reached, else NE


; Was block empty ? Just in case of funny discs, ie/ Revalation

 TEQ  R6, #4
 BEQ end_of_cat                       ; [ yes ]

 MOV R2, R0                                ;
 MOV R3, R1                                ;
 MOV R1, R6                                ;
 LDR R0, DiscNumberOfDirectoryInBuffer
 BL AddDirectoryToBuffer      ; R0 = disc, R1 = size, R2 = block, R3->dire

 MOV R1, R3


 B %BT09

 ]



 [ RISC_OS = 2

;**************************************************************************
LEX ROUT                      ; 5   *LEX
;**************************************************************************

; on entry:
;          R0 = 5
;          R1 -> directory name

; on exit:
;         ----------

 log_on

 MOV R0, R1

 LDRB R1, [ R0 ]  ; The offset must be from the library directory
 TEQ R1, #"%"     ; not from the CSD directory
 TEQNE R1, #"\"   ;
 TEQNE R1, #"$"   ;
 TEQNE R1, #"&"   ;
 TEQNE R1, #"@"   ; if 'EQ' then doesn't matter

 BEQ %FT02

 TEQ R1, #0       ; see below

 ADD R1, R12, #:INDEX:tempbuffer ; Prefix path with '%.'

 MOV R3, R1

 MOV R2, #"%"                 ;
 STRB R2, [ R1 ], #1          ; "%."


 MOVNE R2, #"."               ; "below"
 STRNEB R2, [ R1 ], #1        ;


01                            ; R0 -> get path, R1 -> put path, R2 = temp

 LDRB R2, [ R0 ], #1
 STRB R2, [ R1 ], #1
 TEQ R2, #0

 BNE %BT01

 MOV R0, R3


02                       ; R1 -> path

 MOV R1, R0              ; ALLOW TO RUN ON !!!!!!!!!!!!


 ]


 [ RISC_OS = 2

;**************************************************************************
EX ROUT                       ; 3   *EX
;**************************************************************************

; on entry:
;          R0 = 3
;          R1 -> directory name

; on exit:
;         ----------
 log_on

 MOV R0, R1


;***********************
; Dir: ( pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number
 MOV R1, #1  ; Looking for a directory
 BL Dir
;***********************

 TEQ R2, #DIRECTORY          ; Not found, or is a file
 ADRNEL R0, NotFound         ;
 BNE Error                   ;

 STRB R4, tempdrivenumber

 STASH R1

 MOV R1, R4

 MOV R2, R3

 BL DisplayHeader           ; R0 -> pathname, R1 = drive number see (Open)
                            ; R2 -> disc buffer

 GRAB R1

09

 MOV R5, #SIZEOFBUFFER / 100 ; make sure that the buffer is not overwritten !


 LDR R2, [ R1, #0 ]                  ; Empty directory ?
 TEQ R2, #0                          ;
 GRABALL EQ                          ; [ yes ]
 BICEQS PC, R14, #Overflow_Flag      ;

 LDR R4, =:INDEX:buffer      ; R4 -> next free place in buffer
 ADD R4, R4, R12             ;



02

 LDR R2, [ R1, #LBASTARTOFFSET ]     ; last entry done ?
 MOVS R2, R2, LSR #8
 BEQ terminate_buffer


 SUBS R5, R5, #1                     ; Null terminate if at end
 STREQB R5, [ R4 ]                   ;
 LDREQ R0, =:INDEX:buffer            ; Display buffer if chance of overflow
 ADDEQ R0, R0, R12                   ;
 MOVEQ R4, R0
 SWIEQ XOS_PrettyPrint               ;
 MOVEQ R5, #SIZEOFBUFFER / 100       ;

 MOV R2, R4
 BL INFO                 ; R0 -> pathname, R1 -> details, R2 -> print buffer
                         ; RETURNS R2 -> end of buffer

 MOV R4, R2              ; Seperate entries with a NEWLINE
 MOV R2, #NEWLINE        ;
 STRB R2, [ R4 ], #1     ;

 LDRB R2, [ R1, #OBJECTNAMEOFFSET ]!
 TEQ R2, #0

01                       ; Move past name to start of next entry
 LDRNEB R2, [ R1 ], #1   ;
 TEQNE R2, #0            ;
 BNE %BT01               ;


 ALIGNREG R1             ; Move R1 to start of next entry

 B %BT02

; --- Any more blocks in the directory ? ---

terminate_buffer

 STRB R2, [ R4, #-1 ]              ; terminate buffer
 LDR R0, =:INDEX:buffer            ; Display buffer
 ADD R0, R0, R12                   ;
 MOV R1, #0                        ;
 MOV R2, #0                        ;
 SWI XOS_PrettyPrint               ;

; --- Any more blocks ---

 LDR R0, tempBlockSize

 CMP   R0, #myblocksize
 MOVLT R0, #myblocksize

 LDR R14, tempLength

 SUBS R14, R14, R0

end_of_ex
 SWILE XOS_NewLine                   ;
 GRABALL LE                          ; End of list of names
 BICLES PC, R14, #Overflow_Flag      ;

 STR R14, tempLength

 LDR R2, tempBlock
 ADD R2, R2, #MAX_BLOCKS_BUFFERED
 STR R2, tempBlock

 LDR R0, DiscNumberOfDirectoryInBuffer
 BL FindDiscInBufferList                 ; Found details ?
                                         ; RETURNS r1->buffer

 BCC %BT09

 MOV R6, #2

 BL VeryPreStoreDirectory    ; RETURNS EQ if end of dir reached, else NE

; Was block empty ? Just in case of funny discs, ie/ Revelation

 TEQ  R6, #4
 BEQ end_of_ex                       ; [ yes - end ]

 MOV R2, R0                                ;
 MOV R3, R1                                ;
 MOV R1, R6                                ;
 LDR R0, DiscNumberOfDirectoryInBuffer
 BL AddDirectoryToBuffer      ; R0 = disc, R1 = size, R2 = block, R3->dire

 MOV R1, R3

 B %BT09

 ]


 [ RISC_OS = 2

;**************************************************************************
Info ROUT                    ; 6   *INFO
;**************************************************************************

; on entry:
; R0 = 6
; R1 -> path
; R6 -> 

; on exit:
;         nothing

 log_on

; R7 -> last leaf in directory name
; R8 = number found matching wildcarded spec.


;***************
; Find last leaf in path    ; R0 -> path
;***************

 MOV R8, R1                 ; R8 -> 
 MOV R7, R1                 ; R7 -> start of last leaf

01

 LDRB R14, [ R8 ], #1
 TEQ R14, #"."
 MOVEQ R7, R8

 CMP R14, #32
 BGT %BT01

; R1->path name
; R7->leaf name
; R8->end of path

 MOV R14, #0

;--- Any directories specified ?

 TEQ R7, R1
; SUBEQ R7, R8, #1              ; [ no - so use current dir ]
 SUBEQ R0, R7, #1              ; ->0

 STASH R1

 STRNEB R14, [ R7, #-1 ]       ; [ yes-so search for directory ]
 MOVNE R0, R1

; STREQB R14, [ R8, #-1 ]    ; [ no- so search for current directory ]
; ADREQ R0, CURRENTDIR

; STASH R0
; SWI XOS_WriteS
; = "path=:",0
; ALIGN
; SWI XOS_Write0
; SWI &100+":"
; GRAB R0
;***************************
; Dir: ( pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number
 MOV R1, #1 ; Looking for a directory
 BL Dir
;***************************

 GRAB R14

 TEQ R2, #DIRECTORY          ; Not found, or is a file
 ADRNEL R0, NotFound         ;
 BNE Error                   ;

;***************
; Check to see if '*info $'       !!! OK !!!
;***************

; TEQ R7, R0                      ; '*info $' ?
 LDRB R5, [ R14 ]
 TEQ R5, #"$"
 LDREQB R5, [ R14, #1 ]
 TEQEQ R5, #0

 ADREQ R0, MainDirInfo           ; [ yes - Display '$ DL 2048' ]
 SWIEQ XOS_Write0                ;
 SWIEQ XOS_NewLine               ;
 GRABALL EQ                      ;
 BICEQS PC, R14, #Overflow_Flag  ;

;***************

09

 MOV R5, #SIZEOFBUFFER / 100 ; make sure that the buffer is not overwritten !


 LDR R2, [ R1, #LBASTARTOFFSET ]     ; Empty directory ?
 TEQ R2, #0                          ;
 GRABALL EQ                          ;
 BICEQS PC, R14, #Overflow_Flag      ; [ empty - so leave ]


 LDR R4, =:INDEX:buffer      ; R4 -> next free place in buffer
 ADD R4, R4, R12             ;

 MOV R8, #0

another_name_another_day

 LDR R2, [ R1, #LBASTARTOFFSET ]     ; last entry done ?
 TEQ R2, #0                          ;

 BEQ end_of_day

 SUBS R5, R5, #1
 MOVEQ R0, #0
 STREQB R0, [ R4 ]
 LDREQ R0, =:INDEX:buffer            ; Display buffer if chance of overflow
 ADDEQ R0, R0, R12                   ;
 MOVEQ R5, R0
 SWIEQ XOS_PrettyPrint               ;
; LDREQ R4, =:INDEX:buffer            ;
; ADDEQ R4, R4, R12                   ;
 MOVEQ R4, R5
 MOVEQ R5, #SIZEOFBUFFER / 100       ;

 MOV R2, R4

; Only display info if wildcard spec. is same.

 STASH R0 - R3

 MOV R0, R7
 ADD R1, R1, #OBJECTNAMEOFFSET

 BL WildCompareStrings   ; R0 -> wild string, R1 -> norm string, VCLEAR if found

 GRAB R0 - R3

 ADDVC R8, R8, #1        ; R8 = number matched correctly

 ADDVS R5, R5, #1

 BLVC INFO               ; R0 -> pathname, R1 -> details, R2 -> print buffer
                         ; RETURNS R2 -> end of buffer

 MOVVC R4, R2              ; Seperate entries with a NEWLINE
 MOVVC R2, #NEWLINE        ;
 STRVCB R2, [ R4 ], #1     ;

 LDRB R2, [ R1, #OBJECTNAMEOFFSET ]!
 TEQ R2, #0

more_questing_ok         ; Move past name to start of next entry
 LDRNEB R2, [ R1 ], #1   ;
 TEQNE R2, #0            ;
 BNE more_questing_ok    ;

 ALIGNREG R1             ; Move R1 to start of next entry


 B another_name_another_day

;***********
end_of_day
;***********

 STRB R2, [ R4, #-1 ]              ; terminate buffer

 TEQ R8, #0

 ADREQL R0, NotFound               ; None matched wild spec.
 BEQ Error

 LDR R0, =:INDEX:buffer            ; Display buffer
 ADD R0, R0, R12                   ;

 MOV R1, #0                        ;
 MOV R2, #0                        ;
 SWI XOS_PrettyPrint               ;


; --- Any more blocks ---

 LDR R0, tempBlockSize

 CMP   R0, #myblocksize
 MOVLT R0, #myblocksize

 LDR R14, tempLength

 SUBS R14, R14, R0

end_of_info
 SWILE XOS_NewLine                   ;
 GRABALL LE                          ; End of list of names
 BICLES PC, R14, #Overflow_Flag      ;

 STR R14, tempLength

 LDR R2, tempBlock
 ADD R2, R2, #MAX_BLOCKS_BUFFERED
 STR R2, tempBlock

 LDR R0, DiscNumberOfDirectoryInBuffer
 BL FindDiscInBufferList                 ; Found details ?
                                         ; RETURNS r1->buffer

 BCC %BT09

 MOV R6, #2

 BL VeryPreStoreDirectory    ; RETURNS EQ if end of dir reached, else NE

; Was block empty ? Just in case of funny discs, ie/ Revalation

 TEQ  R6, #4
 BEQ  end_of_info

 MOV R2, R0                                ;
 MOV R3, R1                                ;
 MOV R1, R6                                ;
 LDR R0, DiscNumberOfDirectoryInBuffer
 BL AddDirectoryToBuffer      ; R0 = disc, R1 = size, R2 = block, R3->dire

 MOV R1, R3

 B %BT09

MainDirInfo   = "$          DL   "
NAMEDIRECTORY = "Directory"
              = "                      2048  bytes"
              = 0

 ALIGN
CURRENTDIR = "@",0
 ALIGN


 ]


 [ RISC_OS = 2
;**************************************************************************
ReadBoot_OS2 ROUT                ; 11
;**************************************************************************

; on entry:
;          R0 = 11
;          R2 = memory address to put data at   ( how big ??? )
;          R6 = 0 ( cannot specify a context )

; on exit:
;          --------

; Layout of memory:
;                  < length of name byte >< disc name >< boot option byte >
 log_on



;*********************************************************************************
;  R1 must point to full path of CSD
;*********************************************************************************

 LDR R1, =:INDEX:CSD_path



;*********************************************************************************
;  If unset ($ = first char) R5 -> "Unset", R1 = Length
;*********************************************************************************

 LDRB R5, [ R12, R1 ]
 TEQ R5, #"$"
 ADREQ R5, Unset                ; R5 -> "Unset"
 MOVEQ R1, #?Unset              ; R1 = Length of data to copy
 BEQ %FT02                      ;


;*******************
; Make a string ':x', 0 to pass to Dir
;*******************

; R1 -> place to put
; R0 = drive number

 LDRB R0, CurrentDriveNumber
 ADD R1, R12, #:INDEX:OpenedOutString

 MOV R14, #":"
 STRB R14, [ R1 ], #1

; convert R0 to a string in [ R1 ] and DONT FORGET TO TERMINATE !

; R0 = value to be converted
; R1 -> place to put
; R2 = size of buffer

 STASH R2

 MOV R2, #255

 SWI XOS_ConvertCardinal1
 BVS Error

; R0 -> start of buffer + 1
; R1 -> end of string
; R2 = number of bytes free in buffer

 SUB R0, R0, #1

 MOV R14, #"."
 STRB R14, [ R1 ], #1
 MOV R14, #"$"
 STRB R14, [ R1 ], #1
 MOV R14, #0
 STRB R14, [ R1 ]


;*******************

; Dir: R0 -> pathname$
;      RETURN R1 -> block of object info, 0 if not found,
;      RETURN R2 = 1 if a file, 2 if a directory
;      RETURN R3 -> start of disc buffer
;      RETURN R4 = drive number

 MOV R1, #1 ; Looking for a directory
 BL Dir

 TEQ R2, #DIRECTORY          ; If it is a file, or not found then error
 ADRNEL R0, NotFound
 BNE Error


; R1 -> copy from
; R2 -> copy to
; R3 = length of copy

 ADD R1, R3, #DISCNAMEOFFSETINABUFFER
 ADD R2, R12, #:INDEX:TempArea
 MOV R3, #LENGTHOFDISCNAME

 SWI      XCD_ByteCopy

; cutspace

 ADD R0, R12, #:INDEX:TempArea

 BL CutSpace

 GRAB R2

;*********************************************************************************
;  Calculate R5 -> to discname, R1 length of name  
;*********************************************************************************

 MOV R5, R0
 MOV R1, R0

01
 LDRB R3, [R1], #1
 TEQ R3, #0
 BNE %BT01

 SUB R1, R1, R5
 SUB R1, R1, #1


02
 STRB R1, [ R2 ], #1            ; Write length into buffer, R2 -> next free space


;*********************************************************************************
;  Copy exact number of characters in dirname (without 0 terminator) to user buffer
;*********************************************************************************

022
 LDRB R3, [ R5 ], #1            ; R5 -> to next char
 STRB R3, [ R2 ], #1            ; R2 -> to next space in buffer
 SUBS R1, R1, #1                ; No. of bytes to copy
 BNE %BT022

 STRB R6, [ R2 ]                ; boot option = 0


 GRABALL
 BICS PC, R14, #Overflow_Flag

 ]


 [ RISC_OS > 2
;-----------------------------------------------------------------------------------------------
ReadBoot_OS3 ROUT                ; 11
;
; on entry:
;          R0 = 11
;          R2 = memory address to put data at   ( how big ??? )
;          R6 = 0 ( cannot specify a context )
; on exit:
;          --------
; Layout of memory:
;                  < length of name byte >< disc name >< boot option byte >
;
; This is the RISC OS 3 version of ReadBoot
;
;-----------------------------------------------------------------------------------------------

        MOV         r5, r2


        LDRB        r0, CurrentDriveNumber
        BL          TestKnowDisc
        ADD         r1, r1, #DISCNAMEOFFSETINABUFFER 

;------------------------------------
; Copy the name into a RISC OS buffer 
;------------------------------------

        MOV         r2, #0

01
        LDRB        r0, [ r1 ], #1
        STRB        r0, [ r5 ], #1
        ADD         r2, r2, #1
        CMP         r0, #32
        BGT         %BT01

;------------------------------------
; Store the boot option
;------------------------------------
        STRB        r6, [ r5 ]

;------------------------------------
; Store the length byte
;------------------------------------
        STRB        r2, [ r5, -r2 ]


;------------------------------------

        GRABALL
        BICS PC, R14, #Overflow_Flag

 ]






 [ RISC_OS = 2
;**************************************************************************
CurrentDirectory ROUT        ; 12
;**************************************************************************

; on entry:
;          R0 = 12
;          R2 -> place to put information
;          R6 = 0 ( cannot specify a context )

; layout of memory:
; <zero byte> <name length byte> <CSD name> <privilege byte>

 log_on

 STRB R6, [ R2 ], #1


;*********************************************************************************
;  R1 must point to full path of CSD
;*********************************************************************************

 LDR R1, =:INDEX:CSD_path
 ADD R1, R12, R1                ; R1 points to CSD

 

;*********************************************************************************
;  If CSD is unset ($ = first char) R5 -> "Unset", R1 = Length
;*********************************************************************************

 LDRB R5, [ R1 ]
 TEQ R5, #"$"
 ADREQ R5, Unset                ; R5 -> "Unset"
 MOVEQ R1, #?Unset              ; R1 = Length of data to copy
 BEQ %FT02                      ;



;*********************************************************************************
;  Calculate R5 -> to dirname, R1 length of name  
;*********************************************************************************

01                              ; Only return the last branch of the pathname
 LDRB R3, [ R1 ], #1            ; Find where the last dot was
 TEQ R3, #"."                   ;
 MOVEQ R5, R1                   ; R5 -> "dirname"
 TEQ R3, #0                     ;
 BNE %BT01                      ; R1 points to byte after 0 terminator

 SUB R1, R1, R5                 ; ie R1 = (R1 - R5)
 SUB R1, R1, #1                 ;    R1 = Length of "dirname"


02
 STRB R1, [ R2 ], #1            ; Write length into buffer, R2 -> next free space


;*********************************************************************************
;  Copy exact number of characters in dirname (without 0 terminator) to user buffer
;*********************************************************************************

022
 LDRB R3, [ R5 ], #1            ; R5 -> to next char
 STRB R3, [ R2 ], #1            ; R2 -> to next space in buffer
 SUBS R1, R1, #1                ; No. of bytes to copy
 BNE %BT022


 MOV R1, #&00                   ; this gives everyone 'owner' status
 STRB R1, [ R2 ]

 GRABALL
 BICS PC, R14, #Overflow_Flag


 ]



 [ RISC_OS = 2                  ; SMC
Unset = 34, "Unset", 34
 GBLA counter
counter SETA 0
 WHILE counter < MAXLENGTHOFNAME - ?Unset + 2
      = HARDSPACE
counter SETA counter + 1
 WEND
 = 0
 ALIGN
 ]



;**************************************************************************
CurrentDirObjects ROUT       ; 14   ( OS_GBPB 8 )
;**************************************************************************

; This is the same as 15, but only returns the names in the directory

; This is used to make a list of the contents of a directory

;entry:
;      R0 = 14
;      R1 -> pointer to directory name
;      R2 = memory address to put data
;      R3 = number of object names to read
;      R4 = offset of first item to read in directory
;      R5 = buffer length
;      R6 = pointer to special field if present ( network ? )

;exit:

;     R3 = number of records read
;     R4 = offset of next item to read in directory ( -1 if end )

 Debug " 14"
 log_on

 MOV R11, #0
 B SearchRoutine           ; R0 -> routine


 [ RISC_OS = 2
;**************************************************************************
ReadLIBName ROUT         ; 13
;**************************************************************************

 ; see 12, but with LIB path

; on entry:
;          R0 = 12
;          R2 -> place to put information
;          R6 = 0 ( cannot specify a context )

; layout of memory:
; <zero byte> <name length byte> <LIB name> <privilege byte>
 log_on

 Debug "ReadLIBName"

 STRB R6, [ R2 ], #1


;********************
; R1 must point at lib path for current drive
;********************

 LDRB R5, CurrentDriveNumber
 LDR R1, pointertolibandurd
 MOV R3, #LIBLENGTH
 MLA R1, R3, R5, R1

;********************
; If the library is not set, then R5 -> 'Unset'
; The library is unset if first byte of path = 0
;********************


 LDRB R5, [ R1 ]                ; Is the library set ?
 TEQ R5, #0                     ; [ no ]

 ADREQ R5, Unset                ; R5 -> "Unset"
 MOVEQ R1, #?Unset              ; R1 = Length of data to copy
 BEQ %FT02                      ;


;*********************************************************************************
;  Calculate R5 -> to leaf of the library path, R1 length of name  
;*********************************************************************************

01                              ; Only return the last branch of the pathname
 LDRB R3, [ R1 ], #1            ; Find where the last dot was
 TEQ R3, #"."                   ;
 MOVEQ R5, R1                   ; R5 -> "libname"
 TEQ R3, #0                     ;
 BNE %BT01                      ; R1 points to byte after 0 terminator

 SUB R1, R1, R5                 ; ie R1 = (R1 - R5)
 SUB R1, R1, #1                 ;    R1 = Length of "libname"


02
 STRB R1, [ R2 ], #1            ; Write length into buffer, R2 -> next free space


;*********************************************************************************
;  Copy exact number of characters in libname (without 0 terminator) to user buffer
;*********************************************************************************

022
 LDRB R3, [ R5 ], #1            ; R5 -> to next char
 STRB R3, [ R2 ], #1            ; R2 -> to next space in buffer
 SUBS R1, R1, #1                ; No. of bytes to copy
 BNE %BT022


 MOV R1, #&00                   ; this gives everyone 'owner' status
 STRB R1, [ R2 ]


;*********************
; Return to sender
;*********************

 GRABALL
 BICS PC, R14, #Overflow_Flag


 ]


;**************************************************************************
ObjectInfo ROUT             ; 15 ( OS_GBPB 10 )
;**************************************************************************

; This is used to make a list of the contents of a directory

; All the way through, the latest entry is updated into loadaddress,

; execaddress, LBA ( used for copying ), temp4

;entry:
;      R0 = 15
;      R1 -> pointer to directory name
;      R2 = memory address to put data
;      R3 = number of object names to read
;      R4 = offset of first item to read in directory
;      R5 = buffer length
;      R6 = pointer to special field if present ( network ? )

;exit:

;     R3 = number of records read
;     R4 = offset of next item to read in directory ( -1 if end )

 log_on

 Debug "ObjectInfo "

 ADR R11, ObjectInfo15

;**************************************************************************
SearchRoutine ROUT        ; R11 -> routine to call when needed OR 0
;**************************************************************************

; expects the following to be true:

; already STASHALLed

;          R1 -> pointer to path
;          R2 = address of Archy buffer
;          R3 = number of objects to read
;          R4 = offset to read from
;          R5 = buffer length
;          R6 = pointer to special field


; during this procedure:

; R1 = number of objects left to read / or offset so far
; R2 -> current place where data is put in their buffer
; R3 = number of objects to read
; R4 = offset reached
; R5 -> end of buffer
; R6 -> start of entry in my buffer
; R8 = count
; ----R9 = !!!!!! number of object names matching wildcarded name
; ----R10 -> filename
; R11 -> routine to call

; The routine to call can use the following regs safely:
; R0, R7

; Return from your routine with MOV PC, R14

; Bit dodgy 'cause it uses a variable set by the 'Dir' procedure


; MOV R9, #0

 MOV R7, R2
 ADD R5, R5, R2           ; R5 -> end of Archies buffer
 SUB R5, R5, #4

 MOV R0, R1

 [ debug=ON
 STASH R0
 Debug " Pathname passed in = "
 Debug0
 GRAB R0
 ]

;****************
; Find file name from pathname
;****************

; MOV R10, R1

;01

; LDRB R14, [ R1 ], #1
; TEQ R14, #"."
; MOVEQ R10, R1
; TEQ R14, #0
; BNE %BT01

;****************

; LDRB R14, [ R0 ]                 ; If points at 'null' path then point at
; TEQ R14, #0                      ; wild card instead !
; ADREQ R10, WildSentence          ;
;************************
; Dir: ( pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number
 STASH R1 - R4

 MOV R1, #1 ; Must find a directory

 BL Dir

 TEQ R2, #DIRECTORY          ; If it is a file, or not found then error
 [ RISC_OS=2
 ADRNEL R0, NotFound
 BNE Error
 |
           MOVNE      r0, #ERROR_NOTFOUND
           BNE        Error
 ]

 MOV R6, R1        ; R6 CORRECT HERE

 STRB R4, tempdrivenumber




 [ RISC_OS=2


; --- Only bother to search for known details if last<wanted ---

 LDR R14,lastobjectnumber
 LDR R4, [ R13, #4*4 ]

 [ debug=ON
 STASH R14
 Debug " offset= "
 DebugDisplay R4
 GRAB R14
 ]

 CMP R14, R4

 BGT dont_want

 LDR R14, lastdiscnumber
 LDR R4, DiscNumberOfDirectoryInBuffer
 TEQ R4, R14
 BNE dont_want

; Is this the same path as searched last time ?

 STASH "R0-R4"

 LDR R1, =:INDEX:lastdirectory
 ADD R1, R1, R12

13

 LDRB R14, [ R0 ], #1
 LDRB R4, [ R1 ], #1
 TEQ R4, #0              ; End of paths together ?
 TEQEQ R14, #0           ; [ yes ]
 BEQ %FT12

 TEQ R4, R14             ; Paths same ?
 BEQ %BT13               ; [ yes ]

12

 TEQ R4, #0              ; End of paths together ?
 TEQEQ R14, #0           ; [ yes ]

 GRAB "R0-R4"

 BNE dont_want

; tempLength-((lastblocknumber-tempBlock)*tempBlockSize)

 LDR R14, lastblocknumber

 LDR R4, tempBlock
 SUBS R4, R14, R4

; --- Decide whether or not to skip first 2 dummy entries in a directory

 MOVEQ R6, #0
 MOVNE R6, #2

 LDR R8, tempBlockSize
 MUL R4, R8, R4

 LDR R8, tempLength
 SUB R8, R8, R4
 STR R8, tempLength

 LDR R8, lastobjectnumber

 STR R14, tempBlock


 ADR R14, I_ll_be_back
 B %FT09

; Keep a copy of the path to look for, so I can find it quickly next time

dont_want ; could be NE or GT here

 MOV R8, #0
 STR R8, lastobjectnumber

 MOV R1, R0
 LDR R2, =:INDEX:lastdirectory
 ADD R2, R2, R12
 MOV R3, #256

 SWI     XCD_ByteCopy

 ]



 LDR R1, tempBlock
 STR R1, lastblocknumber

 LDR R1, DiscNumberOfDirectoryInBuffer
 STR R1, lastdiscnumber

I_ll_be_back

 GRAB R1 - R4


 MOV R8, #0

;************************

 MOV R2, R7

 ADD R3, R3, R4

02                      ; Move to correct start pos.

 LDR R0, [ R6, #0 ]                   ; Empty directory ?
 TEQ R0, #0                           ;
 BLEQ %FT08                           ; [ yes ]

; --- Reached starting offset ? ---

 CMP R8, R4

 BGE %FT04

 ADD R8, R8, #1

;*****************
; Move to next object in buffer
;*****************

 ADD R6, R6, #OBJECTNAMEOFFSET + 1

03

 LDRB R0, [ R6 ], #1
 TEQ R0, #0
 LDRNEB R0, [ R6 ], #1
 TEQNE R0, #0
 BNE %BT03

 ALIGNREG R6

;*****************

 B %BT02

04

; GRABALL                      Crashes ****
; BICS PC, R14, #Overflow_Flag

 [ debug=ON
 STASH R14
 Debug " Found start pos "
 GRAB R14
 ]

06

 LDR R0, [ R6, #0 ]
 TEQ R0, #0
 BLEQ %FT08

;********************
; Invoke specialised routine ( only if routine specified )
;********************

 TEQ R11, #0

 MOVNE R14, PC

 MOVNE PC, R11

;******************** Returns to this point (!)

 ADD R6, R6, #OBJECTNAMEOFFSET

; R0 -> wild carded string, R1 -> string, RETURNS R3 = SAME / NOT SAME

; MOV R0, R10
; STASH "R1, R3"
; MOV R1, R6
; BL WildCompareStrings
; ADDVC R9, R9, #1
; GRAB "R1, R3"

05

 LDRB R0, [ R6 ], #1
 STRB R0, [ R2 ], #1

 CMP R2, R5                  ; Run out of buffer space ?
 BGT %FT07                   ; [ yes ]

 TEQ R0, #0
 BNE %BT05

 TEQ R11, #0                 ; Only GBPB 9 & 10 need to be aligned
 TSTNE R2, #3                ;
 ADDNE R2, R2, #4            ;
 BICNE R2, R2, #3            ;


 ALIGNREG R6

 ADD R8, R8, #1

 CMP R8, R3

; BLE %BT06
 BLT %BT06



;************
; Done all that was asked for, or filled buffer
;************
07

 [ debug=ON
 STASH R14
 Debug " Filled buffer "
 GRAB R14
 ]

 STR R8, verytemporary

 GRABALL
 LDR R0, verytemporary     ; R3=number of entries read ( matching wildname )
                           ; R4 = next offset
 SUB R3, R0, R4
; SUB R3, R3, #1
; SUB R4, R0, #1
 MOV R4, R0

 BICS PC, R14, #Overflow_Flag

;************
; Reached end of directory, but not end of buffer
; I NOW HAVE TO CHECK TO SEE IF ANY MORE DIRECTORY SPACE

; R14 is return address if needed

;************

08

 [ debug=ON
 STASH R14
 Debug " End of directory "
 GRAB R14
 ]

 LDR R0, tempBlockSize

 CMP   R0, #myblocksize
 MOVLT R0, #myblocksize

 LDR R10, tempLength
 SUBS R10, R10, R0

end_of_search
 STRLE R8, verytemporary
 GRABALL LE                           ;
 LDRLE R3, verytemporary              ; [ yes ]
 SUBLE R3, R3, R4
 MOVLE R4, #-1                        ; ( That was the last entry )
 BICLES PC, R14, #Overflow_Flag       ; GETS HERE, BUT AFTER ?

 STR R10, tempLength

 LDR R6, tempBlock
 ADD R6, R6, #MAX_BLOCKS_BUFFERED
 STR R6, tempBlock

 MOV R6, #2

; Get next directory r2 r3 r4 r5 r6 r7 r8 ON ENTRY r6=2 or 0
09

; --- Keep up to date with object number found

 STASH "R1-R5,R7,R14"

 Debug " 09 "

 LDR R2, tempBlock

 LDR R0, DiscNumberOfDirectoryInBuffer

; r0=disc number, R2 = block, returns r1->buffer, CC if found

 BL FindDiscInBufferList                 ; Found details ?

 MOVCC R6, R1                            ; [ yes ]
 GRAB "R1-R5,R7,PC", CC              ;

; Need to load this by hand

; r0 =start LBA, r1->put here, r3=disc type, r4=blocksize, r5=drive number
; r6=0 then skip 2 entries, else don't RETURNS r6=size used

 BL VeryPreStoreDirectory   ; RETURNS EQ if end of dir reached, else NE

; Was block empty ? Just in case of funny discs, ie/ Revalation

 TEQ  R6, #4
 BEQ  end_of_search    ; [ yes - so exit ]


 MOV R2, R0
 MOV R3, R1

 MOV R1, R6
 MOV R6, R3

 LDR R0, DiscNumberOfDirectoryInBuffer

; R0 = disc, R1 = size, R2 = block, R3->dire

 BL AddDirectoryToBuffer

 GRAB "R1-R5, R7,PC"

WildSentence = "*", 0
 ALIGN

;**************************************************************************
ReadEntriesAndLength ROUT  ; 19 ( OS_GBPB 11 )
;**************************************************************************

; on entry:
;          R0 = 19
;          R1 -> pointer to path
;          R2 = address of Archy buffer
;          R3 = number of objects to read
;          R4 = offset to read from
;          R5 = buffer length
;          R6 = pointer to special field


; on exit:
;         R3 = number of records read
;         R4 = offset of next item to read ( -1 if end )


 Debug " 19 "

 log_on

 ADR R11, ObjectInfo19
 B SearchRoutine        ; R0 -> routine


;**************************************************************************
;**************************************************************************
;**************************************************************************
;**************************************************************************


;**************************************************************************
ObjectInfo15 ROUT
;**************************************************************************
; Corruptable regs: R0, R7, R9, R10

; This corrupts R0 and R7 and R10

 LDR R0, [ R6, #LOADADDRESSOFFSET ]
 LDR R7, [ R6, #EXECUTIONADDRESSOFFSET ]

; CHECK TO SEE IF TIME=0 IF SO, THEN COPY FROM TIMEDATEOFFSET

; TEQ R7, #0

; LDREQB R7, [ R6, #TIMEDATEHIBYTEOFFSET ]
; ORREQ R0, R7, R0
; LDREQ R7, =&FFF00000
; ORREQ R0, R0, R7
; LDREQ R7, [ R6, #TIMEDATEOFFSET ]

 STMIA R2!, { R0, R7 }

 LDR R0, [ R6, #LENGTHOFFSET ]
 LDRB R7, [ R6, #FILEATTRIBUTESOFFSET ]

 LDRB R10, [ R6, #OBJECTTYPEOFFSET ]
 STMIA R2!, { R0, R7, R10 }

 MOV PC, R14

;**************************************************************************
ObjectInfo19
;**************************************************************************

; Corruptable regs: R0, R7, R9, R10

; This corrupts R0 and R7

 LDR R0, [ R6, #LOADADDRESSOFFSET ]
 LDR R7, [ R6, #EXECUTIONADDRESSOFFSET ]

 LDR R10, [ R6, #LENGTHOFFSET ]
 STMIA R2!, { R0, R7, R10 }
 LDRB R10, [ R6, #FILEATTRIBUTESOFFSET ]
 STMIA R2!, { R10 }
; LDR R9, [ R6, #LENGTHOFFSET ]
; LDRB R10, [ R6, #FILEATTRIBUTESOFFSET ]
; STMIA R2!, { R0, R7, R9, R10 }

 LDRB R0, [ R6, #OBJECTTYPEOFFSET ]
 MOV R7, #0                                ; System internal name

 LDR R10, [ R6, #TIMEDATEOFFSET ]           ;
 STMIA R2!, { R0, R7, R10 }                 ;

 LDRB R0, [ R6, #TIMEDATEHIBYTEOFFSET ]    ; Date stamp
 STRB R0, [ R2 ], #1                       ;

 MOV PC, R14

;-----------------------------------------------------------------------------------------------

 [ RISC_OS > 2

CanonicaliseName ROUT
; on entry:
;          r0  = 23
;          r1 -> special field or 0
;          r2 -> disc name or 0
;          r3 -> buffer to hold canonical special field or 0 to return required length
;          r4 -> buffer to hold canonical disc name, or 0 to return required length
;          r5  = length of buffer to hold canonical special field
;          r6  = length of buffer to hold canonical disc name
; on exit:
;          r1 -> canonical special field or 0
;          r2 -> canonical disc name or 0
;          r3 = bytes overflow from special field buffer
;          r4 = bytes overflow from canonical disc name

; See page 4-47 of RISC OS 3 PRMs
;-----------------------------------------------------------------------------------------------


 Debug " ~~CanonicaliseName "

;----------------------------
; Is the disc name required ?
;----------------------------
 TEQ         r2, #0
 BEQ         disc_name_done

 TEQ         r4, #0
 MOVEQ       r6, #0


;--------------------------
; Get the drive number/name
;--------------------------
 MOV         r9, r2


 MOV         r0, #10
 MOV         r1, r2
 SWI         XOS_ReadUnsigned                   ; r2 = value
 MOVVC       r0, r2
 MOVVS       r0, r9
 BLVS        FindDiscNameInList
 MOVVS       r0, r1

;---------------------------------------
; Disc name not found so ask User for it
;---------------------------------------
 CMP         r0, #-1
 LDREQB      r1, CurrentDriveNumber
 MOVEQ       r0, r9
 BLEQ        PromptForDisc
 MOVEQ       r0, r1

;19
 BL          TestKnowDisc                       ; r0 = drive, RETURNS r1 -> buffer
 ADD         r1, r1, #DISCNAMEOFFSETINABUFFER 



;--- Update the list of discs mounted
 STASH       r1
 BL          AddDiscNameInList

 BL          PreGetUniqueNumber           ; R0 = drive number, RETURNS R1 = number

 LDR         r14, =:INDEX:discsMounted
 ADD         r14, R14, R12
 STR         r1, [ r14, r0, LSL #2 ]
 GRAB        r1

;---------------------------------
; Find the length of the disc name, and copy to the caller
;---------------------------------

02

 MOV         r8, #0
01
 LDRB        r14, [ r1 ], #1

 SUBS        r6, r6, #1
 CMPGT       r4, #0
 STRGTB      r14, [ r4 ], #1

 CMP         r14, #32
 ADDGT       r8, r8, #1
 BGT         %BT01

 RSBS        r6, r6, #0
 MOVMI       r6, #0
 STR         r6, verytemporary
 GRABALL
 MOV         r2, r4
 LDR         r4, verytemporary
 BICS        pc, r14, #Overflow_Flag

;---------------------------------

disc_name_done

 GRABALL
 BICS        pc, r14, #Overflow_Flag

 ]

;-----------------------------------------------------------------------------------------------

 [ RISC_OS > 2

ResolveWildcard ROUT
; on entry:
;          r1 -> directory path
;          r2 -> buffer to hold resolved name, or 0
;          r3 -> wildcarded object name
;          r4 ???
;          r5 =  length of buffer
;          r6 -> special field or 0
; on exit: 
;          r1   preserved
;          r2 = -1 if not found, else preserved
;          r3   preserved
;          r4 = -1 if fileswitch should work it out itself, else bytes overflow from buffer
;          r5   preserved
;
; see page 4-48 RISC OS 3 PRMs
;
;-----------------------------------------------------------------------------------------------

 GRABALL
 MOV         r4, #-1
 BICS        pc, r14, #Overflow_Flag


 ]



;-----------------------------------------------------------------------------------------------


 LTORG

 END
