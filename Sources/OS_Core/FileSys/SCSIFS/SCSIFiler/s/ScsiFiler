; > Sources.SCSIFiler
;;----------------------------------------------------------------------------
;; SCSI Filer module
;;
;; Change List
;; -----------
;; 12-Jun-89     0.18    File created by modifying ADFSFiler version 0.18
;; 12-Jun-89     0.19    Check for zero drives - close down if so
;;                      (This also copes with SCSIFS not being present
;; 28-Jul-89     0.20    Display disc name under hard disc icons
;;               ----    Conditional version checking introduced
;; 31-Jul-89            If Wimp 2.21 or later, keep icons on left of bar
;;               0.21    When naming discs, keep icon in same place
;;  1-Sep-89     0.22    Use SCSIFS_TestReady before asking for name
;; 15-Apr-91     0.23    Use *ShowFree -FS SCSI <x> for showing free space.
;; 24-Jul-91     0.24    Detects RISC OS version for 'free'    
;; 09-Jan-92 amg 0.25    Hacked the desktop verify from adfsfiler 0.33 into here
;; 13-Jan-92 DDV         Bug fix: Loading templates under Wimp 2.00 and 2.05
;; 13-Jan-92 DDV         Bug fix: Greying menu items so multiple verify on the same device not possible
;; 16-Jan-92 DAR         Changed version number to 1.10 so all modules in SCSI Card at time of release have same version number.
;; 31-Jan-92 DDV         Added interactive help stuff for menu.
;; 01-Feb-92 DDV/DAR     Fixed (if only Mandy knew the truth) the verify bugs.
;; 01-Feb-92 DDV/DAR     Grey out all options when verifying.
;; 25-Aug-92 JSR         Deal with iconbar icons using PollChange - does removable
;;                              media better.
;;
;;----------------------------------------------------------------------------

                GBLL    bodgedisc
bodgedisc       SETL    {TRUE}          ; needed for old FileCore modules


Module_BaseAddr

        GET     hdr:ListOpts
        GET     hdr:Macros
        GET     hdr:System
        GET     hdr:ModHand
        GET     hdr:FSNumbers
        GET     hdr:HighFSI
        GET     hdr:NewErrors
        GET     hdr:Wimp
        GET     hdr:WimpSpace
        GET     hdr:Messages
        GET     Hdr:MsgTrans
        GET     Hdr:MsgMenus
        GET     hdr:Sprite
        GET     hdr:VduExt
        GET     hdr:Proc
        GET     hdr:Services
        GET     hdr:SCSIFS
        GET     hdr:FileCore
        GET     hdr:ShareD

        GET     Version

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        GBLL    debug
debug   SETL    False

        GET     hdr:Debug
        GET     hdr:HostDebug

        GBLL    debugfo
debugfo SETL    False

        GBLL    debugfom
debugfom SETL   False        
  
                GBLL    debugtask
debugtask       SETL    debug :LAND: False


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Register names
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; sp            RN      r13             ; FD stack
; wp            RN      r12

scy             RN      r11
scx             RN      r10
y1              RN      r9
x1              RN      r8
y0              RN      r7
x0              RN      r6
cy1             RN      r5              ; Order important for LDMIA
cx1             RN      r4
cy0             RN      r3
cx0             RN      r2

; r0,r1 not named

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Macro definitions
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        MACRO
        max     $a, $b
        CMP     $a, $b
        MOVLT   $a, $b
        MEND

        MACRO
        min     $a, $b
        CMP     $a, $b
        MOVGT   $a, $b
        MEND

        MACRO
$label  FixDCB  $n, $string
        ASSERT  ((:LEN:"$string")<$n)
$label  DCB     "$string"
        LCLA    cnt
cnt     SETA    $n-:LEN:"$string"
        WHILE   cnt>0
        DCB     0
cnt     SETA    cnt-1
        WEND
        MEND

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Constants
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

TAB     *       9
LF      *       10
CR      *       13
space   *       32
delete  *       127


bignum          *       &0FFFFFFF

initbrx         *       100
initbry         *       1024-80

brxoffset       *       64
bryoffset       *       64

CMOS_Byte       *       &D0

ReadCMOS        * &A1   ; The OS_Byte call to read CMOS
WriteCMOS       * &A2   ; The OS_Byte call to write CMOS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Data structure offsets
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; format of icon description blocks

                ^       -1
icb_validation  #       1               ; "S" for validation string
icb_drivetype   #       12              ; first byte is "h" or "f"
icb_drivenumber #       3               ; ":n",0

; format of disc name blocks (fixed size, held in main workspace)

                ^       0
drv_number      #       3               ; ":n",0
drv_namelen     #       1               ; length of ":discname"
drv_iconblock   #       4
drv_name        #       48              ; "discname",0
drv_flags       #       1
drv_wasempty    *       1:SHL:0
                #       3
drv_sequence    #       4
drv_size        #       0
drv_shift       *       6
        ASSERT  drv_size = (1 :SHL: drv_shift)
        ASSERT  (drv_iconblock :AND: 3) = 0

len_colon       *       0               ; don't include ":" in discname
len_mediaprefix *       :LEN:"SCSI::"-len_colon

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Workspace allocation
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                ^       0, wp
mytaskhandle    #       4               ; id so we can kill ourselves
FilerHandle     #       4               ; id so we can contact Filer
privateword     #       4
mywimpversion   #       4               ; another wimp version
        [ Version >= 21
wimpversion     #       4
        ]

mousedata       #       0
mousex          #       4
mousey          #       4
buttonstate     #       4
windowhandle    #       4
iconhandle      #       4

menuhandle      #       4
menudir         #       4
menufileblock   #       4
menufilename    #       4

windowx         #       4
windowy         #       4

relmousex       #       4
relmousey       #       4

ndrives         *       4                ; allow for drives 4..7
iconbaricons    #       ndrives*4        ; associate icon handle with index

matchedindex    #       4                ; index of last icon matched

                AlignSpace
ram_menustart   #       0
m_floppydisc    #       m_headersize + mi_size*7
m_namedisc      #       m_headersize + mi_size*1
m_sharedisc     #       m_headersize + mi_size*3
ram_menuend     #       0

mb_namedisc     #       12               ; aligned, with room for terminator

nfloppies       #       4
oldescape       #       4
discnames       #       ndrives*drv_size ; associate index with drive spec.

        [ Version >= 25
FormatState             #       4
FormatList              #       4
FormatWindows           #       4
FormatMenu              #       4
SWICode                 #       16
MaxFormatBarLength      #       4
DiscRecord              #       &100
formattemplate          #       &160
 
 AlignSpace 64
        ]

dirnamebuffer   #       &200

usermsg         #       &100

userdata        #       &200

stackbot        #       &200
stacktop        #       0

SCSIFiler_WorkspaceSize *  :INDEX: @

 ! 0, "SCSIFiler workspace is ":CC:(:STR:(:INDEX:@)):CC:" bytes"


driveno *       m_floppydisc + m_title + :LEN:"SCSI:"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Module header
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        LEADR   Module_LoadAddr

 ASSERT (.=Module_BaseAddr)

        DCD     SCSIFiler_Start        -Module_BaseAddr
        DCD     0 ; SCSIFiler_Init      -Module_BaseAddr
        DCD     SCSIFiler_Die          -Module_BaseAddr
        DCD     SCSIFiler_Service      -Module_BaseAddr
        DCD     SCSIFiler_TitleString  -Module_BaseAddr
        DCD     SCSIFiler_HelpString   -Module_BaseAddr
        DCD     SCSIFiler_CommandTable -Module_BaseAddr


SCSIFiler_HelpString
        DCB     "SCSIFiler"
        DCB     TAB
        DCB     "$VString ($Date)", 0

Desktop_SCSIFiler_Help
        DCB   "The SCSIFiler provides the SCSI icons on the icon bar, and "
        DCB   "uses the Filer to display SCSI directories.",13,10
        DCB   "Do not use *Desktop_SCSIFiler, use *Desktop instead.",0

Desktop_SCSIFiler_Syntax  DCB   "Syntax: *Desktop_"       ; drop through!

SCSIFiler_TitleString     DCB   "SCSIFiler", 0
SCSIFiler_Banner          DCB   "SCSI Filer", 0
                          ALIGN

SCSIFiler_CommandTable      ; Name     Max min

SCSIFiler_StarCommand
        Command Desktop_SCSIFiler,     0, 0

        DCB     0                       ; End of table
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Had *command to enter SCSIFiler, so start up via module handler

Desktop_SCSIFiler_Code ENTRY

        LDR     r14, [r12]
        CMP     r14, #0
        BLE     %FT01

        LDR     r14, [r14, #:INDEX:mytaskhandle]
        CMP     r14, #0
        MOVEQ   r0, #ModHandReason_Enter
        ADREQ   r1, SCSIFiler_TitleString
        SWIEQ   XOS_Module
01
        ADR     r0, ErrorBlock_CantStartSCSIFiler
        SETV
        EXIT

ErrorBlock_CantStartSCSIFiler
        DCD     0
        DCB     "Use *Desktop to start SCSIFiler", 0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SCSIFiler_Service ROUT

        TEQ     r1, #Service_Reset
        BEQ     SCSIFiler_Service_Reset

        TEQ     r1, #Service_FilerDying
        BEQ     SCSIFiler_Service_FilerDying

        TEQ     r1, #Service_StartFiler
        BEQ     SCSIFiler_Service_StartFiler

        TEQ     r1, #Service_ShareFSStarting           ; traps the service call whenever ShareFS module
        BEQ     ShareFS_Service_CallShare              ; are loaded

        TEQ     r1, #Service_StartedFiler
        MOVNE   pc, lr


SCSIFiler_Service_StartedFiler ENTRY

        LDR     r14, [r12]              ; cancel 'don't start' flag
        CMP     r14, #0
        MOVLT   r14, #0
        STRLT   r14, [r12]

        EXIT


SCSIFiler_Service_StartFiler ENTRY "r2,r3,r6"

        LDR     r2, [r12]
        CMP     r2, #0
        EXIT    NE                      ; don't claim service unless = 0

        MOV     r6, r0                  ; Filer task handle
        MOV     r0, #ModHandReason_Claim
        LDR     r3, =SCSIFiler_WorkspaceSize
        SWI     XOS_Module
        MOVVS   r2, #-1                 ; avoid looping
        STR     r2, [r12]

        MOVVC   r0, #0
        
      [ Version >= 25
        STRVC   r0, [r2, #:INDEX:FormatList]
        STRVC   r0, [r2, #:INDEX:FormatState]
        STRVC   r0, [r2, #:INDEX:FormatWindows]
      ]
              
        STRVC   r0, [r2, #:INDEX:mytaskhandle]
        STRVC   r12, [r2, #:INDEX:privateword]
        STRVC   r6, [r2, #:INDEX:FilerHandle]
        ADRVCL  r0, SCSIFiler_StarCommand
        MOVVC   r1, #0                  ; Claim service

        EXIT


SCSIFiler_Service_Reset ENTRY "r0-r6"

        LDR     r2, [r12]               ; cancel 'don't start' flag
        CMP     r2, #0
        MOVLT   r2, #0
        STRLT   r2, [r12]

        MOVGT   wp, r2
        MOVGT   r0, #0                  ; Wimp has already gone bye-bye
        STRGT   r0, mytaskhandle
        BLGT    freeworkspace

        EXITS                           ; Sorry, but no can do errors here

SCSIFiler_Init
        BL      ShareFS_Service_CallShare        
        EXITS

SCSIFiler_Die ROUT

SCSIFiler_Service_FilerDying ENTRY "r0-r6"

        LDR     wp, [r12]
        BL      freeworkspace

        EXITS                           ; Sorry, but no can do errors here

; ******************************************************************************

      [ Version >= 25
        ALIGN
w_format        DCB     "Format",0
                DCD     0,0,0
      ]

; ******************************************************************************

; Corrupts r0-r6

freeworkspace ROUT

        CMP     wp, #0                  ; clears V
        MOVLE   pc, lr

        MOV     r6, lr                  ; can't use stack on exit if USR mode

        LDR     r0, mytaskhandle
        CMP     r0, #0
        LDRGT   r1, taskidentifier
        SWIGT   XWimp_CloseDown         ; ignore errors from this

        MOV     r2, r12
        LDR     r12, privateword
        MOV     r14, #0                 ; reset flag word anyway
        STR     r14, [r12]
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module

        MOV     pc, r6

taskidentifier
        DCB     "TASK"                  ; Picked up as a word
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


CloseDownAndExit ROUT

        BL      freeworkspace
        SWI     OS_Exit

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; OSS New function to copy template name onto the stack and then call
; Wimp_LoadTemplate since the wimp may over-write the name. We were
; lucky to get away with this previously.

; In    r1 -> user block to put template
;       r2 -> core to put indirected icons for template
;       r3 -> end of this core
;       r4 -> font reference array
;       r5 -> name of relevant entry
;       r6 = position to search from

;load_template ENTRY , 16                ; 16 bytes of stack for name
;        MOV     lr, sp
;        Push    "r1, r2"
;        MOV     r1, lr
;        MOV     r2, r5
;        BL      strcpy
;        MOV     r5, r1                  ; And use this name instead
;        Pull    "r1, r2"
;        SWI     XWimp_LoadTemplate
;        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;                   SCSIFiler application entry point
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ErrorAbort
        MOV     r1, #2_010              ; 'Cancel' button
        BL      ReportError             ; stack is still valid here

Abort
        BL      freeworkspace           ; exits with r12 --> private word
        MOV     r0, #-1
        STR     r0, [r12]               ; marked so doesn't loop

        SWI     OS_Exit
                 
message & Message_HelpRequest 
        & 0
        ALIGN

SCSIFiler_Start ROUT

        LDR     wp, [r12]

        CMP     wp, #0   
        ADRLE   r0, ErrorBlock_CantStartSCSIFiler
        SWILE   OS_GenerateError

        ADRL    sp, stacktop            ; STACK IS NOW VALID!

        LDR     r0, mytaskhandle        ; close any previous incarnation
        CMP     r0, #0
        LDRGT   r1, taskidentifier
        SWIGT   XWimp_CloseDown         ; ignore errors from this
                     
        ;got to keep this at 200 so it continues to work with RISC OS 2!   
        MOV     r0, #300                ; latest known Wimp version number
        LDR     r1, taskidentifier
        ADRL    r2, SCSIFiler_Banner
        ADR     r3, message             ; -> message list
        SWI     XWimp_Initialise
        STR     r0,mywimpversion        ; store this for RISC OS 3 test
      [ Version >= 21
        STRVC   r0, wimpversion
      ]
        STRVC   r1, mytaskhandle

        BLVC    CopyMenus               ; copy menus into ram
        BVS     ErrorAbort

        ADR     r1, iconbaricons        ; initialise all icon handles to -1
        MOV     r2, #ndrives            ; (used in AddToIconBar)
        MOV     r14, #-1
01      STR     r14, [r1], #4
        SUBS    r2, r2, #1
        BNE     %BT01

        BL      SetUpIconBar
        BVS     ErrorAbort              ; frees workspace but marks it invalid

        LDR     R14,iconbaricons        ; give up if no drives (or error)
        CMP     R14,#-1
        BEQ     Abort
 
      [ Version >= 25                   ; Load templates.
        LDR     R1,mywimpversion
        CMP     R1,#205                 
        BLE     %FT01                   ; Not if running under 2.00 or 2.05 (A1 and Fox releases!)
      [ debug
        SWI     XOS_WriteS
        =       "Bollocks!!!!",13,10,0
      ]

        ADRL    R1,str_templatefile
        SWI     XWimp_OpenTemplate
        BVS     ErrorAbort

        ADRL    r1,formattemplate
        ADRL    r2,usermsg
        ADD     r3,r2,#?usermsg
        MOV     r4,#-1
        ADR     r5,w_format
        MOV     r6,#0
        SWI     XWimp_LoadTemplate
        BVS     TemplateErrorAbort


; get max size of bar, and mark bar as deleted.

        ADRL    r1,formattemplate+w_icons
        ADD     r1,r1,#3*i_size         ; Third icon is bar.

        LDR     r0,[r1,#i_bbx0]         ; Icon's x0
        LDR     r2,[r1,#i_bbx1]         ; Icon's x1
        SUB     r2,r2,r0
        STR     r2,MaxFormatBarLength
       [ debug
        dreg    r2,"Max format bar length is "
       ]
        SWI     XWimp_CloseTemplate
        BVS     ErrorAbort

        B       %FT01

TemplateErrorAbort
           
        Push    "r0"
        SWI     XWimp_CloseTemplate
        Pull    "r0"
        SETV
        B       ErrorAbort
01                 
        ]         
; .............................................................................
; The main polling loop!

repollwimp ROUT


        MOVVS   r1, #2_011              ; 'Ok' and 'Cancel' buttons
        BLVS    ReportError
        BVS     ErrorAbort              ; error from reporterror!

        MOV     r0, #pointerchange_bits + null_bit
                                        ; disable null events and pointer
        ADR     r1, userdata            ; entering/leaving window events
        LDR     R14,FormatState
        CMP     R14,#0
        BICNE   r0,r0,#null_bit         ; We need null events if formatting

        SWI     XWimp_Poll
        BVS     repollwimp

; In    r1 -> wimp_eventstr

      [ Version >= 33
        CMP     r0, #Open_Window_Request
        BNE     %FT01
        SWI     XWimp_OpenWindow
        B       repollwimp
01
        CMP     r0,#Close_Window_Request
        BNE     %FT01
        SWI     XWimp_CloseWindow
        ADR     lr, repollwimp
        B       Format_CloseWindow
01
        ADR     lr, repollwimp
        CMP     r0,#Null_Reason
        BEQ     Format_NullEvent
      ]
        ADR     lr, repollwimp

        CMP     r0, #Mouse_Button_Change
        BEQ     event_mouse_click

        CMP     r0, #Key_Pressed
        LDREQ   r0, [r1, #24]
        SWIEQ   XWimp_ProcessKey
        BEQ     repollwimp

        CMP     r0, #Menu_Select
        BEQ     event_menu_select

        CMP     r0, #User_Message
        CMPNE   r0, #User_Message_Recorded
        BEQ     event_user_message

        B       repollwimp                               

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; event_mouse_click
; =================

; In    r1 -> wimp_eventstr
;             [r1, #0]  pointer x
;             [r1, #4]          y
;             [r1, #8]  new button state
;             [r1, #12] window handle (-1 if background/icon bar)
;             [r1, #16] icon handle (-1 if none)

; Out   all regs may be corrupted - going back to PollWimp

event_mouse_click ENTRY

        LDMIA   r1, {r0-r4}             ; set mousex, mousey, buttonstate
        ADR     r14, mousedata          ; windowhandle, iconhandle
        STMIA   r14, {r0-r4}
 [ debug
 dreg r2, "mouse_click: buttonstate ",cc,Word
 dreg r0, ", x ",cc,Integer
 dreg r1, ", y ",cc,Integer
 dreg r3, ", window ",,Word
 ]

        CMP     r3, #iconbar_whandle    ; window handle of icon bar
       [ Version >= 25
        BNE     Format_MouseClick
      |
        EXIT    NE
      ]
        EXIT    NE

        TST     r2, #button_left :OR: button_right ; select or adjust ?
        BNE     click_select_iconbar

        TST     r2, #button_middle      ; menu ?
        BNE     click_menu_iconbar

        EXIT

; .............................................................................
; We get here if the user has double-clicked on a FS icon

; In    lr stacked, Proc_RegList = "lr" for EXIT
;       all regs trashable

click_select_iconbar ROUT

        BL      matchdriveicon          ; r1 -> drive spec, eg. :4
        BLVC    GetMediaName            ; r1 -> media name
        EXIT    VS
        EXIT    NE                      ; user chickened out!

; Try to open dir using Filer

        LDR     r0, =Message_FilerOpenDir
        BL      messagetoFiler
        EXIT

; In    r0 = message action
;       r1 -> media name

messagetoFiler ENTRY

        SUB     sp, sp, #256            ; make temp frame for message
        STR     r0, [sp, #message_action]
        MOV     r2, r1
        ADD     r1, sp, #message_data
        MOV     r14, #fsnumber_SCSIFS   ; FileSystem = SCSI
        STR     r14, [r1], #4
        MOV     r14, #0                 ; bitset = 0
        STR     r14, [r1], #4
        BL      strcpy_advance
        ADR     r2, dotdollar
        BL      strcpy_advance
        ADD     r1, r1, #1
        ADR     r2, dollar
        BL      strcpy_advance
        ADD     r1, r1, #1
        TST     r1, #3                  ; word aligned end ?
        ADDNE   r1, r1, #3              ; round up to word size
        BICNE   r1, r1, #3
        SUB     r1, r1, sp
        STR     r1, [sp, #message_size]
        MOV     r0, #User_Message_Recorded
        MOV     r1, sp
 [ debugtask
 ADD r14, r1, #message_data+8
 dstring r14, "passing dirname to Filer: "
 ]
        LDR     r2, FilerHandle        ; send it to the Filer
 [ debugtask
 BEQ %FT00
 dreg r2, "Filer task handle "
00
 ]
        SWI     XWimp_SendMessage
        ADD     sp, sp, #256            ; free temp frame
        EXIT


dotdollar       DCB     "."             ; share $ with ...
dollar          DCB     "$", 0          ; directory title
                ALIGN


; Offsets of fields in a message block

                ^       0
message_size    #       4
message_task    #       4               ; thandle of sender - filled in by Wimp
message_myref   #       4               ; filled in by Wimp
message_yourref #       4               ; filled in by Wimp
message_action  #       4
message_hdrsize *       @
message_data    #       0               ; words of data to send

; .............................................................................
; In    lr stacked, Proc_RegList = "lr" for EXIT
;       all regs trashable

        MACRO
$l      Shade   $menu, $item, $cc1, $cc2
$l      LDR     r14, m_$menu+m_headersize+mi_size*mo_fl_$item+mi_iconflags
        ORR$cc1 r14, r14, #is_shaded
      [ "$cc1" <> ""
        BIC$cc2 r14, r14, #is_shaded
      ]
        STR     r14, m_$menu+m_headersize+mi_size*mo_fl_$item+mi_iconflags
        MEND

        MACRO
$l      Tick    $menu, $item, $cc1, $cc2
$l      LDR     r14, m_$menu+m_headersize+mi_size*mo_fl_$item+0
        ORR$cc1 r14, r14, #mi_it_tick
      [ "$cc1" <> ""
        BIC$cc2 r14, r14, #mi_it_tick
      ]
        STR     r14, m_$menu+m_headersize+mi_size*mo_fl_$item+0
        MEND

; Check which bits are to be updated in CMOS

        MACRO
$l      Write   $type
$l      MOV     r3, #SCSIbit$type 
        BL      WriteCMOSbits             ; set S/P bit in CMOS -> 1
        MEND        

        MACRO
$l      Clear   $type
$l      MOV     r3, #SCSIbit$type 
        BL      ClearCMOSbits             ; clear S/P bit in CMOS
        MEND

click_menu_iconbar ROUT
        BL      matchdriveicon            ; r1 -> drive number (eg. :0)
        EXIT    VS

      [ Version >= 025
        LDR     R14,[R1,#drv_number+1]    ; get the drive number
        AND     R14,R14,#&F               ; extract only the meaingful bits
        LDR     R2,FormatState
        MOV     R2,R2,LSR R14             ; get bit indicating what is going one
        ANDS    R2,R2,#1                  ; are we verifying or not?
        Shade   floppydisc, namedisc, NE, EQ
        Shade   floppydisc, dismount, NE, EQ
        Shade   floppydisc, share, NE, EQ
        Shade   floppydisc, verify, NE, EQ
        Shade   floppydisc, free, NE, EQ
      ]

        Shade   floppydisc, format
        Shade   floppydisc, backup

        MOV     r0, #ModHandReason_LookupName    ; call OS_Module 18 to check if ShareD
        ADR     r1, Sharemodule                  ; module has been loaded; if not, then
        SWI     XOS_Module                       ; shade share entry in the ADFS menu
        BVC     %FT03
        Shade   floppydisc, share
        B       %FT04
03        
        BLVC    scan_CMOS
04
        BL      getdrivename
        ADR     r1, m_floppydisc
        BL      CreateMenu
        EXIT

getdrivename    ENTRY
        ADR     r1, driveno
        BL      GetMediaName          ; r1 -> media name (VC)
        EXIT    VS
        EXIT    NE
        ADR     r1, dirnamebuffer
        MOV     r7, r1
        ADD     r2, r1, #:LEN:"scsi::"
        ADR     r1, mb_namedisc           ; name of the disc
        BL      strcpy
        MOV     r1, r7
02
        LDRB    r6, [r1], #1
        TEQ     r6, #0
        BNE     %BT02

        SUB     r1, r1, #1
        ADR     r2, dotdollar1             ; add ".$/0" to path
        BL      strcpy_advance

        MOV     r2, r7
        ADR     r1, mb_namedisc
        EXIT

Sharemodule     DCB     "ShareFS"                ; module for sparrow share module
                DCB     0
                ALIGN

; Entry:  R4 = icon handle (in icon bar)
; Exit:   R1 --> drive spec for this drive

matchdriveicon  ENTRY "r2"

        MOV     r2, #ndrives
        ADR     r1, iconbaricons
01
        LDR     r14, [r1], #4
        TEQ     r14, r4
        RSBEQ   r2, r2, #ndrives
        STREQ   r2, matchedindex            ; needed for namedisc
        ASSERT  drv_number = 0
        ADREQ   r1, discnames + drv_number
        ADDEQ   r1, r1, r2, LSL #drv_shift
        LDREQB  r14, [r1, #drv_number+1]    ; initialise drive number (for menu)
        STREQB  r14, driveno+1
        EXIT    EQ                          ; r1 -> drive spec
        SUBS    r2, r2, #1
        BNE     %BT01
        ADR     r0, err_noicon
        SETV
        EXIT

err_noicon
        DCD     0
        DCB     "Unknown iconbar icon",0
        ALIGN


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; A menu is created with the title above the x,y values you feed it, with the
; top left hand corner being at the x,y position

CreateMenu ENTRY "r2, r3"

        STR     r1, menuhandle
        LDR     r2, mousex
        SUB     r2, r2, #4*16
        MOV     r3, #96 + 7*44        ; bodge to clear icon bar
        SWI     XWimp_CreateMenu
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        GBLS    menusym
        GBLA    menuwidth
        GBLA    itemnumber

        ASSERT  (.-rom_menustart) = ($label-ram_menustart)
$menusym.base                           ; a label to get offsets relative to
        FixDCB  12, "$title"            ; title (12 bytes)
        DCB     7, 2, 7, 0              ; colours
        DCD     $menusym.width*16+12    ; char width = 16 always
        DCD     44                      ; item height (chars = 32 always)
        DCD     0                       ; vertical gap between items
        MEND

menuiconflags  *  (0:SHL:ifb_bcol):OR:(7:SHL:ifb_fcol):OR:if_filled:OR:if_text

        MACRO
$label  ItemI   $buffer,$writelen,$writewidth,$submenu,$end,$validation
$label  *       itemnumber
itemnumber SETA itemnumber + 1
  [ menuwidth < $writewidth
menuwidth SETA  $writewidth
  ]
        LCLA    menuitemflags
menuitemflags SETA 0
 [ "$writelen" <> ""
menuitemflags SETA menuitemflags + mi_it_writeable
 ]
 [ "$end"="-"
menuitemflags SETA menuitemflags + mi_it_dotted
 |
  [ "$end"="X"
menuitemflags SETA menuitemflags + mi_it_lastitem
$menusym.width * menuwidth
  ]
 ]
        DCD     menuitemflags
 [ "$submenu"=""
        DCD     -1
 |
        DCD     $submenu._base-rom_menustart
 ]
        DCD     menuiconflags :OR: if_indirected
 [ "$writelen"<>""
        DCD     :INDEX: $buffer         ; offset of string in ws
   [ "$validation"<>""
        DCD     $validation-rom_menustart
   |
        DCD     -1
   ]
        DCD     $writelen
 |
        DCD     $buffer-rom_menustart   ; offset from menu start in ROM
        DCD     0                       ; 0 or -1 both mean no validation
        DCD     1                       ; forget length unless writeable
 ]
        MEND


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

rom_menustart ; Note - must be defined in the same order as the ram menus

m_floppydisc    Menu    "T00"                   ; must be "ADFS::n"
mo_fl_namedisc  Item    "M01",m_namedisc
mo_fl_dismount  Item    "M02"
mo_fl_format    Item    "M03",,N                ; floppies only
mo_fl_backup    Item    "M04"                   ; floppies only
mo_fl_share     Item    "M05",m_sharedisc
mo_fl_verify    Item    "M06"
mo_fl_free      Item    "M07"

m_backup        Menu    "T04"                   ; this menu is optional
mo_fl_backup0   Item    "M14"                   ; (only supplied if >1 floppy)
mo_fl_backup1   Item    "M24"
mo_fl_backup2   Item    "M34"
mo_fl_backup3   Item    "M44"

m_namedisc      Menu    "T01"
mo_nm_newname   Item    "M11",,W

m_sharedisc     Menu    "T02"
mo_fl_notsh     Item    "M12"
mo_fl_prot      Item    "M22"
mo_fl_unprot    Item    "M32"

                DCB     0                       ; terminator

mv_namedisc     DCB     "A~$&%@\\^:.#*""| ", 0  ; disallow funny chars

        [ Version >= 40
OtherFormatsToken       DCB     "OForms",0
CurrentFormatToken      DCB     "CFormat",0
UnknownFormatToken      DCB     "UKForm",0
UnformattedToken        DCB     "UFormed",0
EmptyToken              DCB     "NoDisc",0
FileCorePercentADFS     DCB     "FileCore%ADFS",0
        ]
                ALIGN


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; CopyMenus
; =========

; Copy menu structures into ram, relocating as we go

CopyMenus ENTRY "r0-r11"

        ADR     r1, rom_menustart       ; src^
        ADR     r2, ram_menustart       ; dst^
        MOV     r10, r2                 ; offset to add to submenu ram ptrs
        MOV     r11, r1                 ; offset to add to indirect ROM strings
        ADR     r0, rom_menuend

01      LDMIA   r1!, {r3-r9}            ; menu header (28 bytes)
        STMIA   r2!, {r3-r9}

02      LDMIA   r1!, {r3-r8}            ; menu item (24 bytes)
        CMP     r4, #-1                 ; submenu pointer (-1 -> no submenu)
        ADDNE   r4, r4, r10             ; add menu base address (in ram)
                                        ; to submenu pointer
        TST     r5, #if_indirected
        BEQ     %FT03

        CMP     r7, #0                  ; is it a dynamic string in ws ?
        ADDEQ   r6, r6, r11             ; add offset to string in ROM
        ADDNE   r6, r6, wp              ; add offset to string in ws
        ADDGT   r7, r7, r11             ; r7 --> validation string if present

03      STMIA   r2!, {r3-r8}
        TST     r3, #&80
        BEQ     %BT02

        CMP     r1, r0
        BNE     %BT01

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;                                       

; event_menu_select
; =================

; In    r1 -> wimp_eventstr

; Out   all regs may be corrupted - going back to PollWimp

event_menu_select ENTRY
        MOV     r2, r1                  ; r2 -> menu selection list
        LDR     r1, menuhandle          ; r1 = menu handle
        BL      DecodeMenu

        ADRVCL  r1,userdata             ; check for right-hand button
        SWIVC   XWimp_GetPointerInfo
        EXIT    VS

        LDR     R14,userdata+8          ; get button state
        TST     R14,#&01
        LDRNE   R1, menuhandle
        SWINE   XWimp_CreateMenu        ; here we go again!

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; In     r1 = menu handle
;        r2 -> list of selections

DecodeMenu ENTRY

decodelp
        LDR     r14, [r2], #4            ; r1 = selection no
        ADD     pc, pc, r14, LSL #2
        EXIT

        B       go_fl_namedisc
        B       go_fl_dismount
        B       go_fl_format
        B       go_fl_backup
        B       go_fl_share
        B       go_fl_verify
        B       go_fl_free

error_namedisc  DCD     1
                DCB     "Disc name must be at least two characters long"
                DCB     0
                ALIGN

go_fl_namedisc
        LDR     r14, [r2], #4           ; must select submenu
        TEQ     r14, #0
        EXIT    NE


        LDRB    r14, mb_namedisc        ; check that new name is >= 2 chars
        CMP     r14, #32
        LDRHSB  r14, mb_namedisc+1
        CMPHS   r14, #32
        ADRLO   r0, error_namedisc
        SETV    LO
        EXIT    VS

        ADR     r1, driveno             ; re-read media name
        BL      GetMediaName_nochecks   ; can be duplicate
        EXIT    VS

        BL      checkambiguous
        EXIT    NE                      ; some other error

        LDRVC   r0, =Message_FilerCloseDir
        BLVC    messagetoFiler          ; only close if NOT ambiguous already

        ADRL    r3, namedisc
        BL      copycommand
        ADR     r2, mb_namedisc
        BL      strcpy
        ADRL    r0, userdata
 [ debug
 dstring r0, "namedisc: "
 ]
        SWI     XOS_CLI
        EXIT    VS

        LDR     r4, matchedindex
        ADR     r1, discnames + drv_iconblock
        LDR     r1, [r1, r4, LSL #drv_shift]
        BL      AddToIconBar

        ADRVC   r1, driveno             ; don't allow this to clash!
        BLVC    GetMediaName            ; delete old/new disc

        EXIT

go_fl_dismount
        ADR     r1, driveno             ; re-read media name
        BL      GetMediaName_nochecks   ; r1 -> "SCSI::discname"
        BLVC    dismountit
        LDRVCB  r1, driveno+1
        SUBVC   r1, r1, #"0"
        MOVVC   r0, #Misc_Eject
        SWIVC   XSCSIFS_MiscOp
        EXIT

go_fl_format

SCSIcolon       DCB     "SCSI:",0
namedisc        DCB     "Namedisc n ",0
                ALIGN
dismount        DCB     "Dismount n ",0         ; NB space still needed
format          DCB     "Format :n ",0
backup          DCB     "Backup n ",0           ; NB ':' not accepted here
verify          DCB     "Verify :n ",0
showfree        DCB     "ShowFree -FS SCSI n ",0
free            DCB     "Free :n ",0
lde             DCB     "LDE"                   ; table of 3 bytes
                ALIGN

go_fl_backup


go_fl_share    ; Tick the entry
         
        LDR     r4, [r2], #4
        CMP     r4, #mo_fl_notsh        ; check if 'not shared' has being selected
        BEQ     unset_share
        CMP     r4, #mo_fl_prot         ; check if 'protected' has being selected
        BEQ     set_prot
        CMP     r4, #mo_fl_unprot       ; check if 'unprotected' has being selected
        BEQ     set_unprot
        EXIT  
    
go_fl_verify   
        [ Version >= 25
        LDR     r1,mywimpversion
        CMP     r1,#205
        BGT     Format_GoVerify
        ]
        ADR     r1, driveno             ; stop ambiguous disc names
        BL      GetMediaName
        EXIT    VS
        EXIT    NE
        ADR     r3, verify
        BL      copycommand
        B       gocommand_window

go_fl_free
        ADR     r1, driveno             ; stop ambiguous disc names
        BL      GetMediaName
        EXIT    VS
        EXIT    NE
        LDR     r2,mywimpversion
        CMP     r2,#205
        ADRLE   r3, free
        ADRGT   r3, showfree
        BL      copycommand
        
        CMP     r2, #205                ; check for interactive/non-interactive
        BNE     gocommand_window


interactive_command ENTRY
        ADR     r0, userdata
      [ debug
        DSTRING r0,"Interactive command is : "
        DREG    r13,"r13 is "  
      ]
        SWI     XWimp_StartTask         ; needs a new domain
      [ debug
        DREG   r13,"New Task started"
      ]
        EXIT

gocommand_window
        ADRL    r0, userdata+:LEN:"SCSI:"
        SWI     XWimp_CommandWindow
        EXIT    VS
        ADRL    r0, userdata
 [ debug
 dstring r0, "commandwindow: "
 ]
        SWI     XOS_CLI
        BVC     %FT01

        SWI     XOS_NewLine
        ADD     r0, r0,#4
        SWI     XOS_Write0
        SWI     XOS_NewLine

01
        MOV     r0, #0
        SWI     XWimp_CommandWindow
        EXIT

; In    r1 -> "SCSI::discname"
; Out   dismounted, and any dirs 'SCSI::discname' closed

dismountit ENTRY "r1"
        LDR     r0, =Message_FilerCloseDir
        BL      messagetoFiler
        ADR     r3, dismount
        BL      copycommand
        SUB     r1, r1, #2              ; r1 -> original drive number
        LDR     r2, [sp]                ; r2 -> "SCSI::discname"
        ADD     r2, r2, #:LEN:"SCSI::"  ; r2 -> discname
        BL      strcpy
        ADRL    r0, userdata
 [ debug
 dstring r0, "dismountit: "
 ]
        SWI     XOS_CLI
        EXIT

; In    [driveno+1] = drive number
;       r3 -> prototype command
; Out   [userdata..] = "SCSI:<command> <drive no>"
;       r1 -> terminator (drive number inserted at [r1,#-2])

copycommand ENTRY
        ADRL    r1, userdata
        ADR     r2, SCSIcolon
        BL      strcpy_advance
        MOV     r2, r3
        BL      strcpy_advance
        LDRB    r14, driveno+1          ; get drive number
        STRB    r14, [r1,#-2]
        EXIT

; share stuff

set_prot   ROUT

        ADR     r1, m_sharedisc
        BL      EncodeMenu

        MOV     r2,#mo_fl_prot
        BL      TickMenu

        Tick    floppydisc, share, NE, EQ       ; tick share
        Shade   floppydisc, namedisc, NE, EQ    ; shade name_disc
        Shade   floppydisc, verify, NE, EQ      ; shade verify

        MOV     r0, #1                   ; r0 -> 1 = protected
        BL      SetShareD                ; If ticked, then change type of sharing
        EXIT

set_unprot   ROUT
        ADR     r1, m_sharedisc
        BL      EncodeMenu

        MOV     r2,#mo_fl_unprot
        BL      TickMenu
        
        Tick    floppydisc, share, NE, EQ       ; tick share
        Shade   floppydisc, namedisc, NE, EQ    ; shade name_disc
        Shade   floppydisc, verify, NE, EQ      ; shade verify

        MOV     r0, #0                   ; r0 -> 0 = unprotected
        BL      SetShareD                ; If ticked, then change type of sharing
        EXIT

unset_share     ROUT                     ; First of all check if not shared is already ticked
        MOV     r2, #mo_fl_notsh         ;unprot
        ADR     r1, m_sharedisc 
        ADD     r1, r1, #m_headersize + mi_itemflags
        ADD     r2, r2, r2, LSL #1
        LDR     r1, [r1, r2, LSL #3]
        CMP     r1, #mi_it_tick
        BEQ     %FT01

        ADR     r1, m_sharedisc
        BL      EncodeMenu

        MOV     r2,#mo_fl_notsh
        BL      TickMenu
        
        Shade   floppydisc, namedisc, EQ, NE    ; unshade name_disc
        Shade   floppydisc, verify, EQ, NE      ; unshade verify
        Tick    floppydisc, share, EQ, NE       ; untick share

        BL      UnSetShareD               ; calls Shared_StopShare
01
        EXIT

; ShareD_CreateShare
; Calls Shared_CreateShare

SetShareD       ENTRY
        MOV     r10, r0
        ADR     r1, driveno

        BLVC    GetMediaName          ; r1 -> media name (VC)
        EXIT    VS
        EXIT    NE
        ADR     r1, dirnamebuffer
        MOV     r7, r1
        ADD     r2, r1, #:LEN:"scsi::"
        ADR     r1, mb_namedisc           ; name of the disc
        BL      strcpy
        MOV     r1, r7
02
        LDRB    r6, [r1], #1
        TEQ     r6, #0
        BNE     %BT02

        SUB     r1, r1, #1
        ADR     r2, dotdollar1             ; add ".$/0" to path
        BL      strcpy_advance

        MOV     r2, r7                    ; r2 -> "scsi::mb_namedisc.$"
        ADR     r1, mb_namedisc           ; r1 -> "mb_namedisc"
        MOV     r0, r10                   ; type of sharing

        SWI     XShareD_CreateShare       ; calls shared_createshare 
        BVC     %FT01

        MOV     r1, #2_001                ; 'Ok' button
        BL      ReportError               ; error if shared_createshare fails
        BVS     ErrorAbort                ; error from reporterror!
        Tick    floppydisc, share, EQ, NE ; untick share
        ADR     r1, m_sharedisc           ; tick not shared
        BL      EncodeMenu
        MOV     r2,#mo_fl_notsh
        BL      TickMenu

        LDR     R1, menuhandle
        SWI     XWimp_CreateMenu          ; here we go again!

        BL      UnSetShareD               ; calls Shared_StopShare
        B       %FT98
01                                        ; check if unprotected option is ticked; if it is
        CMP     r10, #0                   ; EQ -> protected unticked
        BEQ     %FT90
        Write   P                         ; set P bit in CMOS -> 1
        B       %FT92
90      
        Clear   P                         ; set P bit in CMOS -> 0
92
        Write   S                         ; set S bit in CMOS -> 1
98
        EXIT

dotdollar1       DCB     "."             ; share $ with ...
dollar1          DCB     "$", 0          ; directory title
                 ALIGN

; Calls ShareD_StopShare

UnSetShareD     ENTRY
        BL      ReadCMOSbits              ; get in r2 current state of CMOS
        MOV     r3, #SCSIbitS             ; load mask for shared drive
        AND     r0, r2, r3                ; clear bit not needed
        CMP     r0, #SCSIbitS
        BNE     %FT01                     ; the disc is already not shared: why unshare it again?

        ADR     r1, driveno
        BL      GetMediaName          ; r1 -> media name (VC)
        EXIT    VS
        EXIT    NE
        ADR     r1, dirnamebuffer
        MOV     r7, r1
        ADD     r2, r1, #:LEN:"scsi::"
        ADR     r1, mb_namedisc           ; name of the disc
        BL      strcpy
        MOV     r1, r7
02
        LDRB    r6, [r1], #1
        TEQ     r6, #0
        BNE     %BT02

        SUB     r1, r1, #1
        ADR     r2, dotdollar1             ; add ".$/0" to path
        BL      strcpy_advance

        MOV     r2, r7                    ; r2 -> "scsi::mb_namedisc.$"
        ADR     r1, mb_namedisc           ; r1 -> "mb_namedisc"

        BIC     r0, r0, r0
   ;     ADR     r1, mb_namedisc           ; r1 -> namedisc
        SWI     XShareD_StopShare         ; calls shared_stopshare

        Clear   S                         ; set S bit in CMOS -> 0
        Clear   P                         ; set P bit in CMOS -> 0
01
        EXIT

; Scan the CMOS bits and update the menu flags however needed
scan_CMOS      ENTRY
        BL      ReadCMOSbits              ; get in r2 current state of CMOS
        MOV     r3, #SCSIbitS             ; load mask for shared drive
        AND     r0, r2, r3                ; clear bit not needed
        CMP     r0, #SCSIbitS
        BNE     %FT01
        Shade   floppydisc, namedisc, EQ, NE    ; shade name_disc
        Shade   floppydisc, verify, EQ, NE      ; shade verify
        Tick    floppydisc, share, EQ, NE ; tick share if equal
        BL      ReadCMOSbits              ; get in r2 current state of CMOS
        MOV     r3, #SCSIbitP             ; load mask for protected/unprotected
        AND     r0, r2, r3                ; clear bit not needed to check if P bit of drive 4 is set
        CMP     r0, #SCSIbitP
        BLEQ    tick_protected            ; if P bit is set then tick the entry in the menu
        BLNE    tick_unprotected          ; and set reg 0 to 1
        B       %FT05
01      BL      tick_notshared            ; if cmos is 0 then click not shared
05
        EXIT

tick_protected  ENTRY                     ; tick protected option
        ADR     r1, m_sharedisc
        BL      EncodeMenu
        MOV     r2, #mo_fl_prot
        BL      TickMenu
        EXITS

tick_notshared  ENTRY                     ; tick not shared option
        ADR     r1, m_sharedisc
        BL      EncodeMenu
        MOV     r2, #mo_fl_notsh
        BL      TickMenu
        EXITS

tick_unprotected ENTRY                    ; tick unprotected option
        ADR     r1, m_sharedisc
        BL      EncodeMenu
        MOV     r2, #mo_fl_unprot
        BL      TickMenu
        EXITS

; procedures to clear/read/write CMOS bits (byte &6B)

ReadCMOSbits    ENTRY                     ; Out: r2 -> content of location &D0 (ADFS CMOS bits)
        MOV     r0, #ReadCMOS
        MOV     r1, #CMOS_Byte
        SWI     XOS_Byte
        EXITS

WriteCMOSbits   ENTRY                     ; r3 -> bit mask to write under
        BL      ReadCMOSbits              ; r2 -> current state of CMOS &D0
        ORR     r2, r2, r3                ; merge the bits
        MOV     r0, #WriteCMOS
        MOV     r1, #CMOS_Byte            ; store the result
        SWI     XOS_Byte
        EXITS

ClearCMOSbits   ENTRY                     ; r3 -> bit mask to write under
        BL      ReadCMOSbits              ; r2 -> current state of CMOS &D0
        EOR     r3, r3, #&FF              ; reverse mask
        AND     r2, r2, r3                ; clear the bit
        MOV     r0, #WriteCMOS
        MOV     r1, #CMOS_Byte            ; store the result
        SWI     XOS_Byte
        EXITS

SCSIbitS         *   2_01000000           ; masks
SCSIbitP         *   2_10000000

ShareFS_Service_CallShare ENTRY
        LDR     wp, [r12]
        CMP     wp, #0
        EXIT    LE

        BL      ReadCMOSbits              ; get in r2 current state of CMOS
        MOV     r3, #SCSIbitS             ; load mask for share drive 4
        AND     r0, r2, r3                ; clear bit not needed
        CMP     r0, #SCSIbitS
        ADREQ   r1, sh_winnie4            ; get info for drive 4 
        BLEQ    Service_CallShareFS

        EXITS

sh_winnie4      DCB     ":4",0
                ALIGN

Service_CallShareFS ENTRY                 ; gets disc info and calls ShareFS_CreateShare
        MOV     r9, r1
        MOV     r0, r1
        ADR     r1, userdata + &80
        SWI     XSCSIFS_DescribeDisc
        EXIT    VS
        MOV     r14, #0
        STRB    r14, [r1, #32]            ; ensure name is terminated

        ADD     r3, r1, #22               ; r3 -> disc name
        ADR     r2, discsuffix
        BL      strcpy

        MOV     r2, r3
        BL      strcatsh                  ; r1 -> adfs::namedisc
        ADR     r2, dotdollar3
        BL      strcatsh                  ; r1 -> adfs::namedisc.$ (0 terminated)
        
        ADR     r2, terminate             ; r1 -> namedisc (0 terminated)
        MOV     r4, r1        
        MOV     r1, r3
        BL      strcatsh
        MOV     r7, r1     ; r7 -> namedisc
        BL      ReadCMOSbits
        MOV     r3, #SCSIbitP             ; load mask for protected/unprotected
        AND     r0, r2, r3                ; clear bit not needed to check if P bit of drive 4 is set
        CMP     r0, #SCSIbitP
        BNE     %FT90
        MOV     r0, #1
90 
        MOV     r1, r7
        MOV     r2, r4
        SWI     XShareD_CreateShare       ; calls shared_createshare 
        
        BVC     %FT01
        MOV     r1, #2_001                ; 'Ok' button
        BL      ReportError               ; error if shared_createshare fails
        BVS     ErrorAbort                ; error from reporterror!
01
        EXITS

terminate        DCB     "", 0            ; zero termination
dotdollar3       DCB     "."              ; share $ with ...
dollar3          DCB     "$", 0           ; directory title
                 ALIGN

discsuffix       DCB     "scsi::",0
                 ALIGN

; A couple of procedure to tick and check sharedisc submenu 
; In    r1 -> menu

EncodeMenu ENTRY "r0, r1"

        ADD     r1, r1, #m_headersize     ; skip menu header

01      LDR     r0, [r1, #mi_itemflags]

        BIC     r0, r0, #mi_it_tick       ; ensure all unticked to start with
        STR     r0, [r1, #mi_itemflags]

        LDR     r14, [r1, #mi_iconflags]!
        BIC     r14, r14, #is_shaded      ; ensure none greyed out
        STR     r14, [r1], #(mi_size - mi_iconflags)

        TST     r0, #mi_it_lastitem       ; last item in menu?
        BEQ     %BT01                     ; [no]

        EXIT

; In    r1 -> menu
;       r2 = item to tick
; Out   item marked as ticked, flags preserved

TickMenu ENTRY "r1, r2"
        ADD     r1, r1, #m_headersize + mi_itemflags ; skip menu header
                                          ; and item fields before itemflags
   ASSERT mi_size = 24
        ADD     r2, r2, r2, LSL #1        ; *3
        LDR     r14, [r1, r2, LSL #3]     ; *24
        ORR     r14, r14, #mi_it_tick     ; 'tick' corresponding entry
        STR     r14, [r1, r2, LSL #3]
        EXITS


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In     r1 -> drive spec eg. :0

; Out    r1 -> media name (in dirnamebuffer) - "SCSI::discname"

GetMediaName ENTRY "r1-r3"

getmedialoop

        BL      GetMediaName_nochecks
        STR     r1, [sp]                ; ensure r1 correct on return

        BL      checkambiguous
        EXIT    VC
        EXIT    NE                      ; V set, so don't worry about Z

; generate suitable warning message for the user

        ADRL    r3, dismount
        BL      copycommand             ; dismount by drive number
        ADRL    r0, userdata
 [ debug
 dstring r0, "ambiguous: "
 ]
        SWI     XOS_CLI
        EXIT    VS

        LDR     r1, [sp]                ; dismount by disc name (inc. dirs)
      [ Version >= 42
        BL      dismountit
      |
        BL      dismountit
      ]

        ADR     r1, driveno
        B       getmedialoop            ; try again!

      ; NOEXIT


checkambiguous ENTRY "r1-r5"

        MOVVC   r0, #OSFile_ReadInfo    ; see if we get "ambiguous disc name"
        SWIVC   XOS_File
        TEQVC   r0, r0                  ; ensure Z set!
        EXIT    VC

        LDR     r14, [r0]               ; check error number
        LDR     r2, =&1089E             ; "ambiguous disc name"
        TEQ     r14, r2
        EXIT

        LTORG

GetMediaName_nochecks ENTRY "r1-r7"

        MOV     r0, r1
        ADR     r1, userdata + &80
        SWI     XSCSIFS_DescribeDisc
        EXIT    VS
        MOV     r14, #0
        STRB    r14, [r1, #32]          ; ensure name is terminated

        ADD     r3, r1, #22             ; r3 -> disc name

        LDRB    r14, [r3]               ; r3 -> disc name
        CMP     r14, #delete            ; (delete or <= space) = terminator
        CMPNE   r14, #space             ; if null, recover drive number instead

        LDRLS   r3, [sp, #0]            ; r1in = ':4' etc
        ADDLS   r3, r3, #1              ; r3 -> '4' etc
 [ debug
 dstring r3, "ADFS returned name "
 ]

        ADR     r1, dirnamebuffer
        STR     r1, [sp, #0]            ; return 'scsi::DiscName' or 'scsi::4'
        addr    r2, SCSIcolon
        BL      strcpy_advance

        MOV     r14, #":"               ; Append ':'
        STRB    r14, [r1], #1
        MOV     r2, r3
        BL      strcpy_space            ; Append discname: not strcat !

 [ debug
        ADR     r14, dirnamebuffer
        DSTRING r14, "GetMediaName:"
 ]

        EXIT        

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Out   cx0, cy0 = coords of mouse pointer
;       other regs corrupt

GetPointerInfo ROUT

        Push    "r1, r2-r6, lr"         ; poke pointer info into stack

        ADD     r1, sp, #4
        SWI     XWimp_GetPointerInfo
        LDMVCIA r1, {cx0, cy0}

        LDR     r1, [sp], #6*4          ; Restore r1, kill temp frame
        Pull    "pc"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Set up icon bar entries for SCSI
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Out   much corruption

        MACRO
$label  IconDef $sprite, $drvspec, $title
        DCB     "   S"             ; for the validation string entry
$label  FixDCB  12, "$sprite"      ; label --> here
        DCB     "$drvspec", 0
        MEND

ic_winnie4      IconDef "harddisc", ":4"
ic_winnie5      IconDef "harddisc", ":5"
ic_winnie6      IconDef "harddisc", ":6"
ic_winnie7      IconDef "harddisc", ":7"
                ALIGN

SetUpIconBar ENTRY

        SWI     XSCSIFS_Drives
        EXITS   VS                      ; r2 := no of winnies
        MOV     r3, r1                  ; r3 := no of floppies
        STR     r3,nfloppies            ; used by *Backup code

        MOV     lr, #0
        STRB    lr, discnames + 4*drv_size + drv_flags
        STR     lr, discnames + 4*drv_size + drv_sequence
        STRB    lr, discnames + 5*drv_size + drv_flags
        STR     lr, discnames + 5*drv_size + drv_sequence
        STRB    lr, discnames + 6*drv_size + drv_flags
        STR     lr, discnames + 6*drv_size + drv_sequence
        STRB    lr, discnames + 7*drv_size + drv_flags
        STR     lr, discnames + 7*drv_size + drv_sequence

        MOV     r4, #0                  ; r4 = icon handle index

        ADR     r1, ic_winnie7
        CMP     r2, #4
        BLGE    AddToIconBar
        EXIT    VS

        ADR     r1, ic_winnie6
        CMP     r2, #3
        BLGE    AddToIconBar
        EXIT    VS

        ADR     r1, ic_winnie5
        CMP     r2, #2
        BLGE    AddToIconBar
        EXIT    VS

        ADR     r1, ic_winnie4
        CMP     r2, #1
        BLGE    AddToIconBar
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 -> block:
;               12 bytes of sprite name, preceded by 'S' (for the Wimp)
;               3 bytes of drive spec. (eg. ":0", 0)
;       r4 = index of next free item in icon table
;       [iconbaricons,R4,LSL #2] = icon to replace

; Out   r0 = icon handle
;       r4 = index of next free item in icon table

AddToIconBar ENTRY "r1-r3, r5"

      [ Version >= 22
        LDRB    r1, [r1, #icb_drivenumber+1]
        AND     r1, r1, #&F                     ; In:  R1 = drive number (4..7)
        SWI     XSCSIFS_TestReady               ; Out: R0=0 => drive not present
        LDR     r1, [sp]                        ;      R0=1 => drive not ready
        EXIT    VS                              ;      R0=2 => drive ready

        TEQ     R0,#0                           ; should only happen first time
        EXIT    EQ                              ; so no need to deallocate

        ADD     r2, r1, #icb_drivenumber        ; for later

        TEQ     R0,#1                           ; if drive not ready,
        ADDEQ   r3, r1, #icb_drivenumber        ; don't try to read the name
        BEQ     %FT01
        ADD     r1, r1, #icb_drivenumber
      |
        ADD     r1, r1, #icb_drivenumber
        MOV     r2, r1                          ; r2 -> drive number
      ]
        BL      GetMediaName
        EXIT    VS

      [ Version >= 22
        LDRB    r14, [r1, #len_mediaprefix+1]   ; if name is 1 character long,
        CMP     r14, #" "                       ; the disc is in fact unnamed
        ADRLT   r3, unnamed                     ; r3 -> disc name
        ADDGE   r3, r1, #len_mediaprefix        ; must not start with ":"
      |
        ADD     r3, r1, #len_mediaprefix        ; r3 -> disc name
      ]
01
        ADR     r5, discnames
        ADD     r5, r5, r4, LSL #drv_shift
        ADD     r1, r5, #drv_number
        BL      strcpy                          ; copy in drive number
        ADD     r1, r5, #drv_name
        MOV     r2, r3
        BL      strcpy_advance                  ; should be enough room

        SUB     r14, r1, r5
        SUB     r14, r14, #drv_name
        STRB    r14, [r5, #drv_namelen]

        LDR     r1, [sp]                ; r1 -> drive block
        STR     r1, [r5, #drv_iconblock]

        ADR     r2, iconbaricons        ; r2 -> iconbaricons
        LDR     r3, [r2, r4, LSL #2]!   ; r2 -> [icon to open next to]
        BL      AllocateIcon            ; r5 -> drive number/name
        EXIT    VS

        STR     r0, [r2]                ; save new handle
        ADD     r4, r4, #1

        MOV     r1, #-2                 ; delete previous icon, if any
        Push    "r1,r3"
        MOV     r1, sp
        CMP     r3, #0
        SWIGE   XWimp_DeleteIcon
        ADD     sp, sp, #8

        EXIT

      [ Version >= 22
unnamed DCB     "<unnamed>", 0
        ALIGN
      ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 -> icon description (icb_etc)
;       r2 -> [handle of icon to open next to]
;       r4 = icon index
;       r5 -> drive description (drv_etc)

; Out   r0 = icon handle (created on iconbar)

AllocateIcon ENTRY "r1-r5, x0, y0, x1, y1"

        MOV     r2, r1
        MOV     r0, #SpriteReason_ReadSpriteSize
        SWI     XWimp_SpriteOp                  ; r3, r4 = pixel size

        MOVVC   r0, r6                          ; creation mode of sprite

        MOVVC   r1, #VduExt_XEigFactor
        SWIVC   XOS_ReadModeVariable
        MOVVC   x0, #0
        ADDVC   x1, x0, r3, LSL r2              ; pixel size depends on sprite

        MOVVC   r1, #VduExt_YEigFactor
        SWIVC   XOS_ReadModeVariable
        MOVVC   y0, #20                         ; sprite baseline
        ADDVC   y1, y0, r4, LSL r2
        MOVVC   y0, #-16                        ; text baseline

        EXIT    VS

        ASSERT  x0 > r5
        LDMIA   sp,{r1-r5}                      ; we need r1 and r5

        LDRB    r4, [r5, #drv_namelen]          ; include name in icon
        CMP     x1, r4, LSL #4                  ; 16 OS units per char
        MOVLT   x1, r4, LSL #4

        ADRL    r14, userdata
        MOV     r0, #-2                         ; lhs of icon bar
        STMIA   r14!, {r0, x0, y0, x1, y1}      ; window handle, icon coords
        LDR     r0, iconbariconflags            ; r0 = icon flags
        ADD     r2, r5, #drv_name               ; r2 -> drive name/number
        ADD     r3, r1, #icb_validation         ; r3 -> validation string
        STMIA   r14, {r0, r2-r4}                ; r4 = length of text

        ADRL    r1, userdata
      [ Version >= 21
        LDR     r14, wimpversion        ; if Wimp version 2.21 or later,
        CMP     r14, #221
        BLT     %FT01
        LDMIA   sp, {r0, r2-r4}         ; check previous icon handle
        LDR     r0, [r2]                ; [r2] = previous handle
        CMP     r0, #0                  ; if creating for the first time,
        RSBLTS  r14, r4, #0             ; if this is not the first icon,
        LDRLT   r0, [r2, #-4]           ; open to right of previous icon
        MOVLT   r14, #-4                ; -4 => open to right of icon
        MOVGE   r14, #-3                ; -3 => open to left of icon / iconbar
        STR     r14, [r1, #u_handle]
01
      ]
        SWI     XWimp_CreateIcon
        EXIT                            ; returns r0 = icon handle

iconbariconflags
        DCD     &1700310B       ; text
                                ; sprite
                                ; h-centred
                                ; indirected
                                ; button type 3
                                ; fcol 7, bcol 1

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; strcat
; ======
;
; Concatenate two strings

; In    r1, r2 -> CtrlChar/r3 terminated strings

; Out   new string in r1 = "r1" :CC: "r2" :CC: 0

strcat ENTRY "r1-r3"

        MOV     r3, #space-1

05      LDRB    r14, [r1], #1           ; Find where to stick the appendage
        CMP     r14, #delete            ; Order, you git!
        CMPNE   r14, r3
        BHI     %BT05
        SUB     r1, r1, #1              ; Point back to the term char

10      LDRB    r14, [r2], #1           ; Copy from *r2++
        CMP     r14, #delete            ; Order, you git!
        CMPNE   r14, r3                 ; Any char <= r3 is a terminator
        MOVLS   r14, #0                 ; Terminate dst with 0
        STRB    r14, [r1], #1           ; Copy to *r1++
        BHI     %BT10

        EXITS

; .............................................................................
;
; strcpy
; ======
;
; Copy a string and terminate with 0

; In    r1 -> dest area, r2 -> CtrlChar/r3 terminated src string

strcpy ALTENTRY

        MOV     r3, #space-1            ; terminate on ctrl-char
        B       %BT10

strcpy_space ALTENTRY

        MOV     r3, #space              ; terminate on space or ctrl-char
        B       %BT10


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; strcpy_advance
; ==============

; In    r1 -> dest string
;       r2 -> source string

; Out   r1 -> terminating null

strcpy_advance ENTRY "r2"

10      LDRB    r14, [r2], #1           ; Copy from *r2++
        CMP     r14, #delete            ; Order, you git!
        CMPNE   r14, #space-1           ; Any char < space is a terminator
        MOVLS   r14, #0                 ; Terminate dst with 0
        STRB    r14, [r1], #1           ; Copy to *r1++
        BHI     %BT10

        SUB     r1, r1, #1
        EXITS

strcatsh ENTRY "r1-r3"

        MOV     r3, #space

05      LDRB    r14, [r1], #1           ; Find where to stick the appendage
        CMP     r14, #delete            ; Order, you git!
        CMPNE   r14, r3
        BHI     %BT05
        SUB     r1, r1, #1              ; Point back to the term char

10      LDRB    r14, [r2], #1           ; Copy from *r2++
        CMP     r14, #delete            ; Order, you git!
        CMPNE   r14, r3                 ; Any char <= r3 is a terminator
        MOVLS   r14, #0                 ; Terminate dst with 0
        STRB    r14, [r1], #1           ; Copy to *r1++
        BHI     %BT10

        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; event_user_message (and _recorded)
; ==================

; In    r1 -> wimp_eventstr
;             [r1, #0]     block size
;             [r1, #12]    your ref
;             [r1, #16]    message action
;             [r1, #20...] message data

; Out   all regs may be corrupted - going back to PollWimp

event_user_message

        LDR     r0, [r1, #message_action]
                             
        LDR     R2, =Message_HelpRequest
        TEQ     R0, R2
        BEQ     help                            ; apt really ...

        CMP     r0, #Message_Quit
        MOVNE   PC,LR

        B       CloseDownAndExit

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r1 = state for ReportError
; Out   r1 = 1 (OK) or 2 (Cancel)

ReportError ENTRY "r2"

        ADRL    r2, SCSIFiler_Banner
        SWI     XWimp_ReportError
        EXIT

        [ Version >= 25
        ; special reversion of message token routines
        
;..............................................................................

; In    r0 -> token string
;       r1 -> buffer to copy message into
;       r2 = size of buffer (including terminator)
;       r3 -> parameter 0
;       [messagedata] -> message file descriptor (0 => not yet loaded)
; Out   message file loaded if not already loaded
;       [r1..] = message, terminated by 0
;       r2 = size of string, including the terminator

lookuperror
lookuptoken ENTRY "r0-r7"

 [ debug
;  dstring r0, "Look up token "
;  dstring r3, "Parameter 0 "
 ]
   ; copy [r0] to [r1] until =0, incrementing r2
   ; if we encounter a %, don't copy it, but copy [r3] until 0
 
        MOV R2,#0
        MOV R5,#0
lookup1
        LDRB R4,[R0,R2]
        STRB R4,[R1,R5]
        ADD R2,R2,#1  
        CMP R4,#'%'
        BEQ lookup2
        ADD R5,R5,#1     ;it's here to ensure that the % gets overwritten

        CMP R4,#0
        BNE lookup1
        STR R5,[sp,#2*4] ;set the length up
        EXIT                               

lookup2
        MOV R6,#0
lookup3
        LDRB R7,[R3,R6]
        STRB R7,[R1,R5]
        ADD R6,R6,#1
        ADD R5,R5,#1
        CMP R7,#0
        BEQ lookup1
        B lookup3
        ]
               
        ; Note - use of adfs here *is* intentional!
        [ Version >= 25
str_templatefile DCB     "ADFSFiler:Templates", 0
        ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; return interactive help on a menu item/icon.

; in    R1 -> message block
; out   -

help    Push    "R1,LR"
                   
        LDR     R2,[R1,#32]                     ; get the window handle
        CMP     R2,#-2                          ; is it the icon baaah?
        ADREQ   R2,icon                         ; -> message to return
        BEQ     help_returnmessage

        MOV     R0,#1                           ; return list of menu items - as if selected
        LDR     R3,[R1,#36]                     ; get the icon handle

        ADR     R1,dirnamebuffer                     
        SWI     XWimp_GetMenuState
        Pull    "R1,PC",VS     

        LDR     R0,[R1] 
        ADR     R2,menu00                       ; setup for first layer of menu
        CMP     R0,#-1                          ; is there a first item?
        Pull    "R1,PC",EQ,^                    ; don't bother if no items selected

        LDR     R14,[R1,#4]
        CMP     R14,#-1                         ; is there a second layer item?
        MOVNE   R0,R14
        ADRNEL  R2,menu10                       ; if there is then point at that list of messages 
10
        SUBS    R0,R0,#1
        BMI     help_returnmessage              ; have found the token, count has become -1

15      LDRB    R1,[R2],#1
        TEQ     R1,#0
        BNE     %BT15                           ; loop back until the end of the string has been reached
        B       %BT10                      
                        
help_returnmessage
        Pull    "R1"

        ADD     R0,R1,#20
25      LDRB    R3,[R2],#1
        STRB    R3,[R0],#1
        TEQ     R3,#0                           ; have we finished copying the string yet?
        BNE     %BT25                           ; loop back until done then
                            
        SUB     R0,R0,R1                        ; get the size of the message
        ADD     R0,R0,#3
        BIC     R0,R0,#3
        STR     R0,[R1,#ms_size]                ; store size of new message (word aligned)
                                               
        LDR     R0,=Message_HelpReply
        STR     R0,[R1,#ms_action]              ; store the message ID

        LDR     R0,[R1,#ms_myref]
        STR     R0,[R1,#ms_yourref]             ; swap these babys around and send it back!

        MOV     R0,#User_Message
        LDR     R2,[R1,#ms_taskhandle]
        SWI     XWimp_SendMessage               ; suck on this Help task!

        Pull    "PC"                            ; R1 pulled previously
         
icon    = "This is a SCSI Disc drive icon|MClick SELECT to display the root directory of this disc.",0

menu00  = "Move the pointer right to alter the name of this disc.",0
        = "Click SELECT to dismount this disc.",0
        = "Format option.|MTo format a SCSI disc please use the SCSIDM application.",0
        = "Backup option.|MNot supported under SCSIFS.",0 
        = "Move the pointer right to share the disc.",0
        = "Click SELECT to verify this SCSI disc.|MIf there are any defects found, use the SCSIDM application to map them out.",0
        = "Click SELECT to determine the free space on this disc.",0 
     
menu10  = "Enter the new disc name and press Return.",0

menu40  = "Click select if you don't want to share the disc.",0
        = "Click select if you want to share the disc protected.",0
        = "Click select if you want to share the disc unprotected.",0

        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;        LTORG
; [ Version >= 25
;MenuTitleFlags  DCD     &00070207       ; Flags for menu title
; ]
  
 ; my AASM here can't handle this, so....
 [ 0=1
 [ Version >= 25
CondLink        SETS    " LNK Format"
 ]
$CondLink                                
 ]
          
 LNK s.format

        END
