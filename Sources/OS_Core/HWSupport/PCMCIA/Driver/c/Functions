/*****************************************************************************************/
/***                                                                                   ***/
/***  Functions.c                                                                      ***/
/***                                                                                   ***/
/***  Application:   PCMCIA_Drv Module                                                 ***/
/***  Version:       0.03                                                              ***/
/***                                                                                   ***/
/***  By:            N.Critchell, W.Turner, Acorn Computers Ltd.                       ***/
/***  Date:          10th August 1993                                                  ***/
/***                                                                                   ***/
/***  Purpose:       Contains the code to handle the PCMCIA Driver Function routines.  ***/
/***                                                                                   ***/
/***  History:       0.01 10th August 1993 - Original version                          ***/
/***                 0.02 7th July 1994 - Modified considerably due to FS review (WT)  ***/
/***                 0.03 12th July 1994 - further modified as part of a restructuring ***/
/***                                                                                   ***/
/*****************************************************************************************/

/*****************************************************************************************/
/***                                                                                   ***/
/***  Routines:-                                                                       ***/
/***    PCMCIADriver_FunctionHandler()                                                 ***/
/***    Function_VersionFeatures()                                                     ***/
/***    Function_HardwareConfiguration()                                               ***/
/***    Function_GetCardStatus()                                                       ***/
/***    Function_GetMemMapAddress()                                                    ***/
/***    Function_ResetCard()                                                           ***/
/***    Function_SelectPage()                                                          ***/
/***    Function_SelectDataMode()                                                      ***/
/***    Function_SelectMemorySpace()                                                   ***/
/***    Function_SelectCardVoltage()                                                   ***/
/***    Function_SelectProgrammingVoltage()                                            ***/
/***    Function_SelectAccessTiming()                                                  ***/
/***    Function_IRQHandlerInstall()                                                   ***/
/***    Function_IRQHandlerUnInstall()                                                 ***/
/***    Function_SaveSlotState()                                                       ***/
/***    Function_RestoreSlotState()                                                    ***/
/***    Function_CardInitialise()                                                      ***/
/***    Function_CardFinalise()                                                        ***/
/***    Function_CardPresent()                                                         ***/
/***    Function_CardDetectInitialise()                                                ***/
/***    Function_CardDetectFinalise()                                                  ***/
/***                                                                                   ***/
/*****************************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "time.h"

#include "Defs.h"
#include "Structs.h"
#include "Hardware.h"
#include "Variables.h"
#include "Functions.h"
#include "Misc.h"
#include "Error.h"
#include "HWOps.h"

#include "Debug.h"


/*****************************************************************************************/
/***                                                                                   ***/
/***  PCMCIADriver_FunctionHandler(registers, pw)                                      ***/
/***                                                                                   ***/
/***  This function is called when the PCMCIA Support Code wants to access a low       ***/
/***  level driver routine. The function parses the reason code passed in R0 and if    ***/
/***  valid, calls the appropiate functions to perform the requested operation.        ***/
/***                                                                                   ***/
/***  On exit:                                                                         ***/
/***    R0 = 0, if sucessful                                                           ***/
/***    R0 = Error pointer, if error occured.                                          ***/
/***    R1 - R9, returned parameters.  (See functions)                                 ***/
/***                                                                                   ***/
/***  Return:                                                                          ***/
/***    1, Do not claim the IRQ (not IRQ routine)                                      ***/
/***                                                                                   ***/
/*****************************************************************************************/
int PCMCIADriver_FunctionHandler(_kernel_swi_regs *reg, void *pw)
    {
    PCMCIADriver_ErrorCode      error = NO_ERROR;

    /*************************************************************************************/
    /***        Handle the Specified Function.                                         ***/
    /*************************************************************************************/

    switch(reg ->r[0])
        {
    case DRV_FUNCTION__GET_SOFTWARE_FEATURES:
        error = Function_VersionFeatures(reg);
        break;

    case DRV_FUNCTION__GET_HARDWARE_CONFIG:
        error = Function_HardwareConfiguration(reg);
        break;

    case DRV_FUNCTION__GET_CARD_STATUS:
        error = Function_GetCardStatus(reg);
        break;

    case DRV_FUNCTION__GET_MEM_MAP_ADDRESS:
        error = Function_GetMemMapAddress(reg);
        break;

    case DRV_FUNCTION__RESET_CARD:
        error = Function_ResetCard(reg);
        break;

    case DRV_FUNCTION__SELECT_PAGE:
        error = Function_SelectPage(reg);
        break;

    case DRV_FUNCTION__SELECT_DATA_MODE:
        error = Function_SelectDataMode(reg);
        break;

    case DRV_FUNCTION__SELECT_MEMORY_SPACE:
        error = Function_SelectMemorySpace(reg);
        break;

    case DRV_FUNCTION__SELECT_CARD_VOLTAGE:
        error = Function_SelectCardVoltage(reg);
        break;

    case DRV_FUNCTION__SELECT_PROGRAMMING_VOLTAGE:
        error = Function_SelectProgrammingVoltage(reg);
        break;

    case DRV_FUNCTION__SELECT_ACCESS_SPEED:
        error = Function_SelectAccessTiming(reg);
        break;

    case DRV_FUNCTION__IRQ_HANDLER_INSTALL:
        error = Function_IRQHandlerInstall(reg);
        break;

    case DRV_FUNCTION__IRQ_HANDLER_UNINSTALL:
        error = Function_IRQHandlerUnInstall(reg);
        break;

    case DRV_FUNCTION__SAVE_SLOT_STATE:
        error = Function_SaveSlotState(reg);
        break;

    case DRV_FUNCTION__RESTORE_SLOT_STATE:
        error = Function_RestoreSlotState(reg);
        break;

    case DRV_FUNCTION__CARD_INITIALISE:
        error = Function_CardInitialise(reg);
        break;

    case DRV_FUNCTION__CARD_FINALISE:
        error = Function_CardFinalise(reg);
        break;

    case DRV_FUNCTION__CARD_PRESENT:
        error = Function_CardPresent(reg);
        break;

    case DRV_FUNCTION__CARDDETECT_ENTRY:
        error = Function_CardDetectInitialise(reg);
        break;

    case DRV_FUNCTION__CARDDETECT_EXIT:
        error = Function_CardDetectFinalise(reg);
        break;

    default:
        error = ERROR__UNKNOWN_FUNCTION;
        break;
    }

    /*************************************************************************************/
    /***        Check error condition, and set the appropriate error value.            ***/
    /*************************************************************************************/
    if (error == NO_ERROR)
        reg ->r[8] = 0;                                   /* No error, so clear error flag */
    else
        reg ->r[8] = (int) SetError(error);               /* point to error block          */

    return(1);
}





/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 0                                                                       ***/
/***  Function_VersionFeatures(regs)                                                   ***/
/***                                                                                   ***/
/***  Returns the implemented features of this PCMCIA Driver.                          ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       None.                                                                       ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       R0 = Software Version Number (*100)                                         ***/
/***       R1 = Features                                                               ***/
/***                  0      32bit memory Read/Write                    (1)            ***/
/***                  1      Programmable access timings                (1)            ***/
/***                  2      Wait State control                         (1)            ***/
/***                  3      3.3 Volt Support                           (0)            ***/
/***                  4      Vpp1 Selection                             (1)            ***/
/***                  5      I/O Address skewing                        (1)            ***/
/***                  6      Hardware timer                             (1)            ***/
/***                  7 - 15 Reserved                                   (0)            ***/
/***                 16      Vpp2 Selection                             (0)            ***/
/***                 17      Memory Card Functionality                  (1)            ***/
/***                 18      I/O Card Functionality                     (1)            ***/
/***                 19 - 31 Reserved                                   (1)            ***/
/***       R2 = Supported Data Modes                                                   ***/
/***                  1      8-bit read/write                                          ***/
/***                  7      16-bit read/write                                         ***/
/***                  15     32-bit read/write                                         ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if succesfully (always sucessful)                                    ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_VersionFeatures(_kernel_swi_regs *reg)
    {

#if Debug == TRUE
    DebugMessage("yK", "\n\n********       Version/Features (Function 0)  Entry        ********\n");
#endif

    /*********************************************************************************/
    /***    Software Features                                                      ***/
    /*********************************************************************************/
    reg ->r[0] = (int) PCMCIA_DRV_VERSION_NUMBER;
    reg ->r[1] = 0xFFFF0000
        #if PCMCIA_DRV__READ_WRITE32__Implemented == TRUE
            | PCMCIA_DRV__READ_WRITE32__Bits
        #endif

        #if PCMCIA_DRV__ACCESS_TIME__Implemented == TRUE
            | PCMCIA_DRV__ACCESS_TIME__Bits
        #endif

        #if PCMCIA_DRV__WAIT_STATE__Implemented == TRUE
            | PCMCIA_DRV__WAIT_STATE__Bits
        #endif

        #if PCMCIA_DRV__VOLTS33__Implemented == TRUE
            | PCMCIA_DRV__VOLTS33__Bits
        #endif

        #if PCMCIA_DRV__VPP1__Implemented == TRUE
            | PCMCIA_DRV__VPP1__Bits
        #endif

        #if PCMCIA_DRV__SKEW__Implemented == TRUE
            | PCMCIA_DRV__SKEW__Bits
        #endif

        #if PCMCIA_DRV__TIMER__Implemented == TRUE
            | PCMCIA_DRV__TIMER__Bits
        #endif
            ;

        #if PCMCIA_DRV__VPP2__Implemented == FALSE
            reg ->r[1] = reg ->r[1] ^ PCMCIA_DRV__VPP2__Bits;
        #endif

        #if PCMCIA_DRV__MEMORY__Implemented == FALSE
            reg ->r[1] = reg ->r[1] ^ PCMCIA_DRV__MEMORY__Bits;
        #endif

        #if PCMCIA_DRV__IO__Implemented == FALSE
            reg ->r[1] = reg ->r[1] ^ PCMCIA_DRV__IO__Bits;
        #endif

    reg ->r[2] = 0xFFFF0000 | SUPPORTED_DATA_MODES | SUPPORTED_IO_MODES;


#if Debug == TRUE
    DebugMessage("yK","\n    Function 0, Exit:\n");
    DebugMessage("yK","        R0 = &%8X    (PCMCIA Driver version number)\n", reg ->r[0]);
    DebugMessage("yK","        R1 = &%8X    (features)\n", reg->r[1]);
    DebugMessage("yK","        R2 = &%8X    datamodes\n", reg->r[2]);

    #if PCMCIA_DRV__READ_WRITE32__Implemented == TRUE
      DebugMessage("yK","                            32 bit Read/Write capable\n");
    #endif
    #if PCMCIA_DRV__ACCESS_TIME__Implemented == TRUE
      DebugMessage("yK","                            Configurable access timings\n");
    #endif

    #if PCMCIA_DRV__WAIT_STATE__Implemented == TRUE
      DebugMessage("yK","                            Wait State control\n");
    #endif

    #if PCMCIA_DRV__VOLTS33__Implemented == TRUE
      DebugMessage("yK","                            3.3 volt support\n");
    #endif

    #if PCMCIA_DRV__VPP1__Implemented == TRUE
      DebugMessage("yK","                            VPP1 switching control\n");
    #endif

    #if PCMCIA_DRV__SKEW__Implemented == TRUE
      DebugMessage("yK","                            16 bit I/o register skewing\n");
    #endif

    #if PCMCIA_DRV__TIMER__Implemented == TRUE
      DebugMessage("yK","                            Hardware timer built in\n\n");
    #endif

    #if PCMCIA_DRV__VPP2__Implemented == TRUE
      DebugMessage("yK","                            VPP2 switching control\n");
    #endif

    #if PCMCIA_DRV__MEMORY__Implemented == TRUE
      DebugMessage("yK","                            Supports memory functionality\n");
    #endif

    #if PCMCIA_DRV__IO__Implemented == TRUE
      DebugMessage("yK","                            Supports I/O functionality\n");
    #endif
    DebugMessage("yK","\n******************************************************************\n");
#endif

    return((PCMCIADriver_ErrorCode) NO_ERROR);
    }






/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 1                                                                       ***/
/***  Function_HardwareConfiguration(regs)                                             ***/
/***                                                                                   ***/
/***  Returns the hardware configuration for the specified podule address.             ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       None.                                                                       ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       R0 = Number of slots on hardware                                            ***/
/***       R1 = Page size                                                              ***/
/***       R2 = I/O Page Size                                                          ***/
/***       R3 = Longest supported cycle time                                           ***/
/***       R4 = Shortest supported cycle time                                          ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if succesfully completed (always!)                                   ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_HardwareConfiguration(_kernel_swi_regs *reg)
    {
    #if Debug == TRUE
        DebugMessage("yK","\n\n********    Hardware Configuraton (Function 1)  Entry     ********\n");
    #endif

    /*********************************************************************************/
    /***    Get and return the pointer to the Hardware Configuration block         ***/
    /*********************************************************************************/
    reg ->r[0] = 2;
    _kernel_swi (OS_ReadSysInfo, reg, reg);
    if(reg->r[2] != 2) reg->r[0] = 1;                   /** Inverted Stork Special Case! **/
    else reg ->r[0] = MAX_SLOTS_PER_ADAPTOR;

    reg ->r[1] = PAGE_SIZE;
    reg ->r[2] = IO_PAGE_SIZE;
    reg ->r[3] = LONGEST_CYCLE_TIME;
    reg ->r[4] = SHORTEST_CYCLE_TIME;

    #if Debug == TRUE
        DebugMessage("yK","\n**************    Function 1, Exit    ****************\n");
        DebugMessage("yK","        R0 = &%8X\n", reg ->r[0]);
        DebugMessage("yK","        R1 = &%8X\n", reg ->r[1]);
        DebugMessage("yK","        R2 = &%8X\n", reg ->r[2]);
        DebugMessage("yK","        R3 = &%8X\n", reg ->r[3]);
        DebugMessage("yK","        R4 = &%8X\n", reg ->r[4]);
    #endif
    return((PCMCIADriver_ErrorCode) NO_ERROR);
}







/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 2                                                                       ***/
/***  Function_GetCardStatus(regs)                                                     ***/
/***                                                                                   ***/
/***  This function returns the current status of the given PCMCIA card.               ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R7 = Slot Handle                                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       R0 = Card Status.                                                           ***/
/***            bits                                                                   ***/
/***            0 - 1   Card Present                                                   ***/
/***                            0    = Card Present                                    ***/
/***                            1-3  = No card Present                                 ***/
/***            2       Memory/IO Card (as configured)                                 ***/
/***                            0 = Memory card                                        ***/
/***                            1 = I/O card                                           ***/
/***            3       Write Protected (if set)                                       ***/
/***            4 - 5   Battery Condition (Memory Cards Only)                          ***/
/***                            3 = Good (or non battry device)                        ***/
/***                            1 = Low, but usable                                    ***/
/***                            2 = Reserved, no meaning                               ***/
/***                            0 = Very Low, could lose data                          ***/
/***            4       Status Changed (I/O cards only)                                ***/
/***            6       Ready (memory cards only)                                      ***/
/***            6       I/O Interrupt pending  (I/O cards only)                        ***/
/***            7       VS1                                                            ***/
/***            8       VS2                                                            ***/
/***            9 - 31  Reserved (0)                                                   ***/
/***       (The bits 2 - 31 are only valid if bits 0 & 1 are both set. Other bits are  ***/
/***        are valid only for the type of card configured.)                           ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if succesfully (always sucessful)                                    ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_GetCardStatus(_kernel_swi_regs *reg)
    {
    PCMCIADriver_ErrorCode      error = NO_ERROR;
    unsigned int                tempreg = 0;

    #if Debug == TRUE
        DebugMessage("yK", "\n\n********       Get Card Status (Function 2)  Entry        ********\n");
        DebugMessage("yK", "    Function 2, Entry:\n");
        DebugMessage("yK", "        R7 = &%8X    (slot handle)\n", reg ->r[7]);
    #endif

    /*********************************************************************************/
    /***    Get the status of the card.                                            ***/
    /*********************************************************************************/
    tempreg = Read_SlotStatusRegister(reg ->r[7]);
    if(((tempreg >> SLOT__CARDDETECT__SHIFT) & SLOT__CARDDETECT__MASK) == 0) reg ->r[0] = 3;
    else reg ->r[0] = 0; /** Carddetect bits (inverted!) **/
    reg ->r[0] = reg ->r[0] | (((tempreg >> SLOT__WRITEPROT__SHIFT) & 1) << 3); /** Writeprot  bit  **/
    reg ->r[0] = reg ->r[0] | (((tempreg >> SLOT__BATTDETECT__SHIFT) & SLOT__BATTDETECT__MASK) << 4); /** Batt detect bits **/
    reg ->r[0] = reg ->r[0] | (((tempreg >> SLOT__READYBUSY__SHIFT) & 1) << 6); /** Rdy/Bsy or IOIrq bit **/
    reg ->r[0] = reg ->r[0] | (((tempreg >> SLOT__VSELECT__SHIFT) & SLOT__VSELECT__MASK) << 7); /** VS bits **/

    /** Now just need to get the mem/io bit **/
    tempreg = Read_SlotAccessModeRegister(reg ->r[7]);
    reg ->r[0] = reg ->r[0] | (((tempreg >> SLOT__ACCESS_MODE__SHIFT) & 1) << 2);

    #if Debug == TRUE
        DebugMessage("yK", "\n    Function 2, Exit:\n");
        DebugMessage("yK", "Card status is &%08X\n", reg ->r[0]);
        DebugMessage("yK", "\n******************************************************************\n");
    #endif
    return(error);
}






/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 3                                                                       ***/
/***  Function_GetMemMapAddress(regs)                                                  ***/
/***                                                                                   ***/
/***  This function will calculate and return an address within the host's memory      ***/
/***  address map which is the equivelent address on a specified PCMCIA card. Thus     ***/
/***  an application will be able to determine where in the memory mapping a           ***/
/***  particluar address or range of addresses exist. The routine also returns what    ***/
/***  "page" values must be set to obtain the correct address.                         ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R1 = PCMCIA address (ie. within the card)                                   ***/
/***       R2 = Memory or I/O                                                          ***/
/***            0 = Memory Space                                                       ***/
/***            1 = I/O space   (ie. checks page skewing etc)                          ***/
/***       R7 = Slot Handle                                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       R0 = Host memory address                                                    ***/
/***       R1 = PCMCIA page required                                                   ***/
/***       R2 = Skewing page (only for I/O space)                                      ***/
/***            0 = no skew page (ie. data mode 5)                                     ***/
/***            1 = skew page required (ie. data mode 6)                               ***/
/***                                                                                   ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if succesfully (always sucessful)                                    ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_GetMemMapAddress(_kernel_swi_regs *reg)
    {
    PCMCIADriver_ErrorCode      error = NO_ERROR;
#if Debug == TRUE
    int                         IOMode = reg ->r[2];
#endif


    #if Debug == TRUE
        DebugMessage("yK", "\n\n********  Get Memory Mapped Address (Function 3)  Entry   ********\n");
        DebugMessage("yK", "    Function 3, Entry:\n");
        DebugMessage("yK", "        R1 = &%8X    (Address on card)\n", reg ->r[1]);
        if (IOMode == 0)
            DebugMessage("yK", "        (Memory address required)\n");
        else
            DebugMessage("yK", "        (I/O address required)\n");
        DebugMessage("yK", "        R7 = &%8X    (Slot handle)\n", reg ->r[7]);
    #endif

    /*********************************************************************************/
    /***    Obtain the Memory Mapped address                                       ***/
    /*********************************************************************************/

    if (reg ->r[2] == 0) {
        /*** Memory addressing mode requested ***/
        reg ->r[0] = CCB_Block[reg ->r[7]].PCMCIA_Space_Base + (reg ->r[1] % (1 << PAGE_SIZE));
        reg ->r[1] = reg ->r[1] / (1 << PAGE_SIZE);
    }
    else
    {
        /*********************************************************************************/
        /***    I/O addressing mode requested                                          ***/
        /*********************************************************************************/
        reg ->r[2] = (reg ->r[1] >> (IO_PAGE_SIZE-1)) & 1; /* Skew page */
        reg ->r[0] = CCB_Block[reg ->r[7]].PCMCIA_Space_Base + (reg ->r[1] & ~((1<<IO_PAGE_SIZE)-2));
        reg ->r[0] = reg ->r[0] | ((reg ->r[1] << 1) & ((1<<IO_PAGE_SIZE)-3));
        reg ->r[1] = reg ->r[1] / (1 << PAGE_SIZE);
    }

    #if Debug == TRUE
        DebugMessage("yK", "\n    Function 3, Exit:\n");
        DebugMessage("yK", "        R0 = &%8X    (Host address)\n", reg ->r[0]);
        DebugMessage("yK", "        R1 = &%8X    (PCMCIA page setting required)\n", reg ->r[1]);
        if (IOMode == 1) DebugMessage("yK", "        R2 = &%8X    (Skew page)\n", reg ->r[2]);
        DebugMessage("yK", "\n******************************************************************\n");
    #endif
    return(error);
}







/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 4                                                                       ***/
/***  Function_ResetCard(regs)                                                         ***/
/***                                                                                   ***/
/***  This function resets the stated card. It is intended                             ***/
/***  to be used when the card is physically present in a slot. No checking is         ***/
/***  performed to ensure that this is actually the case.                              ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R7 = Slot Handle                                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       None                                                                        ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if succesful                                                         ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_ResetCard(_kernel_swi_regs *reg)
    {

    #if Debug == TRUE
        DebugMessage("yK", "\n\n********  Reset card (Function 4)  Entry   ********\n");
    #endif

    SendCardReset(reg ->r[7]);
    ClearRdyIOIrqs(reg ->r[7]);

    #if Debug == TRUE
        DebugMessage("yK", "\n    Function 4, Exit:\n");
        DebugMessage("yK", "\n******************************************************************\n");
    #endif

    return(NO_ERROR);
}





/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 5                                                                       ***/
/***  Function_SelectPage(regs)                                                        ***/
/***                                                                                   ***/
/***  This function selects the appropiate page.                                       ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R1 = Page value (0-8 on ASIC, 0-3 on prototype)                             ***/
/***       R2 = I/O skew page value                                                    ***/
/***       R7 = Slot Handle                                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       None                                                                        ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if succesfully                                                       ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_SelectPage(_kernel_swi_regs *reg)
    {

#if Debug == TRUE
    DebugMessage("yK", "\n\n********  Select Page (Function 5)  Entry   ********\n");
#endif

    Set_Page(reg ->r[7], reg ->r[1]);
    Set_SkewPage(reg ->r[7], reg ->r[2]);

    #if Debug == TRUE
        DebugMessage("yK", "\n    Function 5, Exit:\n");
        DebugMessage("yK", "\n******************************************************************\n");
    #endif

    return(NO_ERROR);
}






/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 6                                                                       ***/
/***  Function_SelectDataMode(regs)                                                    ***/
/***                                                                                   ***/
/***  This function selects the appropiate data mode for the given slot.               ***/
/***  The currently selected slot will not be effected by this function.               ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R1 = Data Mode                                                              ***/
/***            bits                                                                   ***/
/***             0 -  5         Data Mode                                              ***/
/***                            0 - 8 bit read/write                                   ***/
/***                            1 - 16 bit read/write (lower 16 bits)                  ***/
/***                            2 - 16 bit read/write (upper 16 bits)                  ***/
/***                            3 - 32 bit read/write (using funnel)                   ***/
/***                            4 - I/O without skewing                                ***/
/***                            5 - I/O with 1-bit skewing                             ***/
/***                            6 - I/O with 2-bit skewing                             ***/
/***                                                                                   ***/
/***       R7 = Slot Handle                                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       R0 = Data layout information                                                ***/
/***            bits            meaning                                                ***/
/***              0             Set if datamode was successfully selected              ***/
/***            1-2             Flags                                                  ***/
/***                            1  Set if odd addr 16-bits are read onto upper 16bits  ***/
/***                            2  Set if odd addr 16-bits are writ thru upper 16bits  ***/
/***                            3 - 31  Reserved (0)                                   ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if succesfully                                                       ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_SelectDataMode(_kernel_swi_regs *reg)
    {
    PCMCIADriver_ErrorCode      error = NO_ERROR;


#if Debug == TRUE
    DebugMessage("yK", "\n\n********       Select Data Mode (Function 6)  Entry       ********\n");
    DebugMessage("yK", "    Function 6, Entry:\n");
    DebugMessage("yK", "        R1 = &%8X    (DataMode)\n", reg ->r[1]);
    DebugMessage("yK", "        R7 = &%8X    (Slot handle)\n", reg ->r[7]);
#endif

    /*********************************************************************************/
    /***    Update the CCB with the new Data Mode.                                 ***/
    /*********************************************************************************/
    if(((SUPPORTED_DATA_MODES | SUPPORTED_IO_MODES) & (1 << reg ->r[1])) != 0) {
        Set_DataMode(reg ->r[7], reg ->r[1]);

        /***************** Now set up R0 and R1 for the return values *******************/
        /***************** depending on the data mode chosen ****************************/
        reg ->r[0] = 1 | LAYOUT__UPPER_READ_ON_UPPER_FLAG | LAYOUT__UPPER_WRITE_ON_UPPER_FLAG;
    }
    else reg ->r[0] = 0;

#if Debug == TRUE
    DebugMessage("yK", "\n    Function 6, Exit:\n");
    DebugMessage("yK", "\n******************************************************************\n");
#endif

    return(error);
}







/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 7                                                                       ***/
/***  Function_SelectMemorySpace(regs)                                                 ***/
/***                                                                                   ***/
/***  This function selects the appropriate memory space (ie. common or attribute) for ***/
/***  the given slot.                                                                  ***/
/***  The currently selected slot will not be effected by this function.               ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R1 = Memory Space                                                           ***/
/***            bits                                                                   ***/
/***                  0         Memory Space                                           ***/
/***                            0 - Common Memory                                      ***/
/***                            1 - Attribute Memory                                   ***/
/***       R7 = Slot Handle                                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       None                                                                        ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if succesfully                                                       ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_SelectMemorySpace(_kernel_swi_regs *reg)
    {
    PCMCIADriver_ErrorCode      error = NO_ERROR;


    #if Debug == TRUE
        DebugMessage("yK", "\n\n********     Select Address Space (Function 7)  Entry    ********\n");
        DebugMessage("yK", "    Function 7, Entry:\n");
        DebugMessage("yK", "        R1 = &%8X    (Address Space)\n", reg ->r[1]);
        if (reg ->r[1] == 0)
            DebugMessage("yK", "                              - Common Memory\n");
        else
            DebugMessage("yK", "                              - Attribute Memory\n");
        DebugMessage("yK", "        R7 = &%8X    (slot address)\n", reg ->r[7]);
    #endif

    /*********************************************************************************/
    /***    Update the hardware with the new memory space.                         ***/
    /*********************************************************************************/
    Set_AddressSpace(reg ->r[7], reg ->r[1] & 0x01);

    #if Debug == TRUE
        DebugMessage("yK", "\n    Function 7, Exit:\n");
        DebugMessage("yK", "\n******************************************************************\n");
    #endif

    return(error);
}







/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 8                                                                       ***/
/***  Function_SelectCardVoltage(regs)                                                 ***/
/***                                                                                   ***/
/***  This function selects whether the card is given a 3.3v or 5.0v Vcc. If 3.3v is   ***/
/***  not supported by the hardware, an error is generated. Whichever is selected,     ***/
/***  the access speed for the slot is set to the value in the CCB.                    ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R1 = Voltage Selector (0=5v, 1=3.3v)                                        ***/
/***       R7 = Slot Handle                                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       All registers preserved                                                     ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if successful                                                        ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_SelectCardVoltage(_kernel_swi_regs *reg)
    {
    PCMCIADriver_ErrorCode      error = NO_ERROR;
    int                         slot;

    #if Debug == TRUE
        DebugMessage("yK", "\n\n********  Select voltage (Function 8)  Entry   ********\n");
    #endif

    /******************************/
    /* Check whether 3.3v allowed */
    /******************************/
    if((PCMCIA_DRV__VOLTS33__Implemented == FALSE) && (reg ->r[1] == 1)) return(ERROR__UNSUPPORTED_SLOT);

    /***************************************/
    /* Set the h/w access time accordingly */
    /***************************************/
    slot = Read_SlotPageRegister(reg ->r[7]);
    if(slot & (1<<SLOT__MEM_SPACE__SHIFT)) { /** Are attrib */
        if(reg ->r[1] == 0) Set_AccessTime(reg ->r[7], CCB_Block[reg ->r[7]].AttribAccessTime);
        else Set_AccessTime(reg ->r[7], CCB_Block[reg ->r[7]].Attrib3vAccessTime);
    }
    else
    {
        if(reg ->r[1] == 0) Set_AccessTime(reg ->r[7], CCB_Block[reg ->r[7]].CommonAccessTime);
        else Set_AccessTime(reg ->r[7], CCB_Block[reg ->r[7]].Common3vAccessTime);
    }

    /************************************************/
    /* Finally, flick the voltage on the Berlin h/w */
    /************************************************/
    Set_Voltage(reg ->r[7], reg ->r[1]);

    #if Debug == TRUE
        DebugMessage("yK", "\n\n********  Select voltage (Function 8)  Exit   ********\n");
    #endif

    return(error);
}









/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 9                                                                       ***/
/***  Function_SelectProgrammingVoltage(regs)                                          ***/
/***                                                                                   ***/
/***  This function selects the programming voltage for FLASH devices etc. Selecting   ***/
/***  a programming voltage that is not supported by the hardware results in an error. ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R1 = Programming Voltage Select (see spec for fields)                       ***/
/***       R7 = Slot Handle                                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       All registers preserved                                                     ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if successful                                                        ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_SelectProgrammingVoltage(_kernel_swi_regs *reg)
    {
    PCMCIADriver_ErrorCode      error = NO_ERROR;

    #if Debug == TRUE
        DebugMessage("yK", "\n\n********  Select prog voltage (Function 9)  Entry   ********\n");
    #endif

    /********************************************/
    /* Check whether we want an allowed voltage */
    /********************************************/
    if(((1 << (reg ->r[1] & 0x0f)) & VPP1__Allowed) == 0) return(ERROR__UNSUPPORTED_SLOT);
    if(((1 << ((reg ->r[1] & 0xf0) >> 8)) & VPP2__Allowed) == 0) return(ERROR__UNSUPPORTED_SLOT);

    /***************************/
    /* Set the h/w accordingly */
    /***************************/
    Set_ProgramVoltage(reg ->r[7], (reg ->r[1] & 0x0f), 1);
    Set_ProgramVoltage(reg ->r[7], ((reg ->r[1] & 0xf0) >> 8), 2);

    #if Debug == TRUE
        DebugMessage("yK", "\n\n********  Select Prog voltage (Function 10)  Exit   ********\n");
    #endif

    return(error);
}







/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 10                                                                      ***/
/***  Function_SelectAccessTiming(regs)                                                ***/
/***                                                                                   ***/
/***  This function selects the appropriate memory speed for the given slot.           ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R1 = 5v Access time (ns)                                                    ***/
/***       R2 = 3.3v access time                                                       ***/
/***       R3 = setup time                                                             ***/
/***       R4 = hold time                                                              ***/
/***       R7 = Slot Handle                                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       R1-R4 reflect prevoius settings                                             ***/
/***       All registers preserved                                                     ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if succesfully                                                       ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_SelectAccessTiming(_kernel_swi_regs *reg)
    {
    PCMCIADriver_ErrorCode      error = NO_ERROR;
    int                         slot;
    int                         vslot;

    #if Debug == TRUE
        DebugMessage("yK", "\n\n********     Select Access Timings (Function 10)  Entry    ********\n");
        DebugMessage("yK", "    Function 10, Entry:\n");
        DebugMessage("yK", "        R1 = &%8X    (Access Time in ns)\n", reg ->r[1]);
        DebugMessage("yK", "        R2 = &%8X", reg ->r[2]);
        DebugMessage("yK", "        R7 = &%8X    (Slot handle)\n", reg ->r[7]);
    #endif

    /*****************************************************************************/
    /***        Now set the hardware as well                                   ***/
    /*****************************************************************************/
    slot = Read_SlotPageRegister(reg ->r[7]);
    vslot = Read_VoltControlRegister(reg ->r[7]);
    if(slot & (1<<SLOT__MEM_SPACE__SHIFT)) { /** Are attrib */
        vslot = CCB_Block[reg ->r[7]].Attrib3vAccessTime;
        if(reg ->r[2] != 0) CCB_Block[reg ->r[7]].Attrib3vAccessTime = reg ->r[2];
        reg ->r[2] = vslot;

        vslot = CCB_Block[reg ->r[7]].AttribAccessTime;
        if(reg ->r[1] != 0) CCB_Block[reg ->r[7]].AttribAccessTime = reg ->r[1];
        reg ->r[1] = vslot;

        if(vslot & (1<<SLOT__VCC_3V_OR_5V__SHIFT)) Set_AccessTime(reg ->r[7], CCB_Block[reg ->r[7]].Attrib3vAccessTime);
        else Set_AccessTime(reg ->r[7], CCB_Block[reg ->r[7]].AttribAccessTime);
    }
    else
    {
        vslot = CCB_Block[reg ->r[7]].Common3vAccessTime;
        if(reg ->r[2] != 0) CCB_Block[reg ->r[7]].Common3vAccessTime = reg ->r[2];
        reg ->r[2] = vslot;

        vslot = CCB_Block[reg ->r[7]].CommonAccessTime;
        if(reg ->r[1] != 0) CCB_Block[reg ->r[7]].CommonAccessTime = reg ->r[1];
        reg ->r[1] = vslot;

        if(vslot & (1<<SLOT__VCC_3V_OR_5V__SHIFT)) Set_AccessTime(reg ->r[7], CCB_Block[reg ->r[7]].Common3vAccessTime);
        else Set_AccessTime(reg ->r[7], CCB_Block[reg ->r[7]].CommonAccessTime);
    }

#if Debug == TRUE
    DebugMessage("yK", "\n    Function 10, Exit:\n");
    DebugMessage("yK", "\n******************************************************************\n");
#endif

    return(error);
}





/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 11                                                                      ***/
/***  Function_IRQHandlerInstall(regs)                                                 ***/
/***                                                                                   ***/
/***  Installs an interrupt handler/controller for the given CCB (ie slot)             ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R1 = IRQ Mask bits                                                          ***/
/***             0 - Battery Low                                                       ***/
/***             1 - Battery Very Low                                                  ***/
/***             2 - Busy status changed                                               ***/
/***            16 - I/O interrupt                                                     ***/
/***         17-30 - Reserved                                                          ***/
/***            31 - Prevent enabling of card detect IRQ                               ***/
/***       R2 = Memory IRQ handler address (0 = don't change existing handler address) ***/
/***       R3 = R12 value to use when calling Memory handler                           ***/
/***       R4 = I/O IRQ handler address (0 = don't change existing handler address)    ***/
/***       R5 = R12 value to use when calling I/O handler                              ***/
/***       R6 = R2 value to use when calling irq handlers                              ***/
/***       R7 = Slot Handle                                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       All registers preserved                                                     ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if succesfull                                                        ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_IRQHandlerInstall(_kernel_swi_regs *reg)
    {
    PCMCIADriver_ErrorCode      error = NO_ERROR;
    int                         IRQMask_Mask = 0;
    int                         NumSlots = 0;

#if Debug == TRUE
    DebugMessage("yK", "\n\n********     IRQ Handler Install (Function 11)  Entry    ********\n");
    DebugMessage("yK", "    Function 11, Entry:\n");
    DebugMessage("yK", "        R1 = &%8X    (IRQ Mask)\n", reg ->r[1]);
    DebugMessage("yK", "        R2 = &%8X    (Memory Handler address)\n", reg ->r[2]);
    DebugMessage("yK", "        R3 = &%8X    (Memory Handler R12)\n", reg ->r[3]);
    DebugMessage("yK", "        R4 = &%8X    (I/O Handler address)\n", reg ->r[4]);
    DebugMessage("yK", "        R5 = &%8X    (I/O Handler R12)\n", reg ->r[5]);
    DebugMessage("yK", "        R6 = &%8X    (R2 value to pass)\n", reg ->r[6]);
    DebugMessage("yK", "        R7 = &%8X    (CCB address)\n", reg ->r[7]);
#endif

    if(reg ->r[7] == -1) {  /* ie -1, special case */
        for(NumSlots = 0; NumSlots < NumberOfSlots; NumSlots++) {
            CCB_Block[NumSlots].IRQ_Call_R2 = reg ->r[6];
            CCB_Block[NumSlots].CardIRQ_Call_Address = reg ->r[2];
            CCB_Block[NumSlots].CardIRQ_Call_R12 = reg ->r[3];
            #if Debug == TRUE
                DebugMessage("yK","Doing slot %d\n",NumSlots);
            #endif
            Set_IRQMaskRegister(NumSlots,0); /** This may trip an irq or two... **/
        }
    }
    else
    {
        if(reg ->r[2] != 0) {
            #if Debug == TRUE
                DebugMessage("yK","R2 was non-zero on entry, so change the mem irqs\n");
            #endif
            if( ((CCB_Block[reg ->r[7]].MemoryIRQ_Call_Address == reg ->r[2]) && (CCB_Block[reg ->r[7]].MemoryIRQ_Call_R12 == reg ->r[3]))
                || (CCB_Block[reg ->r[7]].MemoryIRQ_Call_Address == 0)) {
                    IRQMask_Mask = reg ->r[1] & 0xffff;
                    CCB_Block[reg ->r[7]].IRQ_Call_R2 = reg ->r[6];
                    CCB_Block[reg ->r[7]].MemoryIRQ_Call_Address = reg ->r[2];
                    CCB_Block[reg ->r[7]].MemoryIRQ_Call_R12 = reg ->r[3];
            }
        }

        if(reg ->r[4] != 0) {
            #if Debug == TRUE
                DebugMessage("yK","R4 was non-zero on entry, so change the io irqs\n");
            #endif
            if( ((CCB_Block[reg ->r[7]].IOIRQ_Call_Address == reg ->r[4]) && (CCB_Block[reg ->r[7]].IOIRQ_Call_R12 == reg ->r[5]))
                || (CCB_Block[reg ->r[7]].IOIRQ_Call_Address == 0)) {
                    IRQMask_Mask = IRQMask_Mask | (reg ->r[1] & 0x7fff0000);
                    CCB_Block[reg ->r[7]].IRQ_Call_R2 = reg ->r[6];
                    CCB_Block[reg ->r[7]].IOIRQ_Call_Address = reg ->r[4];
                    CCB_Block[reg ->r[7]].IOIRQ_Call_R12 = reg ->r[5];
            }
        }

        CCB_Block[reg ->r[7]].IRQ_Mask = IRQMask_Mask; /* Updates the CCB IRQMask */
        if((reg ->r[1] & 0x80000000) != 0) Set_IRQMaskRegister(reg ->r[7],1); /** This may trip an irq or two... **/
        else Set_IRQMaskRegister(reg ->r[7],0);
    }

#if Debug == TRUE
    DebugMessage("yK", "\nOn exit, the CCB Irq mask is &%8X\n",IRQMask_Mask);
    DebugMessage("yK", "\n    Function 11, Exit:\n");
    DebugMessage("yK", "\n******************************************************************\n");
#endif

    return(error);
}




/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 12                                                                      ***/
/***  Function_IRQHandlerUnInstall(regs)                                               ***/
/***                                                                                   ***/
/***  Uninstalls claimed irq handler routines (opposite to function 11)                ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R1 = IRQ mask bit                                                           ***/
/***            0-30 - Reserved (must be 0)                                            ***/
/***              31 - Prevent enabling of card detect IRQ                             ***/
/***       R2 = same as when installed (if memory handler)                             ***/
/***       R3 = same as when installed (if memory handler)                             ***/
/***       R4 = same as when installed (if io handler)                                 ***/
/***       R5 = same as when installed (if io handler)                                 ***/
/***       R7 = Slot handle                                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       All registers preserved                                                     ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if successful                                                        ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_IRQHandlerUnInstall(_kernel_swi_regs *reg)
    {
    PCMCIADriver_ErrorCode      error = NO_ERROR;
    int                         IRQMask_Mask = 0x00000000;
    int                         NumSlots = 0;

#if Debug == TRUE
    DebugMessage("yK", "\n\n********     IRQ Handler UnInstall (Function 12)  Entry    ********\n");
    DebugMessage("yK", "    Function 12, Entry:\n");
    DebugMessage("yK", "        R1 = &%8X    (IRQ Mask)\n", reg ->r[1]);
    DebugMessage("yK", "        R2 = &%8X    (Memory Handler address)\n", reg ->r[2]);
    DebugMessage("yK", "        R3 = &%8X    (Memory Handler R12)\n", reg ->r[3]);
    DebugMessage("yK", "        R4 = &%8X    (I/O Handler address)\n", reg ->r[4]);
    DebugMessage("yK", "        R5 = &%8X    (I/O Handler R12)\n", reg ->r[5]);
    DebugMessage("yK", "        R7 = &%8X    (Slot handle)\n", reg ->r[7]);
#endif

    if(reg ->r[7] == 0xffffffff) {  /* ie -1, special case */
        for(NumSlots = 0; NumSlots < NumberOfSlots; NumSlots++) {
            CCB_Block[NumSlots].CardIRQ_Call_Address = 0;
            CCB_Block[NumSlots].CardIRQ_Call_R12 = 0;
            Set_IRQMaskRegister(reg ->r[7],0);
        }
    }
    else
    {
        IRQMask_Mask = CCB_Block[reg ->r[7]].IRQ_Mask;
        if(reg ->r[2] != 0) {
            if( (CCB_Block[reg ->r[7]].MemoryIRQ_Call_Address == reg ->r[2]) && (CCB_Block[reg ->r[7]].MemoryIRQ_Call_R12 == reg ->r[3])) {
                    IRQMask_Mask = IRQMask_Mask & 0xffff0000; /* Wipe all mem irqs */
                    CCB_Block[reg ->r[7]].MemoryIRQ_Call_Address = 0;
                    CCB_Block[reg ->r[7]].MemoryIRQ_Call_R12 = 0;;
            }
        }

        if(reg ->r[4] != 0) {
            if( (CCB_Block[reg ->r[7]].IOIRQ_Call_Address == reg ->r[4]) && (CCB_Block[reg ->r[7]].IOIRQ_Call_R12 == reg ->r[5])) {
                    IRQMask_Mask = IRQMask_Mask & 0xffff; /* wipe all io irqs */
                    CCB_Block[reg ->r[7]].IOIRQ_Call_Address = 0;
                    CCB_Block[reg ->r[7]].IOIRQ_Call_R12 = 0;
            }
        }

        CCB_Block[reg ->r[7]].IRQ_Mask = IRQMask_Mask; /* Updates the CCB IRQMask */
        if((reg ->r[1] & 0x80000000) != 0) Set_IRQMaskRegister(reg ->r[7],1); /** This may trip an irq or two... **/
        else Set_IRQMaskRegister(reg ->r[7],0);

    }

#if Debug == TRUE
    DebugMessage("yK", "\nOn exit, the CCB Irq mask is &%8X\n",IRQMask_Mask);
    DebugMessage("yK", "\n    Function 11, Exit:\n");
    DebugMessage("yK", "\n******************************************************************\n");
#endif

    return(error);
}





/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 13                                                                      ***/
/***  Function_SaveSlotState(regs)                                                     ***/
/***                                                                                   ***/
/***  Saves the state of the stated slot on a slot-specific stack.                     ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R7 = Slot handle                                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       All registers preserved                                                     ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if successful                                                        ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_SaveSlotState(_kernel_swi_regs *reg)
    {

    #if Debug == TRUE
        DebugMessage("yK", "Entered function 13 routine in the I/f driver module.\n");
    #endif

    if(StackLevel >= STATESTACK_ENTRIES) return(ERROR__STACK_FULL);

    /** Ok, so let's stack the data then.... **/
    State_Stack[StackLevel].IRQMask_Reg     = *(CCB_Block[reg->r[7]].Adaptor_Register_Base+ADAPTOR__IRQ_MASK_REG__OFFSET);
    State_Stack[StackLevel].IRQMask_CCB     = CCB_Block[reg->r[7]].IRQ_Mask;
    State_Stack[StackLevel].AccessTime_Reg  = *(CCB_Block[reg->r[7]].Slot_Register_Base+SLOT__ACCESS_TIME_REG__OFFSET);
    State_Stack[StackLevel].CommAccess_CCB  = CCB_Block[reg->r[7]].CommonAccessTime;
    State_Stack[StackLevel].AttrAccess_CCB  = CCB_Block[reg->r[7]].AttribAccessTime;
    State_Stack[StackLevel].AccessMode_Reg  = *(CCB_Block[reg->r[7]].Slot_Register_Base+SLOT__ACCESS_MODE_REG__OFFSET);
    State_Stack[StackLevel].VoltageCtrl_Reg = *(CCB_Block[reg->r[7]].Slot_Register_Base+SLOT__VOLTAGE_CONTROL_REG__OFFSET);
    State_Stack[StackLevel].SlotPage_Reg    = *(CCB_Block[reg->r[7]].Slot_Register_Base+SLOT__PAGE_REG__OFFSET);

    StackLevel++;

    return(NO_ERROR);   /* Impossible to generate an error in this routine */
}





/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 14                                                                      ***/
/***  Function_RestoreSlotState(regs)                                                  ***/
/***                                                                                   ***/
/***  Restores the state of the stated slot from a slot-specific stack.                ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R7 = Slot handle                                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       All registers preserved                                                     ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if successful                                                        ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_RestoreSlotState(_kernel_swi_regs *reg)
    {

    #if Debug == TRUE
        DebugMessage("yK", "Entered function 14 routine in the I/f driver module.\n");
    #endif

    if(StackLevel <= 0) return(ERROR__STACK_EMPTY);

    /** Rightio, let's unstack the data then... **/
    *(CCB_Block[reg->r[7]].Adaptor_Register_Base+ADAPTOR__IRQ_MASK_REG__OFFSET)  = State_Stack[StackLevel].IRQMask_Reg;
    CCB_Block[reg->r[7]].IRQ_Mask                                                = State_Stack[StackLevel].IRQMask_CCB;
    *(CCB_Block[reg->r[7]].Slot_Register_Base+SLOT__ACCESS_TIME_REG__OFFSET)     = State_Stack[StackLevel].AccessTime_Reg;
    CCB_Block[reg->r[7]].CommonAccessTime                                        = State_Stack[StackLevel].CommAccess_CCB;
    CCB_Block[reg->r[7]].AttribAccessTime                                        = State_Stack[StackLevel].AttrAccess_CCB;
    *(CCB_Block[reg->r[7]].Slot_Register_Base+SLOT__ACCESS_MODE_REG__OFFSET)     = State_Stack[StackLevel].AccessMode_Reg;
    *(CCB_Block[reg->r[7]].Slot_Register_Base+SLOT__VOLTAGE_CONTROL_REG__OFFSET) = State_Stack[StackLevel].VoltageCtrl_Reg;
    *(CCB_Block[reg->r[7]].Slot_Register_Base+SLOT__PAGE_REG__OFFSET)            = State_Stack[StackLevel].SlotPage_Reg;

    StackLevel--;

    return(NO_ERROR);   /* Impossible to generate an error in this routine */
}






/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 15                                                                      ***/
/***  Function_CardInitialise(regs)                                                    ***/
/***                                                                                   ***/
/***  Initialises the card on insert, by hardware resetting the slot it is in.         ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R7 = Slot handle                                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       All registers preserved                                                     ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if succesfull                                                        ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_CardInitialise(_kernel_swi_regs *reg)
    {
    clock_t             StartTime;
    clock_t             EndTime;

#if Debug == TRUE
    DebugMessage("yK", "Entered CardInitialise routine in the I/f driver module.\n");
    DebugMessage("yK", "Clocks per sec = %d\n", (int)CLOCKS_PER_SEC);
#endif

    /* Would check the VC pins here, but we don't seem to need to */

/*    *(CCB_Block[reg ->r[7]].Slot_Register_Base + SLOT__VOLTAGE_CONTROL_REG__OFFSET)
        = PCMCIA__SUPPLY_VOLTAGE__ON << SLOT__VCC_SWITCH__SHIFT;   Power the slot to 5v Vcc */

    Set_Power(reg ->r[7], SLOT__POWER_ON__MASK);   /** And, as if by magic, the PCMCIA card stirred into life. **/

    /************************/
    /* Now wait 6ms minimum */
    /************************/
    StartTime = clock();
    EndTime = StartTime + 2;

    #if Debug == TRUE
        DebugMessage("yK", "Waiting...\n");
        DebugMessage("yK", "StartTime &%08X\n",(int)StartTime);
        DebugMessage("yK", "EndTime &%08X\n",(int)EndTime);
    #endif
    while(clock() < EndTime);
    #if Debug == TRUE
        DebugMessage("yK", "Negate reset\n");
    #endif
    /*************************/
    /* Assert the card reset */
    /*************************/
    *(CCB_Block[reg ->r[7]].Slot_Register_Base + SLOT__PAGE_REG__OFFSET)
         = *(CCB_Block[reg ->r[7]].Slot_Register_Base + SLOT__PAGE_REG__OFFSET) | (PCMCIA__RESET << SLOT__CARD_RESET__SHIFT);  /*Card Reset */

    /*************************/
    /* Now wait 20ms minimum */
    /*************************/
    StartTime = clock();
    EndTime = StartTime+3;

    #if Debug == TRUE
        DebugMessage("yK", "Waiting...\n");
        DebugMessage("yK", "StartTime &%08X\n",(int)StartTime);
        DebugMessage("yK", "EndTime &%08X\n",(int)EndTime);
    #endif
    while(clock() < EndTime);

    /**************************************************/
    /* All done - card was enabled on interrupt entry */
    /**************************************************/
    #if Debug == TRUE
        DebugMessage("yK", "Waiting finished.. returning now.");
    #endif

    return(NO_ERROR);   /* Impossible to generate an error in this routine */
}






/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 16                                                                      ***/
/***  Function_CardFinalise(regs)                                                      ***/
/***                                                                                   ***/
/***  Finalises the card on removal, by hardware resetting the slot to default values. ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R7 = Slot handle                                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       All registers preserved                                                     ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR, if successful                                                        ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_CardFinalise(_kernel_swi_regs *reg)
    {

    #if Debug == TRUE
        DebugMessage("yK", "Entered CardFinalise routine in the I/f driver module.\n");
    #endif

    /** Power down the slot & change to default settings... also reset ccb **/
    Set_Power(reg ->r[7], 0); /** +Click+, and out went the lights! **/

    CCB_Block[reg ->r[7]].IRQ_Mask               = DEFAULT__IRQ_MASK;
    CCB_Block[reg ->r[7]].IRQ_Call_R2            = DEFAULT__IRQ_R2;
    /** CardIRQ information left unchanged **/
    CCB_Block[reg ->r[7]].MemoryIRQ_Call_Address = DEFAULT__IRQ_CALL;
    CCB_Block[reg ->r[7]].MemoryIRQ_Call_R12     = DEFAULT__IRQ_R12;
    CCB_Block[reg ->r[7]].IOIRQ_Call_Address     = DEFAULT__IRQ_CALL;
    CCB_Block[reg ->r[7]].IOIRQ_Call_R12         = DEFAULT__IRQ_R12;
    CCB_Block[reg ->r[7]].CommonAccessTime       = DEFAULT__COMMON_ACCESS_TIME;
    CCB_Block[reg ->r[7]].AttribAccessTime       = DEFAULT__ATTRIB_ACCESS_TIME;
    CCB_Block[reg ->r[7]].Common3vAccessTime     = DEFAULT__COMMON_3V_ACCESS_TIME;
    CCB_Block[reg ->r[7]].Attrib3vAccessTime     = DEFAULT__ATTRIB_3V_ACCESS_TIME;

    /** Now change the regs to attrib, 8/16-bit mode, mem, default access time, page 0 **/
    Set_DataMode(reg ->r[7], 0);
    Set_Page(reg ->r[7], 0);
    Set_AddressSpace(reg ->r[7], 1);
    Set_AccessTime(reg ->r[7], DEFAULT__ATTRIB_ACCESS_TIME);
    return(NO_ERROR);   /* Impossible to generate an error in this routine */
}






/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 17                                                                      ***/
/***  Function_CardPresent(regs)                                                       ***/
/***                                                                                   ***/
/***  Determines whether a card is present in the stated slot. Needed for initial      ***/
/***  bootup, before any cards have been given CCBs, because you don't know whether    ***/
/***  (or where) any cards are.                                                        ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R1 = Physical slot number (slot handle in this case...)                     ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       R0 = 0 if slot empty                                                        ***/
/***       R1 = slot handle of slot if R0 != 0                                         ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR                                                                       ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_CardPresent(_kernel_swi_regs *reg)
    {
    reg ->r[0] = (Read_SlotStatusRegister((SLOT_HANDLE) reg ->r[1]) & (SLOT__CARDDETECT__MASK << SLOT__CARDDETECT__SHIFT));
    #if Debug == TRUE
        DebugMessage("yK","Seeing if there is a card present in slothandle %d -we get &%08X from the reg\n",reg ->r[1], reg ->r[0]);
    #endif
    if(reg ->r[0] != 0) reg ->r[0] = 0; else reg ->r[0] = 1;

    return(NO_ERROR);
}





/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 18                                                                      ***/
/***  Function_CardDetectInitialise(regs)                                              ***/
/***                                                                                   ***/
/***  This function simply removes the card detect interrupt from the interface        ***/
/***  hardware. This is necessary due to the fact that the card detect interrupt       ***/
/***  triggers a callback routine to do all the hard work...                           ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R7 = Slot Handle                                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       nothing                                                                     ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR                                                                       ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_CardDetectInitialise(_kernel_swi_regs *reg)
    {
    int                         StartTime;
    int                         EndTime;

    #if Debug == TRUE
        DebugMessage("yK","In carddetectentry\n");
    #endif

    /** Right, wait the debounce period & then decide whether **/
    /**  it was an insertion or a removal.                    **/
    StartTime = clock();
    EndTime = StartTime + IRQ__DEBOUNCE_TIME + 1;
    #if Debug == TRUE
        DebugMessage("mK", "Waiting for the debounce period...\n");
    #endif
    while(clock() < EndTime);

    /*** Now, clear the edge detect registers for IO & rdybsy ***/
    ClearRdyIOIrqs(reg ->r[7]);

    #if Debug == TRUE
        DebugMessage("yK","Leaving carddetectentry\n");
    #endif
    return(NO_ERROR);
}




/*****************************************************************************************/
/***                                                                                   ***/
/***  Function 19                                                                      ***/
/***  Function_CardDetectFinalise(regs)                                                ***/
/***                                                                                   ***/
/***  This function simply removes the card detect interrupt from the interface        ***/
/***  hardware. This is necessary due to the fact that the card detect interrupt       ***/
/***  triggers a callback routine to do all the hard work...                           ***/
/***                                                                                   ***/
/***    On Entry:                                                                      ***/
/***       R7 = Slot Handle                                                            ***/
/***                                                                                   ***/
/***    On Exit:                                                                       ***/
/***       nothing                                                                     ***/
/***                                                                                   ***/
/***  Return Value:                                                                    ***/
/***    NO_ERROR                                                                       ***/
/***                                                                                   ***/
/*****************************************************************************************/
PCMCIADriver_ErrorCode Function_CardDetectFinalise(_kernel_swi_regs *reg)
    {
    int                 loop;

    _kernel_irqs_off();   /** They should be switched back on by the exit veneer.... **/

    #if Debug == TRUE
        DebugMessage("yK","In carddetectexit\n");
    #endif
    /** Clear the irq latch by setting the right edge-detect bit. In fact, best clear any other irq's from this slot **/
    *(CCB_Block[reg ->r[7]].Adaptor_Register_Base + ADAPTOR__EDGEDETECT_CLEAR_REG__OFFSET) = 1 << (EDGE__CD_SLOT0__SHIFT - (reg ->r[7] % 2));
    /** Reenable the masks throughout the drivers judiciary **/
    for(loop=0;loop < NumberOfSlots; loop++) Set_IRQMaskRegister(loop,0); /** This may trip an irq or two... **/
    /** And that's it! **/

    #if Debug == TRUE
        DebugMessage("yK","Leaving carddetectexit\n");
    #endif
    return(NO_ERROR);
}
