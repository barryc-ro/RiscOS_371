; > Sources.DMA

;-----------------------------------------------------------------------------
; DMAGetRequestBlock
;       Out:    r10 ->free DMA request block
;
;       Return a free DMA request block.
;
DMAGetRequestBlock
        ENTRY   "r1-r3"

        Debug   dma,"DMAGetRequestBlock"

        IRQOff  r3                              ; Stop IRQs messing with free chain.

        LDR     r10, FreeBlock                  ; Get free block pointer.
        TEQ     r10, #0
        BLEQ    DMANewBuffer                    ; Need new buffer if no free space.
        ORRVS   r3, r3, #V_bit
        BVS     %FT10

        ASSERT  free_Next = 0
        ASSERT  free_Size = free_Next + 4
        LDMIA   r10, {r1,r2}                    ; r10->free block so get next and size.

        TEQ     r2, #DMARSize                   ; If only one request block then
        STREQ   r1, FreeBlock                   ;   point FreeBlock to next in list
        BEQ     %FT10                           ;   and return.

        SUB     r2, r2, #DMARSize               ; Otherwise, adjust size
        ADD     lr, r10, #DMARSize              ;   and set up remainder of free block.
        STMIA   lr, {r1,r2}
        STR     lr, FreeBlock                   ; Point FreeBlock to remainder.
10
        SetPSR  r3                              ; The world is consistent again so reenable IRQs.
        DebugIf VC,dma," block at ",r10
        EXIT

;-----------------------------------------------------------------------------
; DMAFreeRequestBlock
;       In:     r10 ->DMA request block to free
;
;       Link a DMA request block onto the head of the free list.
;
DMAFreeRequestBlock
        ENTRY   "r0,r1"

        Debug   dma,"DMAFreeRequestBlock",r10

        IRQOff  lr                              ; Stop IRQs messing with queue.

        LDR     r0, FreeBlock
        MOV     r1, #DMARSize
        STMIA   r10, {r0,r1}
        STR     r10, FreeBlock

        EXITS

;-----------------------------------------------------------------------------
; DMANewBuffer
;       Out:    r10 ->free block
;
;       Link a new buffer into the DMA request block list.
;
DMANewBuffer
        ENTRY   "r0,r2,r3"

        MOV     r0, #ModHandReason_Claim        ; Claim new buffer block.
        MOV     r3, #BlockSize
        SWI     XOS_Module
        EXIT    VS

        LDR     r0, DMABlockHead                ; Link into DMA block buffer list.
        STR     r0, [r2, #block_Next]
        STR     r2, DMABlockHead

        ASSERT  free_Next = 0
        ASSERT  free_Size = free_Next + 4
        ADD     r10, r2, #block_Data            ; r10->free space
        MOV     r0, #0
        MOV     r3, #BlockSize - block_Data     ; Size of free space.
        STMIA   r10, {r0,r3}                    ; Set up free block.

        EXIT

;-----------------------------------------------------------------------------
; DMALinkRequest
;       In:     r9  ->DMA queue
;               r10 ->DMA request block
;
;       Link the DMA request block onto the tail of the queue.
;
DMALinkRequest
        ENTRY

        Debug   dma,"DMALinkRequest",r10

        IRQOff  lr                              ; Stop IRQs changing queue.

        LDR     lr, [r9, #dmaq_Tail]            ; Link onto tail.
        TEQ     lr, #0
        STREQ   r10, [r9, #dmaq_Head]           ; If queue was empty then set up as head
        STRNE   r10, [lr, #dmar_Next]           ;   else link onto tail.
        STR     r10, [r9, #dmaq_Tail]           ; Point tail to new entry.
        STR     lr, [r10, #dmar_Prev]           ; Link back.
        MOVNE   lr, #0
        STR     lr, [r10, #dmar_Next]           ; Mark as end of queue.

        EXITS                                   ; Exit restoring IRQs.

;-----------------------------------------------------------------------------
; DMAUnlinkRequest
;       In:     r9  ->DMA queue
;               r10 ->DMA request block
;
;       Unlink a DMA request block from a queue.
;
DMAUnlinkRequest
        ENTRY   "r0"

        Debug   dma,"DMAUnlinkRequest",r10

        IRQOff  lr                              ; Stop IRQs changing queue.

        LDR     r0, [r10, #dmar_Prev]
        LDR     lr, [r10, #dmar_Next]
        TEQ     r0, #0
        STREQ   lr, [r9, #dmaq_Head]            ; If head of queue then set up next as new head
        STRNE   lr, [r0, #dmar_Next]            ;   else link previous to next.
        TEQ     lr, #0
        STREQ   r0, [r9, #dmaq_Tail]            ; If tail of queue then set up previous as new tail
        STRNE   r0, [lr, #dmar_Prev]            ;   else link next back to previous.

        EXITS                                   ; Exit restoring IRQs.

;---------------------------------------------------------------------------
; DMAFindTag
;
;       In:     r1 = DMA request tag
;
;       Out:    VC =>   r9->DMA queue
;                       r10->DMA request block
;               VS =>   r0->error
;                       r9,r10 corrupted
;
;       Search the appropriate queue for the DMA request with the given tag.
;
DMAFindTag
        ENTRY   "r2"

        Debug   dma,"DMAFindTag",r1

        AND     r10, r1, #dmar_PhysBits
        CMP     r10, #NoPhysicalChannels
        PullEnv CS
        ADRCS   r0, ErrorBlock_DMA_BadTag
        DoError CS

        PhysToDMAQ r9, r10                      ; r9->DMA queue

        IRQOff  r2                              ; Stop IRQs messing with queue.

        LDR     r10, [r9, #dmaq_Head]           ; Search the queue.
10
        TEQ     r10, #0                         ; If reached the end then
        BEQ     %FT20                           ;   return error.

        LDR     lr, [r10, #dmar_Tag]
        TEQ     lr, r1                          ; If tags don't match then
        LDRNE   r10, [r10, #dmar_Next]          ;   try next.
        BNE     %BT10

        SetPSR  r2

        Debug   dma," =",r10

        EXIT
20
        SetPSR  r2
        Debug   dma," tag not found"
        PullEnv
        ADR     r0, ErrorBlock_DMA_BadTag
        DoError

        MakeErrorBlock  DMA_BadTag

;-----------------------------------------------------------------------------
; DMACreatePageTable
;       In:     r10 ->DMA request block
;       Out:    r1 -> page table
;
;       Creates a page table for the given transfer and fills it with
;       logical addresses and section lengths.
;
DMACreatePageTable
        ENTRY   "r0,r2-r5"

        Debug   dma,"DMACreatePageTable",r10

        LDR     r1, [r10, #dmar_Length]         ; Get length of transfer.
        LDR     lr, [r10, #dmar_Flags]
        TST     lr, #dmarf_Circular             ; If not using a circular buffer then
        BEQ     %FT05                           ;   convert pages spanning length.
        LDR     lr, [r10, #dmar_BuffSize]
        TEQ     r1, #0                          ; Otherwise, if length = 0 (infinite transfer)
        CMPNE   lr, r1                          ;   or buffer size < total length then
        MOVLE   r1, lr                          ;   convert pages spanning buffer size.
05
        LDR     r0, [r10, #dmar_ScatterList]    ; Get scatter list pointer.
        MOV     r4, #0
        LDR     r5, =PAGESIZE-1
        MOV     lr, r1
10
        LDMIA   r0!, {r2,r3}                    ; Get address,length pair.
        TEQ     r3, #0                          ; Skip 0 length entries.
        BEQ     %BT10
        SUBS    lr, lr, r3                      ; Adjust total transfer length.
        ADDCC   r3, lr, r3                      ; If total length < section length then use total length.
        AND     r2, r2, r5                      ; Get start offset into page.
        ADD     r2, r2, r3                      ; Add on section length.
        ADD     r2, r2, r5                      ; Count page for possible end segment.
        ADD     r4, r4, r2, LSR #PAGESHIFT      ; Add no. of pages spanned by this section to total.
        BGT     %BT10

        Debug   dma," page count =",r4

        MOV     r0, #ModHandReason_Claim        ; Claim space for table (r4=no. of pages).
        MOV     r3, r4, LSL #2
        ADD     r3, r3, r3, LSL #1              ; 3 words per entry (r3=r4*12).
        SWI     XOS_Module
        STRVS   r0, [sp]                        ; If error then return r0.
        EXIT    VS

        Debug   dma," page table, size =",r2,r3

        STR     r2, [r10, #dmar_PageTable]
        STR     r4, [r10, #dmar_PageCount]

        LDR     r0, [r10, #dmar_ScatterList]    ; Fill length and logical address fields in table.
20
        LDMIA   r0!, {r4,lr}                    ; Get address,length pair.
        TEQ     lr, #0                          ; Skip 0 length entries.
        BEQ     %BT20
        SUBS    r1, r1, lr                      ; Adjust total transfer length.
        ADDCC   lr, r1, lr                      ; If total length < section length then use total length.
        AND     r3, r4, r5                      ; Get start offset into page.
        RSB     r3, r3, #PAGESIZE               ; Convert to length to end of page.
30
        SUBS    lr, lr, r3                      ; Adjust section length.
        ADDCC   r3, lr, r3                      ; If section length < offset to page end then use section length.
        Debug   dma," length,address =",r3,r4
        STMIA   r2!, {r3,r4,r5}                 ; Store section entry (length, address, r5 just pads it out).
        ADDGT   r4, r4, r3                      ; If more to do then adjust logical address
        MOVGT   r3, #PAGESIZE                   ;   offset to end of page is PAGESIZE from now on
        BGT     %BT30                           ;   and do next page.
        CMP     r1, #0
        BGT     %BT20

        LDR     r1, [r10, #dmar_PageTable]
        EXIT

 [ debug
        LTORG
 ]

;-----------------------------------------------------------------------------
; DMAConvertPageTable
;       In:     r10 ->DMA request block
;
;       Fill in physical addresses in page table and mark pages as uncacheable
;       if reading to memory.
;       However, if StrongARM true, then mark pages as uncacheable for either
;       direction of transfer (we could be running on StrongARM, which has
;       write-back data cache, so DMA from memory to device can be out of date
;       wrt cache).
;
DMAConvertPageTable
        ENTRY   "r0-r3"

        Debug   dma,"DMAConvertPageTable",r10

        MOV     r0, #Memory_LogicalGiven :OR: Memory_PhysicalWanted
        LDR     r1, [r10, #dmar_PageTable]
        TEQ     r1, #0                          ; If no page table yet then
        BLEQ    DMACreatePageTable              ;   create one.
        EXIT    VS
        LDR     r2, [r10, #dmar_PageCount]
        LDR     r3, [r10, #dmar_Flags]
 [ StrongARM
        ORR     r3, r3, #dmarf_Uncacheable      ;   set uncacheable flag
        STR     r3, [r10, #dmar_Flags]
 |
        TST     r3, #dmarf_Direction            ; If reading to memory then
        ORREQ   r3, r3, #dmarf_Uncacheable      ;   set uncacheable flag
        STREQ   r3, [r10, #dmar_Flags]
 ]

 [ MemManager
   [ StrongARM
        ORR     r0, r0, #Memory_SetUncacheable  ;   and mark pages as uncacheable.
   |
        ORREQ   r0, r0, #Memory_SetUncacheable  ;   and mark pages as uncacheable if necessary.
   ]
        Debug   dma," OS_Memory flags,ptable,entries =",r0,r1,r2
        SWI     XOS_Memory
        BICVS   r3, r3, #dmarf_Uncacheable      ; If conversion failed then pages not uncacheable
        STRVS   r3, [r10, #dmar_Flags]
        STRVS   r0, [sp]                        ;   and return error.
 ]

        EXIT

;-----------------------------------------------------------------------------
; DMAReleasePageTable
;       In:     r10 ->DMA request block
;
;       If the operation was read to memory then mark the specified pages
;       as cacheable.  If the transfer has been flagged as completed then
;       the memory for the page table is freed.
;
DMAReleasePageTable
        ENTRY   "r0-r3"

        LDR     r1, [r10, #dmar_PageTable]
        TEQ     r1, #0                          ; If no page table then
        EXIT    EQ                              ;   nothing to do.

        Debug   dma,"DMAReleasePageTable",r10

        LDR     r3, [r10, #dmar_Flags]
        TST     r3, #dmarf_Uncacheable          ; If pages have been marked as uncacheable then
        BICNE   r3, r3, #dmarf_Uncacheable      ;   clear uncacheable flag
        STRNE   r3, [r10, #dmar_Flags]
 [ MemManager
        MOVNE   r0, #Memory_LogicalGiven :OR: Memory_PhysicalGiven :OR: Memory_SetCacheable
        LDRNE   r2, [r10, #dmar_PageCount]
        SWINE   XOS_Memory                      ;   and make them cacheable again.
 ]
        TST     r3, #dmarf_Completed            ; If the transfer has completed then
        MOVNE   r0, #ModHandReason_Free         ;   free the page table.
        MOVNE   r2, r1
        SWINE   XOS_Module

        EXIT

;-----------------------------------------------------------------------------
; DMAActivate
;       In:     r8  ->logical channel block
;               r9  ->DMA queue
;               r10 ->DMA request block
;               r11 = IOMD base address
;
;       Activate the specified DMA request.  The Start routine is only called
;       if the DMA is being activated for the first time.  If a DMA request is
;       already active on this channel or the channel is blocked then the
;       request is simply left in the queue.  If the Start callback returns an
;       error then the request is completed and the error passed back to the
;       caller, the channel also remains claimed so that the caller may try to
;       start another using DMAForceActivate.
;
DMAActivate
        ENTRY   "r1-r4,r11,r12"

        Debug   dma,"DMAActivate",r10

        IRQOff  r3                              ; Stop IRQs messing with queue.

        LDR     lr, [r9, #dmaq_Active]
        TEQ     lr, #0                          ; If there is an active DMA
        DebugIf NE,tmp,"DMA already active"
        LDREQ   lr, [r8, #lcb_Flags]
        TSTEQ   lr, #lcbf_Blocked               ;     or logical channel is blocked then
        DebugIf NE,tmp,"Aborting DMAActivate"
        EXITS   NE                              ;   leave in queue and exit restoring IRQs.

        STR     r10, [r9, #dmaq_Active]         ; Otherwise, make active.
        SetPSR  r3                              ; Claimed channel so reenable IRQs.
        B       %FT05

; Entry point which skips above tests.
DMAForceActivate
        ALTENTRY

        Debug   dma,"DMAForceActivate"

        STR     r10, [r9, #dmaq_Active]         ; Make active.
05
        Debug   dma," activating"

        LDR     r1, [r8, #lcb_Physical]
        DMARegBlk r4, r1                        ; r4->DMA register block for this channel

        LDR     r11, [r10, #dmar_R11]           ; Set up r11 value.
        LDR     r12, [r8, #lcb_R12]             ; Set up r12 value.
        LDR     r1, [r8, #lcb_Vector]           ; r1->vector of routines

        SwpPSR  r3, #SVC_mode+I_bit             ; Ensure SVC mode, no IRQs for callbacks and address conversion (also clears V).
        Push    lr                              ; Save SVC_lr.

        Debug   tmp," r11,r12 =",r11,r12

        LDR     r2, [r10, #dmar_Flags]
        TST     r2, #dmarf_BeenActive           ; If not been active before then
        MOVEQ   lr, pc                          ;   call Start routine.
        LDREQ   pc, [r1, #vector_Start]
        BVS     %FT40

        BL      DMAConvertPageTable
        BVS     %FT40

        Debug   tmp," r11,r12 =",r11,r12

        MOV     lr, #IOMD_DMA_C_Bit             ; Clear DMA channel before calling Enable (stop extra transfers).
        STRB    lr, [r4, #IOMD_IOxCR]
        MOV     lr, pc                          ; Call Enable routine.
        LDR     pc, [r1, #vector_Enable]

        Pull    lr                              ; Restore SVC_lr.
        SetPSR  r3                              ; Back to original mode/IRQs.

        Debug   dma," start and enable called"

        ADD     lr, r10, #dmar_BuffA            ; Initialise last buffer programmed.
        STR     lr, [r9, #dmaq_LastBuff]

        TST     r2, #dmarf_BeenActive           ; If resuming a suspended request then
        BNE     %FT10                           ;   don't initialise any more.

        Debug   dma," initialising request block"

        MOV     r11, #0
        MOV     r12, #0

        LDR     r1, [r10, #dmar_PageTable]
        STMIA   lr!, {r1,r11,r12}               ; Initialise buff A.
        STMIA   lr, {r1,r11,r12}                ; Initialise buff B.

        TST     r2, #dmarf_Circular             ; Initialise data for circular buffer (if used).
        LDRNE   r1, [r10, #dmar_BuffSize]
        STRNE   r1, [r10, #dmar_BuffLen]

        TST     r2, #dmarf_Sync                 ; Initialise data for DMASync callback (if used).
        LDRNE   r1, [r10, #dmar_SyncGap]
        STRNE   r1, [r10, #dmar_ProgGap]
        STRNE   r12, [r10, #dmar_Gap]

10
        LDR     r3, [r8, #lcb_Flags]            ; Set up control register.
        AND     r1, r3, #lcbf_TransferSize
        ORR     r1, r1, #IOMD_DMA_C_Bit :OR: IOMD_DMA_E_Bit
        AND     r2, r2, #dmarf_Direction
        EOR     r2, r2, #dmarf_Direction        ; Someone screwed up, direction bit wrong way round!
        ORR     r1, r1, r2, LSL #6
        STRB    r1, [r4, #IOMD_IOxCR]           ; Set control register.
        Debug   dma," set control (cr,block) =",r1,r12

 [ :LNOT: IOMD
        MOV     r1, #IOMD_DMA_O_Bit :OR: IOMD_DMA_I_Bit
        STRB    r1, [r4, #IOMD_IOxST]
 ]

        MOV     r11, #IOMD_Base                 ; Restore r11=IOMD base address.
        LDR     r2, [r8, #lcb_Physical]         ; r2=physical channel number
        CMP     r2, #4                          ; If it's not one of the general IO channels then
        BCS     %FT20                           ;   no need to program DMATCR.

        MOV     r1, #&03                        ; Set cycle speed in DMATCR.
        MOV     r1, r1, LSL r2
        AND     r3, r3, #lcbf_DMASpeed
        MOV     r3, r3, LSR #5
        MOV     r3, r3, LSL r2
        IRQOff  r12
        LDRB    lr, [r11, #IOMD_DMATCR]
        BIC     lr, lr, r1, LSL r2
        ORR     lr, lr, r3, LSL r2
        STRB    lr, [r11, #IOMD_DMATCR]
        SetPSR  r12
        Debug   dma," DMATCR =",lr
20
        LDR     r12, [sp, #20]                  ; Restore our workspace pointer.
        LDR     r1, UnsafePageTable
        TEQ     r1, #0                          ; If no unsafe page table then
        BEQ     %FT30                           ;   start the transfer.

        MOV     r2, r1                          ; Otherwise, scan the page table for unsafe pages.
        LDR     r3, UnsafePageCount
        LDR     r1, [r10, #dmar_Flags]
        BL      DMAUnsafeScan
        TST     r1, #dmarf_Halted               ; If transfer is halted then
        EXITS   NE                              ;   wait for Service_PagesSafe to start it.
        LDR     r2, [r8, #lcb_Physical]
30
        IRQOff  lr
        MOV     r3, #1                          ; Enable interrupt for this channel.
        LDRB    r1, [r11, #IOMD_DMAMSK]
        ORR     r1, r1, r3, LSL r2
        STRB    r1, [r11, #IOMD_DMAMSK]

 [ :LNOT: IOMD
        LDRB    r1, [r11, #IOMD_DMASTA]
        ORR     r1, r1, r3, LSL r2
        STRB    r1, [r11, #IOMD_DMASTA]
        SUB     r1, r4, r11
        Push    "r0-r3,r11"
        BL      DMAInterruptCommon
        Pull    "r0-r3,r11"
        Debug   dma," interrupt done"
 ]

        EXITS                                   ; Exit restoring IRQs.

40
        ORR     r2, r2, #dmarf_Completed        ; If we got an error along the way then
        STR     r2, [r10, #dmar_Flags]          ;   set completed flag
        MOV     lr, pc                          ;   call Completed call back (r11,r12 still set up)
        LDR     pc, [r1, #vector_Completed]
        BL      DMAReleasePageTable             ;   free page table
        Pull    lr                              ;   restore SVC_lr
        SetPSR  r3                              ;   go back to original mode/IRQs

        Debug   dma," error in activate, complete called"

        SETV                                    ;   and pass error back to caller.
        EXIT

;-----------------------------------------------------------------------------
; DMATerminate
;       In:     r0  = 0 (suspend) or ->error block (terminate)
;               r1  = DMA tag
;               r8  ->logical channel block
;               r9  ->DMA queue
;               r10 ->DMA request block
;               r11 = IOMD base address
;
;       Terminate the specified DMA request.  An error is returned if the
;       request block is invalid.  If the request is not active and we are
;       terminating then the Completed callback is called and the routine
;       exits.  If the request is not active and we are suspending then an
;       error is returned.  If the request is active then it is stopped,
;       the scatter list is updated and the appropriate action taken for
;       suspend or terminate.  The stopped request is left blocking the
;       physical channel and must be removed by the caller (usually by
;       calling DMASearchQueue).
;
DMATerminate
        ENTRY   "r0-r8,r11,r12"

        Debug   dma,"DMATerminate",r10

        IRQOff  r7                              ; Stop IRQs messing with queue.

        LDR     lr, [r10, #dmar_Tag]            ; Make sure it's still there.
        TEQ     lr, r1
        adrdeb  r0, ErrorBlock_DMA_BadTag, NE
        BNE     %FT70

        LDR     lr, [r9, #dmaq_Active]
        TEQ     lr, r10                         ; If not active then
        BNE     %FT80                           ;   deal with it.

        LDR     r1, [r8, #lcb_Physical]         ; Otherwise, disable channel IRQ.
        MOV     r2, #1
        LDRB    lr, [r11, #IOMD_DMAMSK]
        BIC     lr, lr, r2, LSL r1
        STRB    lr, [r11, #IOMD_DMAMSK]

        SetPSR  r7                              ; Reenable general IRQs.

        DMARegBlk r2, r1                        ; r2->IOMD DMA register block
        LDRB    r1, [r2, #IOMD_IOxCR]
        BIC     r1, r1, #IOMD_DMA_E_Bit
        STRB    r1, [r2, #IOMD_IOxCR]           ; Disable DMA.
        Debug   term," transfer halted, CR =",r1

        LDR     r11, [r10, #dmar_R11]           ; Set up r11 value.
        LDR     r12, [r8, #lcb_R12]             ; Set up r12 value.
        LDR     r3, [r8, #lcb_Vector]           ; r3->vector of routines

        MOV     lr, pc                          ; Call Disable routine.
        LDR     pc, [r3, #vector_Disable]

        LDRB    r1, [r2, #IOMD_IOxST]           ; Get current state.
        Debug   term," ST =",r1

        TST     r1, #IOMD_DMA_B_Bit
        ADDEQ   r2, r2, #IOMD_IOxCURA           ; r2 -> active buffer
        ADDNE   r2, r2, #IOMD_IOxCURB
        ADDEQ   r3, r10, #dmar_BuffA            ; r3 -> active buffer info
        ADDNE   r3, r10, #dmar_BuffB
        ADDEQ   r4, r10, #dmar_BuffB            ; r4 -> inactive buffer info
        ADDNE   r4, r10, #dmar_BuffA

        LDR     r8, [r10, #dmar_Flags]

        TST     r1, #IOMD_DMA_I_Bit             ; If in interrupt state then
        MOVNE   r0, r4                          ;   update from inactive buffer.
        BLNE    update
10
        LDMIA   r3, {r5,r6,r7}                  ; Get active buffer ptp, off, len.
        Debug   term," active ptp,off,len =",r5,r6,r7

        TEQ     r7, #0                          ; If active buffer not programmed then
        LDREQ   r0, [sp]                        ;   must have completed.
        BEQ     %FT60

        TST     r1, #IOMD_DMA_O_Bit             ; If in overrun state then
        MOVNE   r2, r7                          ;   amount done = programmed length
        LDREQ   r2, [r2]                        ; else determine amount actually done
        BICEQ   r2, r2, #7:SHL:29               ;   clear top 3 bits of current address
        LDREQ   lr, [r5, #ptab_Physical]        ;   get start address from page table
        SUBEQ   r2, r2, lr
        SUBEQ   r2, r2, r6                      ;   amount done = current - start address - off
        STREQ   r2, [r3, #buff_Len]             ;   and pretend we programmed the amount actually done.
        Debug   term," active done =",r2

        MOV     r0, r3                          ; Update from the active buffer.
        BL      update

        LDR     r0, [sp]                        ; Get back err (or 0).
        TEQ     r0, #0                          ; If we have an error then
        BNE     %FT60                           ;   terminate not suspend.

        TST     r8, #dmarf_Sync                 ; If doing DMA sync then
        BEQ     %FT20
        BL      DMASync                         ;   do DMASync callbacks that should have happened,
        LDR     lr, [r10, #dmar_SyncGap]
        LDR     r0, [r10, #dmar_Gap]
        SUB     lr, lr, r0                      ;   new ProgGap = SyncGap - Gap.
        Debug   term," ProgGap =",lr
        STR     lr, [r10, #dmar_ProgGap]
20
        SUB     r0, r7, r2                      ; r0 = amount programmed but not transferred
        TST     r1, #IOMD_DMA_I_Bit             ; If not in interrupt state then
        LDREQ   lr, [r4, #buff_Len]             ;   add on inactive length programmed.
        ADDEQ   r0, r0, lr
        Debug   term," not done =",r0

        LDR     lr, [r10, #dmar_Length]         ; Add amount not done back onto total length.
        ADD     lr, lr, r0
        STR     lr, [r10, #dmar_Length]
        Debug   term," Length =",lr

        TST     r8, #dmarf_Circular             ; If not circular buffer then
        BEQ     %FT50                           ;   set up for resume.

        LDR     lr, [r10, #dmar_BuffLen]
        ADD     lr, lr, r0                      ; BuffLen left += amount not done
        LDR     r0, [r10, #dmar_BuffSize]
40
        CMP     lr, r0
        SUBCS   lr, lr, r0                      ; BuffLen left = BuffLen left mod BuffSize
        BCS     %BT40
        STR     lr, [r10, #dmar_BuffLen]
        Debug   term," BuffLen =",lr
50
        ADD     r6, r6, r2                      ; Resume offset = old offset + active amount done
        MOV     r7, #0                          ; Resume len = 0
        ADD     lr, r10, #dmar_BuffA            ; Set up BuffA for resume.
        STMIA   lr!, {r5,r6,r7}
        Debug   term," BuffA =",r5,r6,r7
        STR     r7, [lr, #buff_Len]             ; Set BuffB as not programmed.
        BL      DMAReleasePageTable             ; Will not free the table, only mark pages as cacheable (if reading).
        Debug   term," suspended"
        EXITS

60
        Debug   term," already completed"
        ORR     r8, r8, #dmarf_Completed        ; Tell the world it's completed.
        STR     r8, [r10, #dmar_Flags]
        TEQ     r0, #0                          ; If error then
        SETV    NE                              ;   set V.
        LDR     r8, [r10, #dmar_LCB]
        LDR     r3, [r8, #lcb_Vector]           ; Call Completed (r11,r12 already set up).
        MOV     lr, pc
        LDR     pc, [r3, #vector_Completed]
        BL      DMAReleasePageTable             ; Free the page table.
        Debug   term," terminated"
        EXITS

70
        SetPSR  r7
        Debug   term," error, tag changed"
        STR     r0, [sp]
        PullEnv
        DoError

80
        TEQ     r0, #0                          ; Not active so if terminating then
        LDRNE   lr, [r10, #dmar_Flags]          ;   stop it being activated when IRQs reenabled.
        ORRNE   lr, lr, #dmarf_Completed
        STRNE   lr, [r10, #dmar_Flags]

        SetPSR  r7                              ; Restore IRQ status.

        Debug   term," terminating inactive transfer"

        TEQ     r0, #0                          ; If suspending then
        PullEnv EQ                              ;   return error.
        ADREQ   r0, ErrorBlock_DMA_NotActive
        DoError EQ

        SETV
        LDR     r3, [r8, #lcb_Vector]           ; Call Completed call back.
        LDR     r11, [r10, #dmar_R11]
        LDR     r12, [r8, #lcb_R12]
        MOV     lr, pc
        LDR     pc, [r3, #vector_Completed]
        BL      DMAReleasePageTable             ; Free the page table.
        EXITS

        MakeErrorBlock  DMA_NotActive

;-----------------------------------------------------------------------------
; DMACompleted
;       In:     r0  = 0 or ->error block
;               r8  ->logical channel block
;               r9  ->DMA queue
;               r10 ->DMA request block
;
;       The specified DMA request has completed.  The Disable routine
;       is only called if no error is provided (ie. the DMA has completed
;       successfully).
;
DMACompleted
        ENTRY   "r1,r2,r11,r12"

        Debug   dma,"DMACompleted",r10

        LDR     r11, [r10, #dmar_R11]           ; Set up r11 value.
        LDR     r12, [r8, #lcb_R12]             ; Set up r12 value.
        LDR     r1, [r8, #lcb_Vector]           ; r1->vector of routines

        SwpPSR  r2, #SVC_mode+I_bit             ; Ensure SVC mode, no IRQs for callbacks and freeing page table.
        Push    lr                              ; Save SVC_lr.

        TEQ     r0, #0                          ; If error then
        SETV    NE                              ;   set V flag for Completed routine
        MOVEQ   lr, pc                          ; else call Disable routine.
        LDREQ   pc, [r1, #vector_Disable]

        MOV     lr, pc                          ; Call Completed routine.
        LDR     pc, [r1, #vector_Completed]

        LDR     lr, [r10, #dmar_Flags]          ; Mark as completed.
        ORR     lr, lr, #dmarf_Completed
        STR     lr, [r10, #dmar_Flags]

        Pull    lr
        SetPSR  r2

        BL      DMAReleasePageTable             ; Free the page table.

        EXITS

;-----------------------------------------------------------------------------
; DMAPagesUnsafe
;       In:     r2  ->Page table with 3-word entries for each unsafe page
;               r3  = Number of entries in table
;
;       The DMA manager has received Service_PagesUnsafe and calls this
;       code to scan the page tables of all active DMA transfers.  If an
;       unsafe page is found then it is flagged as unsafe and the transfer
;       may be temporarily halted until Service_PagesSafe is received.
;
DMAPagesUnsafe
        ENTRY   "r0,r1,r9-r11"

        Debug   unsf,"DMAPagesUnsafe",r2,r3

        ASSERT  UnsafePageCount = UnsafePageTable + 4
        ADR     lr, UnsafePageTable             ; Store unsafe page table and count, to be checked
        STMIA   lr, {r2,r3}                     ;   when new transfers are activated.

        MOV     r0, #NoPhysicalChannels
        ADR     r9, DMAQueues-DMAQSize          ; Set r9 so that increment below points to first channel.
        IOMDBase r11
        IRQOff  lr
10
        SUBS    r0, r0, #1                      ; If no more channels to scan then
        EXITS   CC                              ;   exit.

        Debug   unsf," channel",r0
        ADD     r9, r9, #DMAQSize               ; Move on to next channel.
        LDR     r10, [r9, #dmaq_Active]         ; Get pointer to active DMA request block.
        TEQ     r10, #0                         ; If nothing active then
        BEQ     %BT10                           ;   try next channel.
        LDR     r1, [r10, #dmar_Flags]
        TST     r1, #dmarf_Completed            ; If completed then
        BNE     %BT10                           ;   try next channel.

        BL      DMAUnsafeScan
        B       %BT10

;-----------------------------------------------------------------------------
; DMAUnsafeScan
;       In:     r1  = DMA request block flags
;               r2  ->Page table of unsafe pages
;               r3  = Number of entries in page table
;               r10 ->DMA request block
;               r11 = IOMD base address
;       Out:    r1  = Possibly updated flags
;
;       Scan the page table for the given transfer looking for unsafe
;       pages.  The transfer is halted if transferring using an unsafe page.
;
DMAUnsafeScan
        ENTRY   "r2-r7"

        Debug   unsf,"DMAUnsafeScan"

        LDR     r4, [r10, #dmar_PageTable]      ; Get our page table pointer.
        LDR     r5, [r10, #dmar_PageCount]      ; Get the number of pages in our table.
        Debug   unsf," page table,count =",r4,r5
        ADD     r4, r4, #ptab_Physical          ; Point to the first physical address in our table.
        LDR     r7, =PAGESIZE-1
20
        LDR     r6, [r4], #PTABSize             ; Get physical address from our table and move on pointer.
        ADD     r2, r2, #ptab_Physical          ; Point to the first physical address in callers table.
30
        LDR     lr, [r2], #PTABSize             ; Get physical address from callers table and move on pointer.
        EOR     lr, lr, r6
        BICS    lr, lr, r7
        LDREQ   lr, [r4, #ptab_Len-(PTABSize+ptab_Physical)]    ; If same address then
        ORREQ   lr, lr, #ptabf_Unsafe                           ;   mark page as unsafe
        STREQ   lr, [r4, #ptab_Len-(PTABSize+ptab_Physical)]
        BLEQ    DMAHalt                                         ;   halt transfer if necessary.
        SUBNES  r3, r3, #1                      ; If not same address and still pages in callers table then
        BNE     %BT30                           ;   try next address in callers table.

        SUBS    r5, r5, #1                      ; If more pages in our table then
        LDMNEIA sp, {r2,r3}                     ;   restore pointer to callers table and callers page count
        BNE     %BT20                           ;   try next address in our table
        EXIT                                    ; else exit.

;-----------------------------------------------------------------------------
; DMAHalt
;       In:     r1  = DMA request block flags
;               r4  = pointer to page table entry + PTABSize+ptab_Physical
;               r10 ->DMA request block
;               r11 = IOMD base address
;       Out:    r1  = possibly updated flags
;
;       Determine if the given unsafe page is being used by the active
;       transfer and if it is then halt the transfer.
;
DMAHalt
        ENTRY   "r0,r2,r3"

        TST     r1, #dmarf_Halted               ; If already halted then
        EXITS   NE                              ;   nothing to do.

        Debug   unsf,"DMAHalt",r10

        LDR     r0, [r10, #dmar_Tag]
        AND     r0, r0, #dmar_PhysBits          ; r0=physical channel number
        DMARegBlk r3, r0                        ; r3->IOMD DMA register set

        LDRB    r2, [r3, #IOMD_IOxST]           ; Get current state.
        Debug   unsf," ST =",r2
        TST     r2, #IOMD_DMA_O_Bit             ; If in overrun state then
        EXITS   NE                              ;   not active so leave to interrupt routine.

        TST     r2, #IOMD_DMA_B_Bit             ; Load active buffer page table pointer.
        LDREQ   lr, [r10, #dmar_BuffA+buff_Ptp]
        LDRNE   lr, [r10, #dmar_BuffB+buff_Ptp]
        ADD     lr, lr, #PTABSize + ptab_Physical
        Debug   unsf," test",r4,lr
        TEQ     r4, lr                          ; If active on unsafe page then
        BEQ     %FT10                           ;   halt transfer.

        TST     r2, #IOMD_DMA_I_Bit             ; If in interrupt state then
        EXITS   NE                              ;   inactive has completed or is not programmed.

        TST     r2, #IOMD_DMA_B_Bit             ; Load inactive buffer page table pointer.
        LDREQ   lr, [r10, #dmar_BuffB+buff_Ptp]
        LDRNE   lr, [r10, #dmar_BuffA+buff_Ptp]
        ADD     lr, lr, #PTABSize + ptab_Physical
        TEQ     r4, lr                          ; If inactive not on unsafe page then
        EXITS   NE                              ;   nothing to do.
10
        Debug   unsf," halting transfer"
        LDRB    lr, [r3, #IOMD_IOxCR]           ; Disable DMA state machine.
        BIC     lr, lr, #IOMD_DMA_E_Bit
        STRB    lr, [r3, #IOMD_IOxCR]
        LDRB    lr, [r11, #IOMD_DMAMSK]         ; Disable channel interrupt.
        MOV     r3, #1
        BIC     lr, lr, r3, LSL r0
        STRB    lr, [r11, #IOMD_DMAMSK]
        ORR     r1, r1, #dmarf_Halted           ; Flag transfer as halted.
        STR     r1, [r10, #dmar_Flags]

        EXITS

;-----------------------------------------------------------------------------
; DMAPagesSafe
;       In:     r2  = Number of entries in tables
;               r3  ->Page table with 3-word entries for old pages
;               r4  ->Page table with 3-word entries for new pages
;
;       The DMA manager has received Service_PagesSafe and calls this code
;       to scan the page tables of all active DMA transfers.  If a page
;       flagged as unsafe is now safe then the flag is removed and the
;       transfer may be continued if it had been halted by DMAPagesUnsafe.
;
DMAPagesSafe
        ENTRY   "r2-r12"

        Debug   safe,"DMAPagesSafe"

        MOV     lr, #0                          ; Pages are now safe so
        STR     lr, UnsafePageTable             ;   allow new transfers to start up unchecked.

        MOV     r7, #NoPhysicalChannels
        LDR     r8, =PAGESIZE-1
        ADR     r9, DMAQueues-DMAQSize          ; Set r9 so that increment below points to first channel.
10
        SUBS    r7, r7, #1                      ; If no more channels to scan then
        EXIT    CC                              ;   exit.

        ADD     r9, r9, #DMAQSize               ; Move on to next channel.
        LDR     r10, [r9, #dmaq_Active]         ; Get pointer to active DMA request block.
        Debug   safe," transfer =",r10
        TEQ     r10, #0                         ; If nothing active then
        BEQ     %BT10                           ;   try next channel.
        LDR     lr, [r10, #dmar_Flags]
        Debug   safe," flags =",lr
        TST     lr, #dmarf_Completed            ; If completed then
        BNE     %BT10                           ;   try next channel.
        TST     lr, #dmarf_Halted               ; If not halted then
        BEQ     %BT10                           ;   try next channel.

        ASSERT  ptab_Len = 0
        LDR     r5, [r10, #dmar_PageTable]      ; Get our page table pointer
        LDR     r6, [r10, #dmar_PageCount]      ; Get the number of pages in our table.
        Debug   safe," scanning table,len =",r5,r6
20
        SUBS    r6, r6, #1                      ; If no more pages in our table then
        BLCC    DMAContinue                     ;   get DMA going again if possible
        BCC     %BT10                           ;   and try next channel.
        LDR     r11, [r5], #PTABSize            ; Get page table entry length and move on pointer.
        TST     r11, #ptabf_Unsafe              ; If this page is not unsafe then
        BEQ     %BT20                           ;   try next page.
        LDR     r12, [r5, #ptab_Physical-PTABSize]      ; Get physical address of our unsafe page.

        ADD     r3, r3, #ptab_Physical          ; Point to the first physical address in callers old table.
30
        LDR     lr, [r3], #PTABSize             ; Get physical address from callers old table.
        EOR     lr, lr, r12
        BICS    lr, lr, r8
        LDREQ   lr, [r4, #ptab_Physical]                ; If same address then get new physical address from callers new table
        ANDEQ   r12, r12, r8
        ORREQ   lr, lr, r12                             ;   or in the offset within the page
        STREQ   lr, [r5, #ptab_Physical-PTABSize]       ;   replace the old address in our table with the new address
        BICEQ   r11, r11, #ptabf_Unsafe                 ;   and mark page as safe.
        STREQ   r11, [r5, #ptab_Len-PTABSize]
        SUBNES  r2, r2, #1                      ; If not same address and still pages in callers table then
        ADDNE   r4, r4, #PTABSize               ;   move on new table pointer
        BNE     %BT30                           ;   and try next address in callers table.

        LDMIA   sp, {r2-r4}                     ; Restore pointers to callers tables and callers page count.
        B       %BT20                           ; Try next page in our table.

;-----------------------------------------------------------------------------
; DMAContinue
;       In:     r8  = PAGESIZE-1
;               r10 ->DMA request block
;
;       If the unsafe pages which caused a transfer to be halted are now
;       safe then the transfer is continued.
;
DMAContinue
        ENTRY   "r0-r2,r11"

        Debug   safe,"DMAContinue",r10

        LDR     r0, [r10, #dmar_Tag]
        AND     r0, r0, #dmar_PhysBits          ; r0=physical channel number
        IOMDBase r11
        DMARegBlk r1, r0                        ; r1->IOMD DMA register set

        LDR     lr, [r10, #dmar_BuffA+buff_Len]
        TEQ     lr, #0                          ; If BuffA is not programmed then
        BEQ     %FT10                           ;   skip check.

        Debug   safe," reprogramming A"
        LDR     r2, [r10, #dmar_BuffA+buff_Ptp]
        LDR     lr, [r2, #ptab_Len]
        TST     lr, #ptabf_Unsafe               ; If the page is still unsafe then
        EXITS   NE                              ;   cannot continue transfer.
        LDR     lr, [r1, #IOMD_IOxCURA]         ; Get address currently programmed.
        AND     lr, lr, r8                      ; Only want the offset
        LDR     r2, [r2, #ptab_Physical]        ; Get the new address.
        BIC     r2, r2, r8                      ; Don't want the offset.
        ORR     lr, lr, r2                      ; Combine into continuation address.
        STR     lr, [r1, #IOMD_IOxCURA]         ; Reprogram IOMD.
        Debug   safe," with",lr
10
        LDR     lr, [r10, #dmar_BuffB+buff_Len]
        TEQ     lr, #0                          ; If BuffB is not programmed then
        BEQ     %FT20                           ;   skip check.

        Debug   safe," reprogramming B"
        LDR     r2, [r10, #dmar_BuffB+buff_Ptp]
        LDR     lr, [r2, #ptab_Len]
        TST     lr, #ptabf_Unsafe               ; If the page is still unsafe then
        EXITS   NE                              ;   cannot continue transfer.
        LDR     lr, [r1, #IOMD_IOxCURB]         ; Get address currently programmed.
        AND     lr, lr, r8                      ; Only want the offset
        LDR     r2, [r2, #ptab_Physical]        ; Get the new address.
        BIC     r2, r2, r8                      ; Don't want the offset.
        ORR     lr, lr, r2                      ; Combine into continuation address.
        STR     lr, [r1, #IOMD_IOxCURB]         ; Reprogram IOMD.
        Debug   safe," with",lr
20
        Debug   safe," restarting transfer"
        IRQOff  lr

        LDRB    lr, [r1, #IOMD_IOxCR]           ; Enable DMA state machine.
        ORR     lr, lr, #IOMD_DMA_E_Bit
        STRB    lr, [r1, #IOMD_IOxCR]
        LDRB    lr, [r11, #IOMD_DMAMSK]         ; Enable channel interrupt.
        MOV     r1, #1
        ORR     lr, lr, r1, LSL r0
        STRB    lr, [r11, #IOMD_DMAMSK]
        LDR     lr, [r10, #dmar_Flags]          ; Remove halted flag.
        BIC     lr, lr, #dmarf_Halted
        STR     lr, [r10, #dmar_Flags]

        EXITS

;-----------------------------------------------------------------------------
; DMASearchQueue
;       In:     r9  ->DMA queue
;               r11 = IOMD base address
;
;       Search queue for a DMA request which can be activated.  It is assumed
;       that a completed or terminated request is blocking the physical channel
;       so DMAForceActivate is called to start a new request.  IRQs are disabled
;       during this call because requests in the queue have tags in the outside
;       world and can be terminated/altered under interrupt.  We don't want the
;       queue to change or a request to be deleted in the middle of setting it up!
;
DMASearchQueue
        ENTRY   "r7,r8,r10"

        Debug   dma,"DMASearchQueue",r9

        IRQOff  lr

        LDR     r7, [r9, #dmaq_Head]
15
        TEQ     r7, #0                          ; If end of queue then
        STREQ   r7, [r9, #dmaq_Active]          ;   no active DMA and return.
        EXITS   EQ

        MOV     r10, r7
        LDR     r7, [r10, #dmar_Next]           ; Get next in case we need it later.

        LDR     lr, [r10, #dmar_Flags]
        TST     lr, #dmarf_Suspended + dmarf_Completed  ; If suspended or completed then
        BNE     %BT15                                   ;   try next.

        LDR     r8, [r10, #dmar_LCB]            ; r8->logical channel block
        LDR     lr, [r8, #lcb_Flags]
        TST     lr, #lcbf_Blocked               ; If logical channel is blocked then
        BNE     %BT15                           ;   try next.

        CLRV
        BL      DMAForceActivate
        EXITS   VC                              ; Exit if started successfully.

        BL      DMAUnlinkRequest                ; If Start callback returned error then
        BL      DMAFreeRequestBlock             ;   free block
        B       %BT15                           ;   and try next.

;-----------------------------------------------------------------------------
; DMAPurge
;       In:     r7 <> 0 => don't try to start transfers on unblocked channels
;               r8  ->logical channel block
;       Out:    all registers preserved
;
;       Purge all DMA requests for the channel specified.  If the active DMA
;       on the appropriate physical channel is for this channel then it is
;       terminated.
;
DMAPurge
        ENTRY   "r0-r2,r9-r11"

        Debug   purge,"DMAPurge",r8

        ADR     r0, ErrorBlock_DMA_Deregistered ; r0->deregistered error
      [ international
        BL      MsgTrans_ErrorLookup
      ]
        IRQOff  lr                              ; Stop interrupts messing around with queues.
        MOV     r2, #0

        LDR     r9, [r8, #lcb_Queue]            ; r9->DMA queue
        Debug   purge," queue = ",r9
        LDR     r10, [r9, #dmaq_Head]           ; Purge DMA queue.
20
        Debug   purge," DMA = ",r10
        TEQ     r10, #0                         ; If end of queue then stop.
        BEQ     %FT30

        LDR     r1, [r10, #dmar_Next]

        LDR     lr, [r10, #dmar_LCB]
        TEQ     lr, r8                          ; If different channel then
        MOVNE   r10, r1                         ;   skip to next.
        BNE     %BT20

        LDR     lr, [r9, #dmaq_Active]
        TEQ     lr, r10                         ; If this one is active then
        MOVEQ   r2, r10                         ;   remember for later
        BLNE    DMACompleted                    ; else just complete.
        BLNE    DMAUnlinkRequest
        BLNE    DMAFreeRequestBlock

        TEQ     r1, #0
        MOVNE   r10, r1                         ; Test next request block.
        BNE     %BT20
30
        TEQ     r2, #0                          ; If nothing to terminate then
        EXITS   EQ                              ;   exit.

        MOV     r10, r2
        IOMDBase r11
        LDR     r1, [r10, #dmar_Tag]
        BL      DMATerminate
        BL      DMAUnlinkRequest
        BL      DMAFreeRequestBlock
        TEQ     r7, #0
        BLEQ    DMASearchQueue
        EXITS

        MakeErrorBlock  DMA_Deregistered

;-----------------------------------------------------------------------------
; DMAActiveDone
;       In:     r8 -> logical channel block
;               r10 -> DMA request block
;       Out     r0 = amount done
;
;       Return the amount of the active buffer which has been transferred.
;
DMAActiveDone
        ENTRY   "r1-r4,r11"

        Debug   dma,"DMAActiveDone",r10

        LDR     lr, [r8, #lcb_Physical]
        IOMDBase r11
        DMARegBlk r0, lr                        ; r0 -> DMA register block

        LDRB    lr, [r0, #IOMD_IOxST]           ; Get current state.
        TST     lr, #IOMD_DMA_B_Bit
        ADDEQ   r1, r10, #dmar_BuffA            ; r1 -> active buffer info
        ADDNE   r1, r10, #dmar_BuffB
        LDREQ   r4, [r10, #dmar_BuffB + buff_Len]       ; r4 = inactive buffer len
        LDRNE   r4, [r10, #dmar_BuffA + buff_Len]
        ADDEQ   r0, r0, #IOMD_IOxCURA           ; r0 -> active buffer
        ADDNE   r0, r0, #IOMD_IOxCURB

        LDMIA   r1, {r1-r3}                     ; Get active buffer ptp, off, len.

        TST     lr, #IOMD_DMA_O_Bit             ; If in overrun then both have completed so
        ADDNE   r0, r3, r4                      ;   return active len + inactive len.
        EXIT    NE

        LDR     r0, [r0]                        ; Get active buffer current.
        BIC     r0, r0, #7:SHL:29               ; Only want bits 0-28.
        LDR     r1, [r1, #ptab_Physical]        ; Get start address.
        SUB     r0, r0, r1                      ; Amount done = current - start - off
        SUB     r0, r0, r2

        TST     lr, #IOMD_DMA_I_Bit             ; If in interrupt state then inactive completed so
        ADDNE   r0, r0, r4                      ;   amount done += inactive len.

        EXIT

;-----------------------------------------------------------------------------
; DMASync
;       In:     r8 = DMA request flags
;               r9 -> DMA queue
;               r10 -> DMA request block
;       Out:    All registers preserved
;
;       Do any pending DMASync callbacks.
;
DMASync
        ENTRY   "r0-r3,r11,r12"

        Debug   int,"DMASync",r10

        LDR     r1, [r10, #dmar_Gap]
        LDR     r2, [r10, #dmar_SyncGap]
        CMP     r1, r2                          ; If Gap done < SyncGap then
        EXIT    CC                              ;   no callbacks to do.

        Debug   int," gap,syncgap =",r1,r2
        DebugTab r0,r3,#&31,r1,r2

        LDR     r0, [r10, #dmar_LCB]            ; r0 -> logical channel block
        LDR     r3, [r0, #lcb_Vector]           ; r3 -> vector of callback routines
        LDR     r11, [r10, #dmar_R11]           ; Get r11 value.
        LDR     r12, [r0, #lcb_R12]             ; Get r12 value.
10
        MOV     lr, pc                          ; Call DMASync routine.
        LDR     pc, [r3, #vector_DMASync]

        SUB     r1, r1, r2
        TEQ     r0, #0
        BNE     %FT20

        CMP     r1, r2
        BCS     %BT10

        STR     r1, [r10, #dmar_Gap]
        EXIT
20
        STR     r1, [r10, #dmar_Gap]

        SUBS    r0, r0, r1                      ; Subtract bit of next gap already done (if any).
        LDRCS   lr, [r10, #dmar_BuffA+buff_Len] ; If still more to do then
        SUBCSS  r0, r0, lr                      ;   subtract amount programmed in BuffA (if any).
        LDRCS   lr, [r10, #dmar_BuffB+buff_Len] ; If still more to do then
        SUBCSS  r0, r0, lr                      ;   subtract amount programmed in BuffB (if any).
        LDRLS   r0, [r10, #dmar_LCB]            ; Unfortunately, we need something more to program as the last
        LDRLS   r0, [r0, #lcb_Flags]            ;   buffer to complete must have the Stop bit set in the end register
        ANDLS   r0, r0, #lcbf_TransferSize      ;   so if we've gone bust then just set length to the transfer unit size, not 0.

        TST     r8, #dmarf_Infinite
        STRNE   r0, [r10, #dmar_Length]         ; If this was an infinite length transfer then set new length,
        BNE     %FT30                           ;   update flags and exit.
        LDR     lr, [r10, #dmar_Length]
        CMP     r0, lr                          ; If we're being asked to do less than we've got left then
        STRCC   r0, [r10, #dmar_Length]         ;   set new length.
30
        BIC     r8, r8, #dmarf_Infinite :OR: dmarf_Sync
        STR     r8, [r10, #dmar_Flags]          ; No longer infinite and don't do any more sync callbacks.

        EXIT

;-----------------------------------------------------------------------------
;       Channel specific interrupt handler entry points.  These simply set
;       up some registers then branch to the common interrupt handler.
;
DMAInterruptSound1
        MOV     r1, #IOMD_SD1CURA
        MOV     r2, #5
        B       DMAInterruptCommon

DMAInterruptSound0
        MOV     r1, #IOMD_SD0CURA
        MOV     r2, #4
        B       DMAInterruptCommon

DMAInterruptChannel3
        MOV     r1, #IOMD_IO3CURA
        MOV     r2, #3
        B       DMAInterruptCommon

DMAInterruptChannel2
        MOV     r1, #IOMD_IO2CURA
        MOV     r2, #2
        B       DMAInterruptCommon

DMAInterruptChannel1
        MOV     r1, #IOMD_IO1CURA
        MOV     r2, #1
        B       DMAInterruptCommon

DMAInterruptChannel0
        MOV     r1, #IOMD_IO0CURA
        MOV     r2, #0
;       Drop through to...

;-----------------------------------------------------------------------------
; DMAInterruptCommon
;       In:     IRQ mode, IRQs disabled
;               r1  = offset to IOMD DMA registers for channel concerned
;               r2  = physical channel number
;               r0-r3,r11 trashable
;               r12->our workspace
;
;       Common DMA interrupt handler.
;
DMAInterruptCommon
        DebugTab r0,r3,#&01,sp,lr

        ENTRY   "r4-r10"

        IOMDBase r11

 [ debugint
        LDRB    r3, [r11, #IOMD_DMAMSK]
        MOV     lr, #0
        STRB    lr, [r11, #IOMD_DMAMSK]
        TEQP    pc, #SVC_mode + I_bit
        NOP
        Push    "r3,lr"
 ]
        Debug   int,"DMAInterrupt"

        ADD     r1, r1, r11                     ; r1->IOMD DMA register block

        PhysToDMAQ r9, r2                       ; r9->DMA queue
        LDR     r10, [r9, #dmaq_Active]         ; r10->active DMA request

        Debug   int," request",r10

        LDR     r8, [r10, #dmar_Flags]

        LDRB    r2, [r1, #IOMD_IOxST]           ; Get state.
        Debug   int," block,state =",r1,r2
 [ debugint
        LDRB    lr, [r1, #IOMD_IOxCR]
        Debug   int," control =",lr
 ]

        TST     r2, #IOMD_DMA_B_Bit
        ADDEQ   r3, r10, #dmar_BuffA            ; r3 -> active buffer info
        ADDNE   r3, r10, #dmar_BuffB
        ADDEQ   r4, r10, #dmar_BuffB            ; r4 -> inactive buffer info
        ADDNE   r4, r10, #dmar_BuffA
        ADDEQ   r6, r1, #IOMD_IOxCURA           ; r6 -> active buffer
        ADDNE   r6, r1, #IOMD_IOxCURB
        ADDEQ   r7, r1, #IOMD_IOxCURB           ; r7 -> inactive buffer
        ADDNE   r7, r1, #IOMD_IOxCURA

testloop
        DebugTab r0,lr,#&02,r2
        LDR     lr, [r9, #dmaq_LastBuff]
        TEQ     lr, r3                          ; If last buffer programmed was current active buffer then
        MOVEQ   r0, r4                          ;   update from inactive (completed) buffer.
        BLEQ    update

        Debug   int," status =",r2
        TST     r2, #IOMD_DMA_O_Bit             ; If not in overrun state then
        BEQ     %FT30                           ;   deal with interrupt only.

        Debug   int," overrun"

        MOV     r0, r3                          ; Update from active (overrun) buffer.
        BL      update

        LDR     r0, [r9, #dmaq_LastBuff]
        TEQ     r0, r3                          ; If active buffer not last programmed then
        BNE     %FT10                           ;   copy inactive.

        TST     r8, #dmarf_Infinite             ; If finite transfer
        LDREQ   r0, [r10, #dmar_Length]
        TEQEQ   r0, #0                          ;     and nothing left to program then
        BEQ     finished                        ;   finished.

        MOV     r5, r3                          ; Program active buffer.
        BL      program
        B       %FT20

10
        Debug   int," copy"
        DebugTab r0,lr,#&03

        TST     r8, #dmarf_Infinite             ; If finite transfer
        LDREQ   r0, [r4, #buff_Len]
        TEQEQ   r0, #0                          ;     and inactive buffer not programmed then
        BEQ     finished                        ;   must have finished.

        LDMIA   r7, {r0,lr}                     ; Copy inactive buffer to active buffer.
        STMIA   r6, {r0,lr}

        LDMIA   r4, {r0,r5,lr}                  ; Copy inactive info to active info.
        STMIA   r3, {r0,r5,lr}

20
 [ :LNOT: IOMD
        BIC     r2, r2, #IOMD_DMA_O_Bit
        STRB    r2, [r1, #IOMD_IOxST]
 ]
        MOV     r0, #0                          ; Mark inactive as not programmed.
        STR     r0, [r4, #buff_Len]
        STR     r3, [r9, #dmaq_LastBuff]        ; Active now last programmed.
        B       %FT40

30
        Debug   int," interrupt only"
        DebugTab r0,lr,#&04
        TST     r8, #dmarf_Infinite             ; If not infinite transfer
        LDREQ   r0, [r10, #dmar_Length]
        TEQEQ   r0, #0                          ;     and length = 0 then
        STREQ   r0, [r7, #4]                    ;   clear interrupt
        STREQ   r0, [r4, #buff_Len]             ;   and mark inactive as not programmed
        MOVNE   r5, r4                          ; else program inactive buffer.
        BLNE    program
 [ :LNOT: IOMD
        BIC     r2, r2, #IOMD_DMA_I_Bit
        STRB    r2, [r1, #IOMD_IOxST]
 ]
        STR     r4, [r9, #dmaq_LastBuff]        ; Inactive now last programmed.
40
        TST     r8, #dmarf_Sync
        BLNE    DMASync

        TST     r8, #dmarf_Halted               ; If transfer has halted due to an unsafe page then
        EXIT    NE                              ;   wait to be restarted by Service_PagesSafe.

        LDRB    r2, [r1, #IOMD_IOxST]           ; Get new state.
        TST     r2, #IOMD_DMA_I_Bit             ; If not in interrupt state then
 [ :LNOT: IOMD
        LDREQ   r2, [r10, #dmar_Tag]
        ANDEQ   r2, r2, #dmar_PhysBits
        MOVEQ   r3, #1
        LDREQB  r4, [r11, #IOMD_DMASTA]
        BICEQ   r4, r4, r3, LSL r2
        STREQB  r4, [r11, #IOMD_DMASTA]
 ]
 [ debugint
        BNE     %FT45
        Pull    "r3,lr"
        TEQP    pc, #IRQ_mode + I_bit
        NOP
        STRB    r3, [r11, #IOMD_DMAMSK]
        EXITS
45
 |
        EXITS   EQ                              ;   exit (give other IRQs a chance).
 ]

        TST     r2, #IOMD_DMA_B_Bit
        ADDEQ   r3, r10, #dmar_BuffA            ; r3 -> active buffer info
        ADDNE   r3, r10, #dmar_BuffB
        ADDEQ   r4, r10, #dmar_BuffB            ; r4 -> inactive buffer info
        ADDNE   r4, r10, #dmar_BuffA
        ADDEQ   r6, r1, #IOMD_IOxCURA           ; r6 -> active buffer
        ADDNE   r6, r1, #IOMD_IOxCURB
        ADDEQ   r7, r1, #IOMD_IOxCURB           ; r7 -> inactive buffer
        ADDNE   r7, r1, #IOMD_IOxCURA

        B       testloop

finished
; In:   r0 = 0
;       r1 = ptr to DMA register block
;       r8 = DMA request flags
;       r9 = ptr to DMA queue
;       r10 = ptr to DMA request block
;       r11 = IOMD base address
;
        Debug   int," finished"
        DebugTab r3,r4,#&05

        TST     r8, #dmarf_Sync                  ; Do any pending syncs.
        BLNE    DMASync

        LDRB    r2, [r1, #IOMD_IOxCR]           ; Disable DMA.
        BIC     r2, r2, #IOMD_DMA_E_Bit
        STRB    r2, [r1, #IOMD_IOxCR]

        ORR     r8, r8, #dmarf_Completed        ; Flag transfer as completed.
        STR     r8, [r10, #dmar_Flags]

        LDR     r8, [r10, #dmar_LCB]            ; r8->logical channel block
        MOV     r1, #1                          ; Disable physical channel interrupt.
        LDR     r2, [r8, #lcb_Physical]
 [ debugint
        LDR     lr, [sp]
 |
        LDRB    lr, [r11, #IOMD_DMAMSK]
 ]
        BIC     lr, lr, r1, LSL r2
 [ debugint
        STR     lr, [sp]
 |
        STRB    lr, [r11, #IOMD_DMAMSK]
 ]

; Go into SVC mode as we will be calling SWIs in this last bit. The completed
; transfer remains blocking the physical channel until DMASearchQueue so new
; transfers queued from an interrupt will not jump the queue.

        SwpPSR  r2, #SVC_mode + I_bit
        Push    lr

        Debug   dma,"DMAInterrupt - end of transfer"

        BL      DMACompleted                    ; r0=0 (successful)
        BL      DMAUnlinkRequest
        BL      DMAFreeRequestBlock
        BL      DMASearchQueue

        Pull    lr
        SetPSR  r2

 [ debugint
        Pull    "r3,lr"
        TEQP    pc, #IRQ_mode + I_bit
        NOP
        STRB    r3, [r11, #IOMD_DMAMSK]
 ]

 [ debugtab
        PullEnv
        DebugTab r0,r1,#&06,sp,lr
        MOVS    pc, lr
 |
        EXITS
 ]

update
; In:   r0 = buffer to update from
;       r8 = DMA request flags
;       r10 = ptr to DMA request block
;
        ENTRY   "r0-r2"

        LDR     r2, [r0, #buff_Len]             ; Get amount done.
        Debug   int," update by",r2
        DebugTab r1,lr,#&11,r2
        TEQ     r2, #0                          ; If buffer not programmed then
        EXIT    EQ                              ;   nothing to update.

        LDR     lr, [r10, #dmar_Done]           ; Update amount done.
        ADD     lr, lr, r2
        STR     lr, [r10, #dmar_Done]

        TST     r8, #dmarf_Sync                 ; If doing sync callbacks then
        LDRNE   lr, [r10, #dmar_Gap]            ;   update gap.
        ADDNE   lr, lr, r2
        STRNE   lr, [r10, #dmar_Gap]

        TST     r8, #dmarf_Circular             ; If circular then
        EXIT    NE                              ;   don't update scatter list.

        LDR     lr, [r10, #dmar_ScatterList]
10
        LDMIA   lr, {r0,r1}                     ; Get scatter list addr,len.
        TEQ     r1, #0                          ; If zero length entry then
        ADDEQ   lr, lr, #8                      ;   move on to next section.
        STREQ   lr, [r10, #dmar_ScatterList]
        BEQ     %BT10

        ADD     r0, r0, r2                      ; Update addr and len by amount done.
        SUB     r1, r1, r2
        STMIA   lr, {r0,r1}
        DebugTab r2,lr,#&12,r0,r1

        EXIT 


program ROUT
; In:   r0 = length to do
;       r1 = ptr to DMA register block
;       r3 = ptr to active buffer info
;       r4 = ptr to inactive info
;       r5 = buffer to program
;       r6 = ptr to active buffer
;       r7 = ptr to inactive buffer
;       r8 = DMA request flags
;       r9 = ptr to DMA queue
;       r10 = ptr to DMA request block
;
        ENTRY   "r2,r3,r11"

        Debug   int," program"
        DebugTab r2,lr,#&21,r3,r5

        TST     r8, #dmarf_Circular             ; If not circular buffer then
        BEQ     %FT10                           ;   don't wrap.

        LDR     lr, [r10, #dmar_BuffLen]
        Debug   int," bufflen =",lr
        TEQ     lr, #0                          ; If no buffer left to do then
        LDREQ   r2, [r10, #dmar_PageTable]      ;   page table wraps,
        MOVEQ   r3, #0                          ;   r3 = new offset = 0,
        LDREQ   lr, [r10, #dmar_BuffSize]       ;   whole buffer left to do.
        STREQ   lr, [r10, #dmar_BuffLen]
        BEQ     %FT20

10
        LDMIA   r3, {r2,r3,r11}                 ; Get active buffer ptp, off, len.
        ADD     r3, r3, r11                     ; r3 = amount programmed so far (new offset)
        LDR     lr, [r2, #ptab_Len]             ; Get page table entry length.

        TEQ     r3, lr                          ; If entry has completed
        MOVEQ   r3, #0                          ;   r3 = new offset = 0
        ADDEQ   r2, r2, #PTABSize               ;   and move on page table pointer.
20
        LDREQ   lr, [r2, #ptab_Len]             ; Get page table entry length.

        TST     lr, #ptabf_Unsafe               ; If we have reached an unsafe page then
        BNE     halt                            ;   the transfer must be halted until the page is safe.

        SUB     r11, lr, r3                     ; r11 = new len = page table entry len - new off

        TST     r8, #dmarf_Infinite             ; If infinite then
        BNE     %FT40                           ;   don't test against length.
        CMP     r0, r11                         ; If Length < new len then
        MOVCC   r11, r0                         ;   new len = Length
40
        TST     r8, #dmarf_Circular             ; If not circular then
        BEQ     %FT50                           ;   don't test against BuffLen.
        LDR     lr, [r10, #dmar_BuffLen]
        CMP     lr, r11                         ; If BuffLen < new len then
        MOVCC   r11, lr                         ;   new len = BuffLen
50
        TST     r8, #dmarf_Sync                 ; If not doing sync callbacks then
        BEQ     %FT60                           ;   don't test against ProgGap.
        LDR     lr, [r10, #dmar_ProgGap]
        CMP     r11, lr                         ; If ProgGap <= new len then
        MOVCS   r11, lr                         ;   new len = ProgGap,
        LDRCS   lr, [r10, #dmar_SyncGap]        ;   ProgGap = SyncGap
        SUBCC   lr, lr, r11                     ; else ProgGap -= new len.
        STR     lr, [r10, #dmar_ProgGap]
60
        Debug   int," off,len =",r3,r11
        STMIA   r5, {r2,r3,r11}                 ; Store buffer info.

        LDR     r2, [r2, #ptab_Physical]        ; Get physical address from page table.
        ADD     r2, r2, r3                      ; r2 = start address
        ADD     r3, r2, r11                     ; r3 = end address
        BIC     r3, r3, #IOMD_DMA_S_Bit + IOMD_DMA_L_Bit

        LDRB    lr, [r1, #IOMD_IOxCR]           ; Get transfer unit size.
        AND     lr, lr, #IOMD_DMA_IncMask
        SUB     r3, r3, lr                      ; Set real end address.
        TEQ     r11, lr                         ; If length of transfer = transfer unit size then
        ORREQ   r3, r3, #IOMD_DMA_L_Bit         ;   set Last bit.

        TST     r8, #dmarf_Infinite             ; If infinite then
        BNE     %FT80                           ;   just program buffer.

        SUBS    r0, r0, r11                     ; If adjusted length to do = 0 then
        ORREQ   r3, r3, #IOMD_DMA_S_Bit         ;   set Stop bit.
        STR     r0, [r10, #dmar_Length]
80
        TEQ     r5, r4                          ; Program buffer.
        STMEQIA r7, {r2,r3}
        STMNEIA r6, {r2,r3}

        TST     r8, #dmarf_Circular             ; Adjust BuffLen if necessary.
        LDRNE   lr, [r10, #dmar_BuffLen]
        SUBNE   lr, lr, r11
        STRNE   lr, [r10, #dmar_BuffLen]

        DebugTab r2,lr,#&22
        EXIT

halt
        Debug   int," halt"
        MOV     r11, #0
        STMIA   r5, {r2,r3,r11}                 ; Set up new ptp, new offset and 0 length for the transfer to continue.
        IOMDBase r11
 [ debugint
        LDR     lr, [sp, #12]
 |
        LDRB    lr, [r11, #IOMD_DMAMSK]         ; Disable channel interrupt.
 ]
        LDR     r2, [r10, #dmar_Tag]
        AND     r2, r2, #dmar_PhysBits
        MOV     r3, #1
        BIC     lr, lr, r3, LSL r2
 [ debugint
        STR     lr, [sp, #12]
 |
        STRB    lr, [r11, #IOMD_DMAMSK]
 ]
        ORR     r8, r8, #dmarf_Halted           ; Flag transfer as halted.
        STR     r8, [r10, #dmar_Flags]

        EXIT

        END
