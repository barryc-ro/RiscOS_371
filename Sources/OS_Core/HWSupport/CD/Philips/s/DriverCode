; DriverCode.s




;     NEVER CHANGE R7 or R11









; This carries out the CD_ SWI commands for the Philips CDD521 writer
















 

;-----------------------------------------------------------------------------------------------
driver_handler_code ROUT
;
; on entry:
;          r0  - r6= Whatever values the various CD_ SWIs use
;          r7 -> control block
;                control block + 0   = SCSI device id (0-7)
;                control block + 4   = SCSI card number (0-3 usually 0)
;                control block + 8   = Logical Unit Number (0-7 usually 0)
;                control block + 12  = Drive type for this module
;          r11 = the number of the CD_ SWI, ie/ 0 = CD_ReadData, 1 = CD_SeekTo etc;
;          r12 -> workspace for this module
;          r13 -> a full descending stack, approx. 1024 bytes
;          r14 = address to return to
; on exit:
;          r0 must be preserved or be return value for the particular SWI
;          r1 - r12 & r14 corrupted
;-----------------------------------------------------------------------------------------------

;--------------------
; Special tag
;--------------------
 DCD       &EE50EE50   ; EESOX EESOX

;--------------------
; Code
;--------------------

 STASH     "r0, r14"


 DebugDisplay r11
 Debug "   "

;----------------------------------------------------------
; Branch to the correct piece of code to handle the command
; The two top bits of R11 (SWIN) are used to indicate the
; number of retries
;----------------------------------------------------------
 BIC       r14, SWIN, #3:SHL:30
 ADR       r10, jump_table_start
 LDR       r14, [ r10, r14, LSL #1 ]
 MOV       r14, r14, LSL #16
 ADD       pc, pc, r14, LSR #16


jump_table_start
 DCW notsupported    - jump_table_start - 4      ;  0   OK  ReadData
 DCW SeekTo          - jump_table_start - 4      ;  1   OK
 DCW notsupported    - jump_table_start - 4      ;  2   OK  DriveStatus
 DCW notsupported    - jump_table_start - 4      ;  3   OK  DriveReady
 DCW GetParameters   - jump_table_start - 4      ;  4   OK
 DCW SetParameters   - jump_table_start - 4      ;  5   OK
 DCW OpenDrawer      - jump_table_start - 4      ;  6   OK  
 DCW EjectButton     - jump_table_start - 4      ;  7   OK
 DCW EnquireAddress  - jump_table_start - 4      ;  8   OK
 DCW EnquireDataMode - jump_table_start - 4      ;  9   OK
 DCW PlayAudio       - jump_table_start - 4      ; 10   OK
 DCW PlayTrack       - jump_table_start - 4      ; 11   OK
 DCW AudioPause      - jump_table_start - 4      ; 12   OK
 DCW EnquireTrack    - jump_table_start - 4      ; 13   OK
 DCW ReadSubChannel  - jump_table_start - 4      ; 14   OK
 DCW notsupported    - jump_table_start - 4      ; 15   OK  CheckDrive
 DCW DiscChanged     - jump_table_start - 4      ; 16   OK
 DCW StopDisc        - jump_table_start - 4      ; 17   OK  
 DCW DiscUsed        - jump_table_start - 4      ; 18   OK  
 DCW AudioStatus     - jump_table_start - 4      ; 19   OK
 DCW notsupported    - jump_table_start - 4      ; 20   OK  Inquiry
 DCW DiscHasChanged  - jump_table_start - 4      ; 21   OK
 DCW notsupported    - jump_table_start - 4      ; 22   OK  Control
 DCW Supported       - jump_table_start - 4      ; 23   OK
 DCW notsupported    - jump_table_start - 4      ; 24   OK  Prefetch
 DCW notsupported    - jump_table_start - 4      ; 25   OK  Reset
 DCW CloseDrawer     - jump_table_start - 4      ; 26   OK  
 DCW IsDrawerLocked  - jump_table_start - 4      ; 27   OK
 DCW AudioControl    - jump_table_start - 4      ; 28   OK  
 DCW notsupported    - jump_table_start - 4      ; 29   OK  AudioLevel
 DCW Identify        - jump_table_start - 4      ; 30 should identify CDD521 or CM212

 ALIGN

notsupported
 ADR       r0, not_supported_error
 B         error_handler_lookup


;-----------------------------------------------------------------------------------------------
;ReadData ROUT
;
; on entry:
;          r0 =   addressing mode
;          r1 =   block number
;          r2 =   number of blocks
;          r3 ->  where to put data
;          r4 =   number of bytes from each block wanted
;          r7 ->  control block
;          r12 -> my workspace
;          r13 -> full descending stack
; on exit:
;          if error then r0-> error block, else all regs preserved
;
;-----------------------------------------------------------------------------------------------

; This is never called - the CDFSDriver internal routine is used instead

;-----------------------------------------------------------------------------------------------
SeekTo ROUT
;
; on entry:
;          r0 = addressing mode
;          r1 = address to seek to
; on exit:
;          if error then r0-> error block, else all regs preserved
;
;-----------------------------------------------------------------------------------------------

 STR       r8, [ r12 ]

;---------------------
; Set up the cdb block
;---------------------
 LDR       r10, [ r7, #LUNoffset ]
 MOV       r4, #&2b
 ORR       r4, r4, r10, LSL #8+5
 MOV       r5, #0
 MOV       r6, #0
 ADR       r2, buffer
 STMIA     r2, { r4, r5, r6 }



; R0 = address mode, R1 = address, RETURNS R1 = address

 SWI       XCD_ConvertToLBA

;------------------
; put in start pos
;------------------
 MOV       r6, r1
 BLVC      save_seek_details

;--------------------
; Do the SCSI command
;--------------------
 BLVC      space_saver

; r1 = size of cdb
 MOVVC     r1, #10

; r2 -> cdb

; r4 = number of bytes returned
 MOVVC     r4, #0

 SWIVC     XSCSI_Op

 BVS       error_handler

;-------------------------------------------------------------------------------
; The CM212 must be slowed down to give readsubchannel etc; the correct address
;-------------------------------------------------------------------------------

 LDR       r8, [ r12 ]
 
 TEQ       r8, #PHILIPS_521
 GRABS     "r0, pc", EQ


;---------------------
; Pause for a bit
;---------------------
 SWI       XOS_ReadMonotonicTime
 MOV       r1, r0

01
 SWI       XOS_ReadMonotonicTime
 SUB       r0, r0, r1
 CMP       r0, #40
 BLT       %BT01

 GRABS     "r0, pc"

;-----------------------------------------------------------------------------------------------
;DriveStatus ROUT
;
; on entry:
;          r7 -> control block
; on exit:
;          r0 = status { 1=OK, 2=BUSY, 4=NOTREADY, 8=UNAVAILABLE }
;-----------------------------------------------------------------------------------------------

; This is never called - the CDFSDriver internal routine is used instead

;-----------------------------------------------------------------------------------------------
;DriveReady ROUT
;
; on entry:
;          r7 -> control block
; on exit:
;          r0 = 0 if drive is OK, else r0 = 1
;
;-----------------------------------------------------------------------------------------------

; This is never called - the CDFSDriver internal routine is used instead

;-----------------------------------------------------------------------------------------------
GetParameters ROUT
;
; on entry:
;          r0 -> parameter block
;          r7 -> control block
; on exit:
;          usual error stuff
;-----------------------------------------------------------------------------------------------


 MOV       r6, #1

set_parameters_jumps_in_here

 STASH     r0

;--------------------------------
; SCSI ModeSense command
;--------------------------------

 BL        space_saver

 ORR       r0, r0, #escapepolloff + readdata   ; prevent 'escape key'

 MOV       r3, #&1a
 ORR       r3, r3, r10, LSL #8+5
 ORR       r3, r3, #&3f:SHL:16
 MOV       r4, #54
 STMIA     r2, { r3, r4 }

 ADR       r3, buffer + 16

 SWI       XSCSI_Op

 GRAB      r4

 BVS       error_handler


 TEQ       r6, #0
 BEQ       set_parameters_back


;-------------------------------
; Pick out the data to return it
;-------------------------------

; Inactivity timer multiplier PHILIPS is not settable !
 MOV       r1, #0


; read retry count OK
 LDRB      r3, buffer + 16 + 12 + 3

;-----------------------------------
; Work out data mode from block size
;-----------------------------------
 LDR       r5, buffer + 16 + 4 + 4
 TEQ       r5, #mode1datasizeHBLB
 MOVEQ     r5, #1
 MOVNE     r5, #2

;-----------------------------------

; Speed selector must be 0
 MOV       r6, #0


 STMIA     r4, { r1, r3, r5, r6 }

;-------------------------------

 GRABS     "r0, pc"

;-----------------------------------------------------------------------------------------------
SetParameters ROUT
;
; on entry:
;          r0 -> parameter block
;          r7 -> control block
; on exit:
;          usual error stuff
;-----------------------------------------------------------------------------------------------

; RESERVED word
 LDR       r6, [ r0, #12 ]
 TEQ       r6, #0
 BNE       invalidparameter

 B         set_parameters_jumps_in_here

set_parameters_back

; r4 -> parameter block


;---------------------------------------------
; Remove other crap not needed for MODE SELECT
;---------------------------------------------

 STRB      r6, buffer + 16 + 0         ; Sense data length
 STRB      r6, buffer + 16 + 2         ; Write protect bit


;-----------------------
; Mode 1 or 2 data ?
;-----------------------

 LDR       r0, [ r4, #8 ]

 TEQ       r0, #1
 MOVEQ     r1, #mode1datasizeHBLB
 LDRNE     r1, =mode2datasizeHBLB

 STR       r1, buffer + 16 + 4 + 4


;--------------------------------
; SCSI ModeSelect command
;--------------------------------

 BL        space_saver

 ORR       r0, r0, #escapepolloff + writedata   ; prevent 'escape key'

 MOV       r3, #&15
 ORR       r3, r3, r10, LSL #8+5
 MOV       r4, #&c
 STMIA     r2, { r3, r4 }

 ADR       r3, buffer + 16

 SWI       XSCSI_Op

 BVS       error_handler


 GRABS     "r0, pc"

;-----------------------------------------------------------------------------------------------
OpenDrawer ROUT
;
; on entry:
;          r7 -> control block
; on exit:
;          usual error stuff
;-----------------------------------------------------------------------------------------------

; Open the drawer
 MOV       r6, #1

close_drawer_jumps_in_here

;--------------------------------------
; This is only supported for the CDD521
;--------------------------------------
 TEQ       r8, #PHILIPS_521
 BNE       notsupported

;--------------------------------
; SCSI OpenDrawer command
;--------------------------------
 BL        space_saver

 MOV       r3, #&e7
 ORR       r3, r3, r10, LSL #8+5
 MOV       r4, #0
 STMIA     r2, { r3, r4, r6 }

 MOV       r1, #10

 SWI       XSCSI_Op

 GRABS     "r0, pc", VC

;----------------------------------------
; If it's a hardware error then ignore it
;----------------------------------------

 LDR       r1, [ r0 ]
 LDR       r2, =HardwareError
 TEQ       r1, r2
 GRABS     "r0, pc", EQ

 B         error_handler


;-----------------------------------------------------------------------------------------------
EjectButton ROUT
;
; on entry:
;          r0 = 0 to allow eject, 1 to prevent
;          r7 -> control block
; on exit:
;          usual error stuff
;-----------------------------------------------------------------------------------------------

;--------------------------------------
; This is only supported for the CDD521
;--------------------------------------
 TEQ       r8, #PHILIPS_521
 BNE       %FT01

;-----------------------
; Check for valid switch
;-----------------------
 CMP       r0, #2
 BCS       invalidparameter

;-----------------------


 MOV       r6, r0

;--------------------------------
; SCSI Prevent/allow command
;--------------------------------

 BL        space_saver

 MOV       r4, #&1e
 ORR       r4, r4, r10, LSL #8+5
 STMIA     r2, { r4, r6 }

 MOV       r4, #8

 SWI       XSCSI_Op

 BVS       error_handler

 MOV       r0, r6
01
 BL        SetDrawerStatus

 GRABS     "r0, pc"

;-----------------------------------------------------------------------------------------------
EnquireAddress ROUT
;
; on entry:
;          r0 = addressing mode for returned data
;          r7 -> control block
; on exit:
;          usual error stuff
;          r0 = current laser position
;-----------------------------------------------------------------------------------------------

;--------------------------------------
; This is only supported for the CM212
;--------------------------------------
 TEQ       r8, #PHILIPS_521
 MOVEQ     r0, #0
 GRABS     "r1, pc", EQ

;--------------------------------
; SCSI ReadSubChannel command
;--------------------------------

 MOV       r6, r0

 BL        space_saver

 ORR       r0, r0, #escapepolloff + readdata   ; prevent 'escape key'

 MOV       r1, #&ea
 ORR       r1, r1, r10, LSL #8+5
 MOV       r4, #5
 STMIA     r2, { r1, r3, r4 }

 MOV       r1, #10

 ADR       r3, buffer + 16 + 3

 SWI       XSCSI_Op

 BVS       error_handler


;--------------------------
; Read the current address
;--------------------------
 LDR       r1, buffer + 16 + 4
 MOV       r5, #&ff00
 ORR       r5, r5, r5, LSL #16
 AND       r4, r5, r1, ROR #8
 AND       r3, r5, r1
 ORR       r1, r4, r3, ROR #24

;---------------------------------------
; If caller wants return in MSF then ...
;---------------------------------------
 TEQ       r6, #MSFFormat

 MOVEQ     r0, #LBAFormat
 SWIEQ     XCD_ConvertToMSF

 BVS       error_handler

;---------------------------------------
; If caller wants return in LBA format
;---------------------------------------
 TEQ       r6, #LBAFormat
 SUBEQ     r1, r1, #( MaxNumberOfBlocks + 1 ) * 2

 MOV       r0, r1

 GRABS     "r1, pc"


;-----------------------------------------------------------------------------------------------
EnquireDataMode ROUT
;
; on entry:
;          r0 = addressing mode for block
;          r1 = block
;          r7 -> control block
; on exit:
;          usual error stuff
;          r0 = addressing mode (1 for mode 1, 2 for mode 2, 3 for mode 2 form 1)
;-----------------------------------------------------------------------------------------------

; Store entry parameters
 STMIA     r12, { r0, r1 }

; Make a real control block for SWIs
 LDMIA     r7, { r2, r3, r4 }
 ADR       r7, temp_control_block
 STMIA     r7, { r2, r3, r4, r8 }

;--------------------------------
; Change to mode 1
;--------------------------------
 ADR       r0, mode_1_block
 SWI       XCD_SetParameters
 BVS       error_handler

;--------------------------------
; Read data
;--------------------------------
 LDMIA     r12, { r0, r1 }
 MOV       r2, #1
 ADR       r3, buffer + 100
 MOV       r4, #1
 SWI       XCD_ReadData

;--------------------------------
; If no error then must be mode 1
;--------------------------------
 MOVVC     r0, #1
 GRABS     "r1, pc", VC

;--------------------------------
; Change to mode 2
;--------------------------------
 ADR       r0, mode_2_block
 SWI       XCD_SetParameters
 BVS       error_handler

;--------------------------------
; Read data
;--------------------------------
 LDMIA     r12, { r0, r1 }
 MOV       r2, #1
 ADR       r3, buffer + 100
 MOV       r4, #1
 SWI       XCD_ReadData

;--------------------------------
; If no error must be mode 2
;--------------------------------
 MOVVC     r0, #2
 GRABS     "r1, pc", VC

;--------------------------------
; Must be mode 0 - audio
;--------------------------------
 MOV       r0, #0

 GRABS     "r1, pc"

mode_1_block
 DCD 0
 DCD 3
 DCD 1
 DCD 0

mode_2_block
 DCD 0
 DCD 3
 DCD 2
 DCD 0

;-----------------------------------------------------------------------------------------------
PlayAudio ROUT
;
; on entry:
;          r0 = addressing mode for returned data
;          r1 = start address
;          r2 = end address
;          r7 -> control block
; on exit:
;          usual error stuff
;-----------------------------------------------------------------------------------------------

;---------------------------
; The CDD521 cannot do this
;---------------------------
 TEQ       r8, #PHILIPS_521
 BEQ       notsupported



;------------------------------------------------------
; Make sure that start and end address is in LBA format
;------------------------------------------------------

 SWI       XCD_ConvertToLBA

 ADDVC     r6, r1, #(MaxNumberOfBlocks + 1) * 2

 MOVVC     r1, r2

 SWIVC     XCD_ConvertToLBA

 BVS       error_handler


;-----------------------------
; If end <= start THEN error !
;-----------------------------
; r6 = start address, r1 = end address
 SUBS      r1, r1, r6
 BCC       invalidparameter

;-----------------------------
; Put in audio control
;-----------------------------

; RETURNS R0 = 0 to 3, R7 -> control block
 BL        GetStereoStatus

 MOV       r4, #&e8
 STR       r4, buffer + 8         ; clear byte 9
 LDR       r10, [ r7, #LUNoffset ]
 ORR       r4, r4, r10, LSL #8+5
 ORR       r4, r4, r0, LSL #3+8
 STR       r4, buffer

;-----------------------------
; Save start address + 150
;-----------------------------
 BL        save_seek_details

;-----------------------------
; Save length of play
;-----------------------------
 STRB      r1, buffer + 8    ; LSB
 MOV       r1, r1, LSR #8
 STRB      r1, buffer + 7    ; ISB
 MOV       r1, r1, LSR #8
 STRB      r1, buffer + 6    ; MSB


;--------------------------------
; Philips SCSI PlayAudio command
;--------------------------------
 BL        space_saver

 MOV       r4, #0

 MOV       r1, #10

 SWI       XSCSI_Op

 BVS       error_handler


 GRABS     "r0, pc"

;-----------------------------------------------------------------------------------------------
PlayTrack ROUT
;
; on entry:
;          r0 = track number
;          r1 = &ff end of disc, &fe play to end of track
;          r7 -> control block
; on exit:
;          usual error stuff
;-----------------------------------------------------------------------------------------------

;---------------------------
; The CDD521 cannot do this
;---------------------------
 TEQ       r8, #PHILIPS_521
 BEQ       notsupported


;-----------------------
; Check track is 1 to 99
;-----------------------
 ADD       r14, r0, #1
 CMP       r14, #101
 BCS       invalidparameter

 MOV       r6, r0

;-----------------------
; Put in audio control
;-----------------------

 BL        GetStereoStatus

 STR       r0, [ r12 ]
     
;---------------------------------------------------------------
; IF R1 = &FF then play to end of disc ELSE play to end of track
;---------------------------------------------------------------

 TEQ       r1, #&FF

;--------------------------------
; Philips SCSI PlayTrack command
;--------------------------------
; r6 = track number
 BL        space_saver

 MOV       r4, #0
 MOV       r1, #&e9
 ORR       r1, r1, r10, LSL #8+5
 ORREQ     r1, r1, #2:SHL:8
 LDR       r14, [ r12 ]
 ORR       r1, r1, r14, LSL #8+3
 STMIA     r2, { r1, r4, r6 }

 MOV       r1, #10

 SWI       XSCSI_Op

 GRABS     "r0, pc", VC

;---------------------------------------------------
; If the error is illegal request then nosuchtrack
;---------------------------------------------------
 LDR       r1, [ r0 ]
 LDR       r2, =IllegalRequest
 TEQ       r1, r2
 BEQ       nosuchtrack
 B         error_handler

;-----------------------------------------------------------------------------------------------
AudioPause ROUT
;
; on entry:
;          r0 = 0 to resume, 1 to pause
;          r7 -> control block
; on exit:
;          usual error stuff
;-----------------------------------------------------------------------------------------------

;---------------------------
; The CDD521 cannot do this
;---------------------------
 TEQ       r8, #PHILIPS_521
 BEQ       notsupported


 LDMIA     r7, { r2, r3, r4 }
 ADR       r7, temp_control_block
 STMIA     r7, { r2, r3, r4, r8 }

;----------------------------
; Make sure that r0 = 0 to 1
;----------------------------
 CMP       r0, #2
 BCS       invalidparameter

;----------------------------

 EORS      r6, r0, #1
 BNE       %FT01

;--------------------------------
; SCSI Pause on
;--------------------------------

 BL        space_saver

 MOV       r1, #&ed
 ORR       r1, r1, r10, LSL #8+5
 MOV       r4, #0
 STMIA     r2, { r1, r5, r6 }

 MOV       r1, #10

 SWI       XSCSI_Op

 BVS       error_handler


 MOV       r0, #1
 BL        SetPauseStatus

 GRABS     "r0, pc"

;--------------------------------------------------------------------
; If pause off was wanted then play from here to the end of the disc
;--------------------------------------------------------------------
01
 MOV       r0, #LBAFormat
 ADR       r1, buffer + 100
 SWI       XCD_DiscUsed

 SWIVC     XCD_EnquireAddress

 MOVVC     r1, r0
 LDRVC     r2, buffer + 100
 MOVVC     r0, #LBAFormat
 SWIVC     XCD_PlayAudio
 BVS       error_handler

 MOV       r0, #0
 BL        SetPauseStatus

 GRABS     "r0, pc"

;-----------------------------------------------------------------------------------------------
EnquireTrack ROUT
;
; on entry:
;          r0 = 0 start/end track, 1 to 99 info on that track
;          r1 -> storage area
;          r7 -> control block
; on exit:
;          usual error stuff
;-----------------------------------------------------------------------------------------------

 STMIA     r12, { r0, r1, r8 }

;----------------------------
; Make sure that r0 = 0 to 99
;----------------------------
 CMP       r0, #100
 BCS       invalidparameter

;----------------------------------------------
; Was only info on start / end track required ?
;----------------------------------------------

 MOVS      r6, r0

;--------------------------------
; SCSI ReadTOC
;--------------------------------

 BL        space_saver

 ORR       r0, r0, #escapepolloff + readdata

 MOV       r1, #&e5
 ORR       r1, r1, r10, LSL #8+5
 MOV       r4, #11
 MOVNE     r3, r6, LSL #8
 MOVEQ     r3, #1:SHL:8
 STMIA     r2, { r1, r3, r4 }

 ADR       r3, buffer + 16

 MOV       r1, #10

 SWI       XSCSI_Op

;---------------------------------------------
; If illegal request then track does not exist
;---------------------------------------------
 BVC       %FT01

 LDR       r1, [ r0 ]
 LDR       r2, =IllegalRequest
 TEQ       r1, r2
 BEQ       nosuchtrack
 B         error_handler

01
 LDMIA     r12, { r0, r1, r8 }

;------------------------------------------
; Was only the start and end track wanted ?
;------------------------------------------

 TEQ       r0, #0
 BNE       %FT02

 MOV       r3, #1
 LDRB      r14, buffer + 16 + 1

; Philips 212 needs converting from BCD
 TEQ       r8, #PHILIPS_212
 ConvertBCDToNormal r14, r2, EQ

 TEQ       r0, #0

;-----------------------------------------
; Give the start address ( in LBA format )
;-----------------------------------------
02
 LDRNEB    r3, buffer + 16 + 5        ; LSB
 STRB      r3, [ r1, #0 ]
 LDRNEB    r14, buffer + 16 + 4       ; LISB
 STRB      r14, [ r1, #1 ]
 LDRNEB    r14, buffer + 16 + 3       ; UISB
 STRNEB    r14, [ r1, #2 ]
 LDRNEB    r14, buffer + 16 + 2       ; MSB
 STRNEB    r14, [ r1, #3 ]

;--------------
; Control bits
;--------------
 LDRNEB    r14, buffer + 16 + 10
 MOVNE     r14, r14, LSR #2
 ANDNE     r14, r14, #3
 STRNEB    r14, [ r1, #4 ]


 GRABS     "r0, pc"

;-----------------------------------------------------------------------------------------------
ReadSubChannel ROUT
;
; on entry:
;          r0 = sub-channel = 64
;          r1 -> storage area
;          r7 -> control block
; on exit:
;          usual error stuff
;-----------------------------------------------------------------------------------------------

 TEQ       r0, #64
 addr      r0, channel_not_supported_error, NE
 BNE       error_handler_lookup


;---------------------------
; The CDD521 cannot do this
;---------------------------
 TEQ       r8, #PHILIPS_521
 MOVEQ     r6, #2
 BEQ       readsubchannel_jumps_in_here

;--------------------------------
; SCSI ReadSubChannel
;--------------------------------

 MOV       r6, r1

 BL        space_saver

 ORR       r0, r0, #escapepolloff + readdata

 MOV       r1, #&42
 ORR       r1, r1, r10, LSL #8+5
 ORR       r1, r1, #(2:SHL:8)
 ORR       r1, r1, #(64:SHL:16)
 MOV       r4, #33
 STMIA     r2, { r1, r3, r4 }

 ADR       r3, buffer + 16

 MOV       r1, #10

 SWI       XSCSI_Op

 BVS       error_handler


;-------------------------
; Extract the correct bits
;-------------------------
; word + 0  = relative
; word + 4  = absolute
; byte + 8  = control bits
; byte + 9  = track number
; byte + 10 = index number

; r6 -> storage area

 ADR       r14, buffer + 16 + 8
 LDMIA     r14, { r2, r8 }

 MOV       r5, #&ff00
 ORR       r5, r5, r5, LSL #16

 AND       r4, r5, r8, ROR #8
 AND       r3, r5, r8
 ORR       r1, r4, r3, ROR #24

 AND       r4, r5, r2, ROR #8
 AND       r3, r5, r2
 ORR       r2, r4, r3, ROR #24

; r1 = relative MSF
 MOV       r0, #MSFFormat
 SWI       XCD_ConvertToLBA
 STRVC     r1, [ r6, #0 ]

; r2 = absolute MSF
 MOVVC     r1, r2
 SWIVC     XCD_ConvertToLBA
 STRVC     r1, [ r6, #4 ]

 BVS       error_handler

; Control bits
 LDRB      r14, buffer + 16 + 5
 MOV       r14, r14, LSR #2
 STRB      r14, [ r6, #8 ]

; Track number
 LDRB      r14, buffer + 16 + 6
 STRB      r14, [ r6, #9 ]

; Index number
 LDRB      r14, buffer + 16 + 7
 STRB      r14, [ r6, #10 ]


 GRABS     "r0, pc"

;-----------------------------------------------------------------------------------------------
;CheckDrive ROUT
;
; on entry:
;          r7 -> control block
; on exit:
;          usual error stuff
;          r0 = drive status bits
;-----------------------------------------------------------------------------------------------

; This is never called - the CDFSDriver internal routine is used instead

;-----------------------------------------------------------------------------------------------
DiscChanged ROUT
;
; on entry:
;          r7 -> control block
; on exit:
;          usual error stuff
;          r0 = 0 if not changed, 1 if changed
;-----------------------------------------------------------------------------------------------

 MOV       r6, #0

drawer_status_jumps_in_here
readsubchannel_jumps_in_here

;--------------------------------
; SCSI EnquireAddress command
;--------------------------------

 STASH     r1

 BL        space_saver

 MOV       r4, r10, LSL #8+5
 STMIA     r2, { r4, r5 }

 MOV       r4, #0

 SWI       XSCSI_Op

 GRAB      r4

; Error
 BVS       error_handler

; No error

; Disc changed ?
 TEQ       r6, #0
 BLEQ      HasDiscChanged

; Get drawer status ?
 TEQ       r6, #1
 BLEQ      GetDrawerStatus

; read sub-channel for CDD521 ?
 TEQ       r6, #2
 MOVEQ     r0, #0
 MOVEQ     r1, #0
 STMEQIA   r4, { r0, r1 }
 STREQB    r0, [ r4, #8 ]
 STREQB    r0, [ r4, #9 ]
 STREQB    r0, [ r4, #10 ]

 GRABS     "r1, pc"

;-----------------------------------------------------------------------------------------------
StopDisc ROUT
;
; on entry:
;          r7 -> control block
; on exit:
;          usual error stuff
;-----------------------------------------------------------------------------------------------

;--------------------------------
; SCSI Stop disc command
;--------------------------------
 BL        space_saver

 MOV       r4, #&1b
 ORR       r4, r4, r10, LSL #8+5
 STMIA     r2, { r4, r5 }

 MOV       r4, #0

 SWI       XSCSI_Op

 BVS       error_handler

 GRABS     "r0, pc"

;-----------------------------------------------------------------------------------------------
DiscUsed ROUT
;
; on entry:
;          r0 =  addressing mode that the disc length should be returned in
;          r1 -> storage area to put data in
;          r7 -> control block
; on exit:
;
;-----------------------------------------------------------------------------------------------

 [ Version > 100
 ; This loads the sub-type from the passed in parameter block
 LDR       r14, [ r7, #drivetypeoffset ]
 TEQ       r14, #PHILIPS_212
 |
 ; This is a bug, r8 = the caller's drive type, not the sub-type
 TEQ       r8, #PHILIPS_212
 ]

;---------------------------------------
; SCSI command to read number of tracks
;---------------------------------------

 STASH     "r0-r1"

 BL        space_saver

 ORR       r0, r0, #escapepolloff + readdata   ; prevent 'escape key'

 MOVNE     r1, #&43
 MOVEQ     r1, #&25
 ORR       r1, r1, r10, LSL #8+5
 MOVNE     r3, #&aa:SHL:16
 MOV       r4, #12
 STMNEIA   r2, { r1, r3, r4 }
 STMEQIA   r2, { r1, r3, r5 }

 MOV       r1, #10

 ADR       r3, buffer + 16

 SWI       XSCSI_Op

 GRAB      "r5-r6"

 BVS       error_handler

 BEQ       %FT01

;----------------------------------
; Get the last Logical Block Number
;----------------------------------
 LDRB      r4, buffer + 16 + 4 + 5 ; MSB
 LDRB      r3, buffer + 16 + 4 + 6
 LDRB      r2, buffer + 16 + 4 + 7 ; LSB
 ORR       r2, r2, r3, LSL #8
 ORR       r1, r2, r4, LSL #16

 MOV       r7, #2048

 STR       r7, [ r6, #4 ]

 TEQ       r5, #LBAFormat
 ADDNE     r1, r1, #( MaxNumberOfBlocks + 1 ) * 2 + 1

 TEQ       r5, #MSFFormat
 STRNE     r1, [ r6, #0 ]
 GRABS     "r0, pc", NE

;-------------------------
; Convert from LBA to MSF
;-------------------------

 MOV       r0, #LBAFormat

 SWI       XCD_ConvertToMSF
 BVS       error_handler

 STR       r1, [ r6, #0 ]

 GRABS     "r0, pc"


01

 MOV       r0, r5
 MOV       r1, r6

 ADR       r5, buffer + 16
 LDMIA     r5, { r3, r6 }

 MOV       r5, #255
 ORR       r5, r5, r5, LSL #16

 AND       r2, r5, r3, ROR #24         ; CHANGE REGISTER FROM MSB/LSB TO LSB/HSB
 AND       r4, r5, r3
 ORR       r2, r2, r4, ROR #8          ; R2 = number of blocks on a disc

 AND       r7, r5, r6, ROR #24         ; CHANGE REGISTER FROM MSB/LSB TO LSB/HSB
 AND       r4, r5, r6
 ORR       r7, r7, r4, ROR #8          ; R7 = size of a block


 STR       r7, [ r1, #4 ]

; If not in mode 0 then convert to other
 TEQ       r0, #LBAFormat
 ADDNE     r2, r2, #( MaxNumberOfBlocks + 1 ) * 2 + 1     ; ie point to lead out address

 TEQ       r0, #MSFFormat
 STRNE     r2, [ r1 ]
 GRABS     "r0, pc", NE



;------------------------
; Convert from LBA to MSF
;------------------------
 MOV       r0, #LBAFormat
 MOV       r3, r1
 MOV       r1, r2

 SWI       XCD_ConvertToMSF
 BVS       error_handler

; save the important bits in the users area
 STR       r1, [ r3 ]

 GRABS     "r0, pc"


;-----------------------------------------------------------------------------------------------
AudioStatus ROUT
;
; on entry:
;          r7 -> control block
; on exit:
;          usual error stuff
;          r0 = 0 playing audio, 1 Pause, 2 muted, 3 play completed, 4 error, 5 not requested
;-----------------------------------------------------------------------------------------------

 LDMIA     r7, { r0, r1, r2 }
 ADR       r7, temp_control_block
 STMIA     r7, { r0, r1, r2, r8 }

;-----------------------------------------------------
; Request current absolute address
;-----------------------------------------------------
 MOV      r0, #64
 ADR      r1, buffer + 100 - 4
 SWI      XCD_ReadSubChannel
 BVS      error_handler

;-----------------------------------------------------
; On a data track - so not playing
;-----------------------------------------------------
 LDRB     r14, buffer + (100 - 4) + 8
 TST      r14, #1
 MOVNE    r0, #NOPLAY
 GRABS    "r1, pc", NE

;-----------------------------------------------------
; Pause ?
;-----------------------------------------------------
 BL       GetPauseStatus
 TEQ      r0, #1
 [ PAUSED<>1
 MOVEQ    r0, #PAUSED
 ]
 GRABS    "r1, pc", EQ

;-----------------------------------------------------
; Save monotonic time
;-----------------------------------------------------
 SWI      XOS_ReadMonotonicTime
 STR      r0, [ r12 ]

;-----------------------------------------------------
; Request size of disc
;-----------------------------------------------------
 MOV      r0, #LBAFormat
 ADR      r1, buffer + 128
 SWI      XCD_DiscUsed
 BVS      error_handler

;-----------------------------------------------------
; If address < 0 or address > size of disc THEN NOPLAY
;-----------------------------------------------------
 LDR      r0, buffer + 100    ; current position
 LDR      r1, buffer + 128    ; disc size
 CMP      r0, #0
 CMPGE    r1, r0
 MOVLE    r0, #NOPLAY
 GRABS    "r1, pc", LE

;-----------------------------------------------------
; Pause for x centi-seconds
;-----------------------------------------------------
 LDR      r1, [ r12 ]
01
 SWI      XOS_ReadMonotonicTime
 SUB      r0, r0, r1
 CMP      r0, #DELAYTIMEFORPLAY
 BLT      %BT01

;-----------------------------------------------------
; Request current absolute address
;-----------------------------------------------------
 MOV      r0, #64
 ADR      r1, buffer + 128 - 4
 SWI      XCD_ReadSubChannel
 BVS      error_handler

;-----------------------------------------------------
; If current address - previous address > y THEN
;                                                if muting on THEN muted
;                                                else PLAYINGAUDIO
;-----------------------------------------------------
 LDR       r0, buffer + 100
 LDR       r1, buffer + 128
 SUB       r0, r1, r0
 CMP       r0, #PLAYMOVEMENT

 MOVLT     r0, #NOPLAY
 GRABS     "r1, pc", LT

 BL        GetStereoStatus
 TEQ       r0, #3
 MOVEQ     r0, #MUTED
 MOVNE     r0, #PLAYINGAUDIO

 GRABS     "r1, pc"

;-----------------------------------------------------------------------------------------------
;Inquiry ROUT
;
; on entry:
;          r0 -> place to put the inquiry data
;          r7 -> control block
; on exit:
; 
;-----------------------------------------------------------------------------------------------

; This is never called - the CDFSDriver internal routine is used instead

;-----------------------------------------------------------------------------------------------
DiscHasChanged ROUT
;
; on entry:
;          r7 -> control block
; on exit:
;          usual error stuff
;-----------------------------------------------------------------------------------------------

 BL        SetDiscChanged

 GRABS     "r0, pc"

;-----------------------------------------------------------------------------------------------
;Control ROUT
;
; on entry:
;          r0 =  0, 1 or 2 to set SCSI error response
;          r7 -> control block
; on exit:
;          usual error stuff
;-----------------------------------------------------------------------------------------------

; This is never called - the CDFSDriver internal routine is used instead

;-----------------------------------------------------------------------------------------------
Supported ROUT
;
; on entry:
;          r7 -> control block
; on exit:
;          usual error stuff
;          r0 = information word with bits set to indicate level of support
;-----------------------------------------------------------------------------------------------

 TEQ       r8, #PHILIPS_521

 MOVEQ     r0, #PHILIPS_CDD521_VERSIONBITS

 MOVNE     r0, #PHILIPS_CM212_VERSIONBITS

 GRABS     "r1, pc"

;-----------------------------------------------------------------------------------------------
;Prefetch ROUT
;
; on entry:
;          r0 =   addressing mode
;          r1 =   block number
;          r7 ->  control block
; on exit:
;          if error then r0-> error block, else all regs preserved
;
;-----------------------------------------------------------------------------------------------

; not supported

;-----------------------------------------------------------------------------------------------
;Reset ROUT
;
; on entry:
;          r7 ->  control block
; on exit:
;          if error then r0-> error block, else all regs preserved
;
;-----------------------------------------------------------------------------------------------

; not supported

;-----------------------------------------------------------------------------------------------
CloseDrawer ROUT
;
; on entry:
;          r7 ->  control block
; on exit:
;          if error then r0-> error block, else all regs preserved
;
;-----------------------------------------------------------------------------------------------

 MOV       r6, #0
 B         close_drawer_jumps_in_here

;-----------------------------------------------------------------------------------------------
IsDrawerLocked ROUT
;
; on entry:
;          r7 ->  control block
; on exit:
;          if error then r0-> error block, else all regs preserved
;          r0 = 0 if unlocked, 1 if locked
;
;-----------------------------------------------------------------------------------------------

 MOV       r6, #1
 B         drawer_status_jumps_in_here

;-----------------------------------------------------------------------------------------------
AudioControl ROUT
;
; on entry:
;          r0 = level of control ( only supports 0 )
;          r1 = left/right channel control ( only if r0 = 0 )
;          r7 -> control block
; on exit:
;          if error then r0-> error block, else all regs preserved
;
;-----------------------------------------------------------------------------------------------

;-----------------------------
; Only supported on the CM212
;-----------------------------
 TEQ       r8, #PHILIPS_521
 BEQ       notsupported

;-----------------------------------------
; Philips only supports level 0 of control
;-----------------------------------------
 TEQ       r0, #0
 BNE       invalidparameter

;-----------------------------------------
; Allowable range for stereo control is 0 to 3
;-----------------------------------------
 CMP       r1, #4
 BCS       invalidparameter


;-----------------------------------------
; Update audio control list
;-----------------------------------------
 MOV       r0, r1

 BL        SetStereoStatus

 MOV       r6, r0

;--------------------------------
; SCSI AudioControl command
;--------------------------------

 BL        space_saver

 MOV       r3, #&ee
 ORR       r3, r3, r10, LSL #8+5
 ORR       r3, r3, r6, LSL #8+3
 MOV       r4, #0

 STMIA     r2, { r3, r4, r5 }

 MOV       r1, #10

 SWI       XSCSI_Op

 GRABS     "r0, pc", VC

;----------------------------------------------------------------------
; If illegal request THEN ignore (just not playing audio at the moment)
;----------------------------------------------------------------------

 LDR       r1, [ r0 ]
 LDR       r2, =IllegalRequest
 TEQ       r1, r2

 BNE       error_handler

 GRABS     "r0, pc"

;-----------------------------------------------------------------------------------------------
;AudioLevel ROUT
;
; on entry:
;          r7 ->  control block
; on exit:
;          if error then r0-> error block, else all regs preserved
;
;-----------------------------------------------------------------------------------------------

; not supported

;-----------------------------------------------------------------------------------------------
Identify ROUT
; on entry:
;           r0  -> 36 byte SCSI inquiry data or 0
;           r1  -> if r0 =0 THEN this -> an error block ie/ the reason inquiry data failed
;           r7  -> control block, ignore the driver type, ie/ control block + 20
;           r11 =  reason code for CD_Identify
;           r12 -> their workspace
;           r13 -> full descending stack
; on exit:
;           r2 = -1 if not recognized, else internal drive type
;           r0-r1, r3-12 can be corrupted
;-----------------------------------------------------------------------------------------------

;----------------------------
; Is there any inquiry data ?
;----------------------------
 TEQ       r0, #0
 BEQ       not_philips

;----------------------------
; Removable media ?
;----------------------------
 LDRB      r1, [ r0 ]
 LDRB      r2, [ r0, #1 ]
 TST       r2, #128

;----------------------------
; Funny LUN ?
;----------------------------
 TEQNE     r1, #&7f
 BEQ       not_philips

;---------------------------- 
; Is it a philips drive ?
;---------------------------- 
; r1 -> manufacturers name
 MOV       r4, r0

 ADD       r0, r0, #8
 ADR       r1, philips_name
 MOV       r2, #?philips_name
 BL        CompareStrings

 ADRNE     r1, philips_2_name
 MOVNE     r2, #?philips_2_name
 BLNE      CompareStrings

 BNE       not_philips

;---------------------------- 
; Check description
;---------------------------- 

 MOV       r6, #-1

; CM212
 ADD       r0, r4, #16
 ADR       r1, philips_description
 MOV       r2, #?philips_description
 BL        CompareStrings

 MOVEQ     r6, #PHILIPS_212

; or CDD521

 ADR       r1, philips_2_description
 MOV       r2, #?philips_2_description
 BL        CompareStrings

 MOVEQ     r6, #PHILIPS_521

 CMP       r6, #-1
 BEQ       not_philips

 MOV       r2, r6

 GRABS     "r0, pc"

;---------------------------- 
not_philips
 MOV       r2, #-1
 GRABS     "r0, pc"

;-----------------------------------------------------------------------------------------------
philips_name          = "LMS"
philips_2_name        = "IMS"
philips_description   = "CM212"
philips_2_description = "CDD521"
 ALIGN

;-----------------------------------------------------------------------------------------------
; Routine to save Logical block address and save space
;-----------------------------------------------------------------------------------------------
save_seek_details ROUT
 STRB      r6, buffer + 5    ; LSB
 MOV       r6, r6, LSR #8
 STRB      r6, buffer + 4    ; LISB
 MOV       r6, r6, LSR #8
 STRB      r6, buffer + 3    ; UISB
 MOV       r6, r6, LSR #8
 STRB      r6, buffer + 2    ; MSB
 MOV       pc, r14

;-----------------------------------------------------------------------------------------------
; Routine to load default values and save space
;-----------------------------------------------------------------------------------------------
space_saver ROUT
 LDMIA     r7, { r8, r9, r10 }

 ORR       r0, r8, r9,  LSL #3                 ; card number
 ORR       r0, r0, r10, LSL #5                 ; lun
 ORR       r0, r0, #escapepolloff + nodata     ; prevent 'escape key'
 MOV       r1, #6
 ADR       r2, buffer
 MOV       r3, #0
 MOV       r5, #0
 MOV       r8, #1

 MOV       pc, r14


;-----------------------------------------------------------------------------------------------
;-----------------------------------------------------------------------------------------------
;-----------------------------------------------------------------------------------------------
;-----------------------------------------------------------------------------------------------

 END
