TITLE TaskWindow;

NEEDS OS;

CONST
   //TaskWindow errors
   Error_TaskWindowCantKill = .Bits: &A80,
   Error_TaskWindowBadSWIEntry = .Bits: &A81,
   Error_TaskWindowBadTaskHandle = .Bits: &A82,
   Error_TaskWindowDying = .Bits: &A83,
   Error_TaskWindowFileSleep = .Bits: &A84,
   Error_TaskWindowNoEditor = .Bits: &A85,
   Error_TaskWindowNoRedirection = .Bits: &A86;

//TaskWindow messages
CONST
   Message_TaskWindowInput   = .Bits: 0x808C0,
   Message_TaskWindowOutput  = .Bits: 0x808C1,
   Message_TaskWindowEgo     = .Bits: 0x808C2,
   Message_TaskWindowMorio   = .Bits: 0x808C3,
   Message_TaskWindowMorite  = .Bits: 0x808C4,
   Message_TaskWindowNewTask = .Bits: 0x808C5,
   Message_TaskWindowSuspend = .Bits: 0x808C6,
   Message_TaskWindowResume  = .Bits: 0x808C7;

TYPE
   TaskWindow_MessageData = .Struct (.Int: size, [232] .Char: data),
   TaskWindow_MessageEgo = .Struct (.Int: txt),
   TaskWindow_MessageNewTask = .Struct ([236] .Char: command);

SWI TaskWindow_TaskInfo =
   (  NUMBER 0x43380 "Obtains information from the TaskWindow module -
      see individual reason codes",
      ABSENT
   );

SWI TaskWindowTaskInfo_WindowTask =
   (  NUMBER 0x43380,
      ENTRY
      (  R0 # 0 "Obtains whether the calling task is running in a task
               window"
      ),
      EXIT
      (  R0! = .Bool: window_task
   )  );

//SWI TaskWindowTaskInfo_WindowTaskParent =
//   (  NUMBER 0x43380,
//      ENTRY
//      (  R0 # 1 "Obtains the parent task and handle of a task window"
//      ),
//      EXIT
//      (  R0! = Wimp_T: parent,
//         R1 = .Int: txt
//   )  );

SWI UpCall_Sleep =
   (  NUMBER 0x33,
      ENTRY
      (  R0 # 6 "Informs the TaskWindow module that a task wants to sleep
               until some termination condition is met",
         R1 = .Ref .Int: pollword
      ),
      EXIT
      (  R0! = .Bool: claimed
   )  )
