        SUBT    Server ==> &.Arthur.Broadcast.Server

Event
        TEQ     r0, #Event_Econet_Rx                    ; Is this the event we expect?
        BNE     LookForTx                               ; No, so look for our other event
        LDR     r0, RxDataHandle1
        TEQ     r0, r1
        BEQ     DoneRxData1
        LDR     r0, RxDataHandle2
        TEQ     r0, r1
        BEQ     DoneRxData2
        LDR     r0, RxControlHandle1
        TEQ     r0, r1
        BEQ     DoneRxControl1
        LDR     r0, RxControlHandle2
        TEQ     r0, r1
        BEQ     DoneRxControl2
        MOV     r0, #Event_Econet_Rx
        MOV     pc, lr

LookForTx
        TEQ     r0, #Event_Econet_Tx
        MOVNE   pc, lr
        Push    "r2, r3"
        ADR     r2, TxControlHandles
        ADR     r3, TxControlHandlesEnd
LookForTxControl
        LDR     r0, [ r2 ], #Tx_RecordSize
        TEQ     r0, r1
        SUBEQ   r0, r2, #Tx_RecordSize                  ; Get the address of the handle that it was
        Pull    "r2, r3", EQ
        BEQ     DoneTxControl
        TEQ     r2, r3
        BNE     LookForTxControl
        Pull    "r2, r3"
        LDR     r0, BroadcastHandle
        TEQ     r0, r1
        BEQ     DoneBroadcast
        LDR     r0, TxImHereHandle
        TEQ     r0, r1
        BEQ     DoneTxImHere
        MOV     r0, #Event_Econet_Tx
        MOV     pc, lr

        ; All claimed events exit (by B'ing) to here with all registers
        ; restored, with R0 as a normal error indicator if V is set
Exit                                                    ; This entry expects R3-R9, PC/LR on the stack
        Pull    "r3-r9, pc", VC                         ; No error so exit immediately
        ADR     r4, ErrorBuffer                         ; See if it is already there
        TEQ     r0, r4
        Pull    "r3-r9, pc", EQ
        LDR     r5, [ r4 ]                              ; See if there is already an error
        TEQ     r5, #0                                  ; By checking the error number
        Pull    "r3-r9, pc", NE                         ; If there is then leave it be
        LDR     r5, [ r0 ], #4                          ; Get the error number (word)
        STR     r5, [ r4 ], #4                          ; Transfer the error number
RetainErrorLoop
        LDRB    r5, [ r0 ], #1                          ; Get the error string (byte)
        STRB    r5, [ r4 ], #1
        TEQ     r5, #0                                  ; Check for the terminator
        BNE     RetainErrorLoop                         ; AFTER copying it
        Pull    "r3-r9, pc"                             ; Exit claiming the event

DoneRxData1
        [       Debug
        DLINE   "Data received (1)"
        ]
        Push    "r3-r9"                                 ; LR already on stack
        ADR     r8, RxDataHandle1
        B       RxData

DoneRxData2
        [       Debug
        DLINE   "Data received (2)"
        ]
        Push    "r3-r9"                                 ; LR already on stack
        ADR     r8, RxDataHandle2

RxData  ROUT                                            ; Only ever received from the Server
        SWI     XEconet_ReadReceive
        MOVVC   r9, r5                                  ; Keep the buffer address
        MOVVC   r0, r8
        BLVC    AbandonReceive                          ; Takes the address of the handle
        BLVC    UnSetRxTimeoutCallBack                  ; Remove RxTimeout Event
        BVS     Exit
        SUBS    r6, r6, #4                              ; Exclude Offset from data packet length
        BLE     ServerStillThere                        ; No data in packet, but the server is still alive
        LDR     r0, [ r5 ], #4                          ; first 4 bytes are the destination offset
        [       Debug
        DREG    r0, "For offset &"
        ]
        LDR     r1, FileLoadAddress                     ; The begining of the file in store
        ADD     r1, r1, r0                              ; The begining of this data packet (store destination)
        ADD     r3, r1, r6                              ; The end of this data packet (store destination)
        ADR     r4, MissingChunkList - :INDEX:Chunk_Link
FindChunkLoop
        LDR     r2, [ r4, #Chunk_Link ]                 ; Get the first record
        TEQ     r2, #NIL                                ; If we reach the end of the list
        BEQ     DoneChunk                               ; Then we must have done this one already
        LDR     r7, [ r2, #Chunk_Identifier ]
        LDR     r14, =ChunkIdentifier
        TEQ     r7, r14
        [       Debug
        ADRNEL  r0, ErrorFatalInternal
        |
        ADRNE   r0, ErrorFatalInternal
        ]
        [       UseMsgTrans
        BLNE    MessageTransErrorLookup
        |
        SETV    NE
        ]
        BVS     Exit
        [       Debug
        LDR     r7, [ r2, #Chunk_StartOffset ]
        DREG    r7, "Chunk_StartOffset = &", cc
        ]
        LDR     r7, [ r2, #Chunk_EndOffset ]
        [       Debug
        DREG    r7, ".  Chunk_EndOffset = &"
        ]
        CMP     r0, r7
        BHS     TryNextChunk                            ; Data is from after this missing chunk 
        LDR     r7, [ r2, #Chunk_StartOffset ]          ; Get the offset of this missing chunk
        CMP     r0, r7
        BHS     FoundChunk                              ; Data is from within this missing chunk  
TryNextChunk
        MOV     r4, r2                                  ; Keep the previous record pointer
        B       FindChunkLoop

FoundChunk                                              ; Copy data from Packet to destination
        LDRB    r7, [ r5 ], #1
        STRB    r7, [ r1 ], #1
        CMP     r1, r3
        BCC     FoundChunk
        LDR     r7, FileLoadedLength                    ; Increment the length by the number of bytes received
        ADD     r7, r7, r6
        STR     r7, FileLoadedLength
        [       Debug
        DREG    r7, "FileLoadedLength is now &"
        ]

        ADD     r1, r0, r6                              ; Calculate the end offset
        LDR     r7, [ r2, #Chunk_StartOffset ]          ; Get the offset of this missing chunk
        TEQ     r0, r7
        BNE     MidOrEndBlock                           ; Go and do the odd cases
        ADD     r7, r7, r6                              ; Move start by packet size
        STR     r7, [ r2, #Chunk_StartOffset ]
        LDR     r7, [ r2, #Chunk_EndOffset ]
        TEQ     r1, r7                                  ; Does this packet fill this missing chunk
        BEQ     FreeBlock                               ; Yes, so get rid of it
DoneChunk
        [       Debug
        DLINE   "Done chunk"
        ]
        LDR     r0, MissingChunkList
        TEQ     r0, #NIL
        BEQ     AllChunksLoaded
        ;       Open the Data Rx Buffer again
ServerStillThere
        [       Debug
        DLINE   "Re-opening DataRx"
        ]
        BL      OpenDataRx
ExitDataChunk
        BLVC    SetRxTimeoutCallBack
        B       Exit    

FreeBlock
        LDR     r7, [ r2, #Chunk_Link ]                 ; Get the rest of the chain
        STR     r7, [ r4, #Chunk_Link ]                 ; Put it where this record was
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module                              ; Throw this block away
        BVS     Exit
        B       DoneChunk

MidOrEndBlock
        LDR     r5, [ r2, #Chunk_EndOffset ]            ; Get the current end value
        STR     r0, [ r2, #Chunk_EndOffset ]            ; Make the packet begining is the new end
        TEQ     r1, r5                                  ; Does this packet butt up against the end?
        BEQ     DoneChunk                               ; If not then we must split this block
        BL      GetChunkRecord
        BVS     Exit
        STR     r1, [ r0, #Chunk_StartOffset ]          ; The end of this packet
        STR     r5, [ r0, #Chunk_EndOffset ]            ; The old end value
        LDR     r7, [ r2, #Chunk_Link ]                 ; Get the rest of the chain
        STR     r7, [ r0, #Chunk_Link ]                 ; Put it on the end of this record
        STR     r0, [ r2, #Chunk_Link ]                 ; Put this record on the end of the current one
        B       DoneChunk

AllChunksLoaded                                         ; Close the other RxDataBuffer, no more data coming
        ASSERT  (((:INDEX:RxDataHandle1)+4):EOR:((:INDEX:RxDataHandle2)+4))=4
        EOR     r0, r8, #4                              ; Get the address of the other handle
        BL      AbandonReceive                          ; And abandon that as well
        B       ExitDataChunk

DoneRxControl1
        [       Debug
        DLINE   "Control received (1)"
        ]
        Push    "r3-r9"                                 ; LR already on stack
        ADR     r8, RxControlHandle1
        B       RxControl

DoneRxControl2
        [       Debug
        DLINE   "Control received (2)"
        ]
        Push    "r3-r9"                                 ; LR already on stack
        ADR     r8, RxControlHandle2

RxControl                                               ; A control packet has come in
        SWI     XEconet_ReadReceive                     ; Find out from whom and what type
        MOVVC   r0, r8
        BLVC    AbandonReceive                          ; This reception now done with
        BVS     Exit                                    ; Too horrible, give up
        LDRB    r7, LocalStation                        ; Get my station number
        [       Debug
        BREG    r7, "Checking against the local station number &"
        ]
        TEQ     r3, r7                                  ; Has this come from myself? (local loopback)
        BEQ     ReOpenControlRx                         ; Yes, ignore it
        BIC     r1, r1, #BitSeven                       ; In case Econet is stupid
        [       Debug
        DREG    r1, "Type = &"
        ]
        TEQ     r1, #Type_Connect
        BEQ     ConnectRequest
        TEQ     r1, #Type_Grant
        BEQ     ConnectGranted
        TEQ     r1, #Type_Over
        BEQ     ChunkOver
        TEQ     r1, #Type_Ack
        BEQ     Thanks
        TEQ     r1, #Type_Request
        BEQ     ChunkRequest
        TEQ     r1, #Type_Error
        BEQ     ErrorFromServer
        TEQ     r1, #Type_Server
        BEQ     NewServer
        ;       Ignore unknown packet types
ReOpenControlRx
        LD      r0, Mode
        TEQ     r0, #Mode_Client
        BEQ     ReOpenControlServerRx
        BL      OpenControlServerRx                     ; Open Server Rx
        B       Exit    

ReOpenControlServerRx
        LD      r1, ServerStation
        MOV     r2, #0
        BL      OpenControlClientRx
        B       Exit    

ConnectRequest  ROUT
        [       Debug
        BREG    r3, "Type_ConnectRequest from &"
        ]
        [       False ; Debug
        ADR     r14, VIDC
        LDR     r0, =Border_Cyan
        STR     r0, [ r14 ]
        ]
        BL      CompareUID
        BNE     ReOpenControlRx                         ; No UID match ==> no co-operation
        [       Debug
        DLINE   "UID OK"
        ]
        LD      r0, Mode
        TEQ     r0, #Mode_Client                        ; No point if there is already a Server
        TEQNE   r0, #Mode_Weak                          ; Or if I can't be a server
        BEQ     ReOpenControlRx 
        [       Debug
        DLINE   "Neither Mode_Client nor Mode_Weak"
        ]
        SWI     XOS_ReadMonotonicTime
        BVS     ReOpenControlRx
        LDR     r1, StartTime
        SUB     r0, r0, r1                              ; Calculate how it is since we started
        [       WeakeningTime = 0
        LDRB    r14, WeakTime
        CMP     r0, r14
        |
        CMP     r0, #WeakeningTime
        ]
        [       Debug
        DREG    r0, "Time since start is now &"
        ]
        BHS     SkipResolution

        LDRB    r0, LocalStation                        ; Test incoming to see if there is a stronger
        CMP     r0, r3                                  ; that is, higher numbered station
        BHI     ReOpenControlRx                         ; If we are stronger continue, as usual
        LD      r0, Mode                                ; Otherwise see if we should become weak
        TEQ     r0, #Mode_Normal                        ; Only if we are still normal
        MOVEQ   r0, #Mode_Weak                          ; If there is then we are weak and must not grant
        STREQB  r0, Mode
        [       Debug
        BNE     %89
        BREG    r3, "Weakened by station &"
89
        ]
        B       ReOpenControlRx

SkipResolution
        LDR     r0, TxEnd
        TEQ     r0, #0
        BEQ     CanConnect                              ; Connect and carry on from TxPtr
        LDR     r1, TxPtr
        TEQ     r0, r1
        MOVEQ   r0, #0
        STREQ   r0, TxPtr                               ; reset TxPtr if reached end
CanConnect                                              ; I am now his Server
        [       Debug
        BREG    r3, "Doing the connect with &"
        ]
        [       False ; Debug
        ADR     r14, VIDC
        LDR     r0, =Border_Pink
        STR     r0, [ r14 ]
        ]
        LD      r5, Mode                                ; See what we are doing now
        TEQ     r5, #Mode_Serving                       ; If we are broadcasting already
        BEQ     DontSetImHere                           ; No need to update or start ImHere events
        LDR     r0, [ r8, #12 ]                         ; Get the new client's RxTimeoutTime
        DECS    r0, CallBackMargin                      ; Leave some slack
        MOVMI   r0, #CallBackMinimum                    ; Set a minimum value
        LDR     r1, ImHereCallBackTime                  ; If it's zero then this new value is a must
        TEQ     r1, #0
        CMPNE   r0, r1                                  ; Is this new time lower?
        MOVGT   r0, r1                                  ; Get lowest value into R0
        STRLE   r0, ImHereCallBackTime                  ; Only update if lowering the value
        BGT     DontSetImHere                           ; If not lowering no new call back is required
        LDR     r1, ImHereCallBackExpectedTime          ; See if we are expecting an event
        TEQ     r1, #0                                  ; Zero means we aren't
        BEQ     DoSetImHereCallBack                     ; Enable ImHereCallBack, time period still in R0
        MOV     r2, r0                                  ; Hold on to the delay
        SWI     XOS_ReadMonotonicTime
        BVS     Exit                                    ; Too horrible, give up
        ADD     r0, r0, r2                              ; Calculate the expected time
        CMP     r0, r1                                  ; See which one will happen first
        BGE     DontSetImHere                           ; The one that will already occur would be first
        BL      UnSetImHereCallBack                     ; Remove the event which will occur too late
        MOV     r0, r2                                  ; Restore the new delay to use
DoSetImHereCallBack
        BL      SetImHereCallBack
DontSetImHere
        LDR     r0, FileLength                          ; I need to broadcast it,  wherever I am
        STR     r0, TxEnd                               ; Broadcast to end of file
        MOV     r0, #Type_Grant                         ; Send 'Connect Granted' to Client
        MOV     r1, #Port_BroadcastControl
        MOV     r2, r3
        MOV     r3, r4
        ADR     r4, UID
        MOV     r5, #?UID
        [       Debug
        BREG    r2, "Sending: Type_ConnectGrant to &"
        ]
        BL      Tx
        ADRVC   r0, UID
        LDMVCIA r0, { r0, r1 }                          ; Get the UID
        LDRVCB  r2, LocalStation                        ; My station number
        ADR     r4, TxControlBuffer                     ; Put UID and my station number
        STMVCIA r4, { r0, r1, r2 }                      ; Into TxControlBuffer
        [       Debug
        BVS     %99
        BREG    r2, "Broadcasting: Type_Server is now &"
99
        ]
        MOVVC   r0, #Type_Server                        ; Tell our clients to do likewise
        MOV     r1, #Port_BroadcastControl
        MOV     r2, #&FF
        MOV     r3, #&FD                                ; Local broadcast, not to BBCs
        MOV     r5, #?UID+1                             ; UID plus station number
        BLVC    Tx
        [       Debug
        BVC     %97
        DLINE   "Tx returns an error"
97
        ]
      ;  BVS     Exit                                   ; Too horrible, give up
        B       ReOpenControlRx

        LTORG

ConnectGranted  ROUT                                    ; Received from the Server
        [       Debug
        BREG    r3, "Type_ConnectGrant from &"
        ]
        BL      CompareUID                              ; Check I've got the right 'Connect Granted'
        BNE     ReOpenControlRx                         ; No UID match ==> no co-operation
        [       Debug
        DLINE   "UID OK"
        ]
        LD      r0, ServerStation
        TEQ     r0, r3                                  ; Has this station already granted?
        [       Debug
        BNE     %73
        DLINE   "Noted as spurious"
73
        ]
        BEQ     ReOpenControlRx 

        ADR     r0, TxControlHandles                    ; Abandon all transmissions
        ADR     r1, TxControlHandlesEnd                 ; Since I've been granted
AbandonTxLoop                                           ; Abandon my tx grant if I'm doing one
        Push    "r0, r1"
        BL      AbandonTransmit                         ; Ignore errors, 'cos we might be Tx'ing
        Pull    "r0, r1"
        INC     r0, Tx_RecordSize
        TEQ     r0, r1
        BNE     AbandonTxLoop
        [       Debug
        BREG    r3, "Connected to server &"
        ]
        ST      r3, ServerStation
        [       False
        LDR     r0, FileHandle                          ; Check if the file has been opened
        CMP     r0, #0                                  ; If it has we must close it in the foreground
        BLEQ    SetupConnect                            ; Otherwise make connection
        |
        BL      SetupConnect                            ; Otherwise make connection
        ]
        BLVC    SetRxTimeoutCallBack                    ; Now we must keep a check on the server
        BLVC    GetChunkRecord                          ; Includes the initialisation of the
        MOV     r1, #0                                  ; Identifier and the Link to NIL          
        STR     r1, [ r0, #Chunk_StartOffset ]          ; Set first missing chunk
        LDR     r2, FileLength                          ; Starts at the begining of the file
        STR     r2, [ r0, #Chunk_EndOffset ]            ; For the size of the entire file
        STRVC   r0, MissingChunkList
        MOVVC   r0, #Mode_Client                        ; Indicate to the foreground what has happened
        STRVCB  r0, Mode
        [       Debug
        BVS     %83
        DLINE   "Now Mode=Mode_Client"
83
        ]
        BVS     Exit                                    ; Too horrible, give up
        B       ReOpenControlRx

SetupConnect                                            ; Allows the data to be received
        Push    "r8, r9, lr"
        [       Debug
        DLINE   "SetupConnect"
        ]
        ADR     r8, RxDataHandle1
        ADR     r9, RxDataBuffer1
        BL      OpenDataRx                              ; Two open CBs mean we won't miss
        ADR     r8, RxDataHandle2                       ; any data
        ADRL    r9, RxDataBuffer2
        BLVC    OpenDataRx
        Pull    "r8, r9, pc"

NewServer
        [       Debug
        BREG    r3, "Type_Server from &"
        ]
        BL      CompareUID
        BNE     ReOpenControlRx                         ; No UID match ==> no co-operation
        [       Debug
        DLINE   "UID OK"
        ]
        LDRB    r2, [ r8, #12 ]                         ; Station number of the new server
        [       Debug
        BREG    r2, "New server is &"
        ]
        LD      r0, Mode
        TEQ     r0, #Mode_Client
        BEQ     AlreadyConnected                        ; If we've been granted
        TEQ     r0, #Mode_Server
        BEQ     ResolveTwoServers                       ; or we've granted somebody
        TEQ     r0, #Mode_Normal
        TEQNE   r0, #Mode_Weak
        BEQ     DirectConnect                           ; Early case
        B       ReOpenControlRx                         ; Otherwise ignore, because they will
                                                        ; eventually respond to our ConnectRequest
  
AlreadyConnected                                        ; We are already a client, check server number
        LDRB    r1, ServerStation
        TEQ     r2, r1                                  ; If we are already connected then do nothing
        BEQ     ReOpenControlRx                         ; If not then our server is telling us to
DirectConnect                                           ; go and connect to another server
        MOV     r0, #Type_Connect                       ; So we transmit a Connect Request directly to it
        MOV     r1, #Port_BroadcastControl              ; Broadcast UID of file required
        LDRB    r2, [ r8, #12 ]                         ; Station number of the new server
        MOV     r3, #0                                  ; Local network
        ADR     r4, UID
        MOV     r5, #?UID+?RxTimeoutTime                ; Size of the UID + Timeout
        MOV     r6, #5                                  ; Don't try very much
        MOV     r7, #2                                  ; But do try hard
        [       Debug
        BREG    r2, "Sending: Type_ConnectRequest to &"
        ]
        BL      Tx
        BVS     Exit                                    ; Too horrible, give up
        B       ReOpenControlRx

ResolveTwoServers                                       ; We as the server are now aware that another
        LDMIA   r8, { r0, r1, r2, r3 }                  ; station is also serving this file, the higher
        LDRB    r0, LocalStation                        ; numbered station remains the server, the
        AND     r3, r3, #&FF                            ; lower becomes a client, after telling its
        CMP     r0, r3                                  ; clients about the new server
        BGT     ReOpenControlRx
        ADR     r0, TxControlBuffer                     ; Put UID and station number of new server
        STMIA   r0, { r1, r2, r3 }                      ; Into TxControlBuffer
        MOV     r0, #Type_Server                        ; Tell our clients to do likewise
        MOV     r5, #?UID+1                             ; UID plus station number
        BL      TxBroadcastControl                      ; Send it out
        B       DirectConnect                           ; Then do it ourselves

CheckServerStation
        LD      r0, ServerStation
        [       Debug
        DREG    r4, "Checking station number &", cc
        DREG    r3, ".&", cc
        DREG    r0, " against 0.&"
        ]
        TEQ     r3, r0
   ;    TEQEQ   r4, #0
        MOV     pc, lr

ChunkOver
        BL      CheckServerStation
        BNE     IgnoreChunkOver
        LD      r0, Mode
        [       Debug
        BREG    r3, "Type_ChunkOver from &", cc
        BREG    r0, "; Mode = &"
        ]
        TEQ     r0, #Mode_Client                        ; See if I am actually connected to a server
        BNE     IgnoreChunkOver                         ; I'm not so re-open Control Rx from anyone
        LDR     r7, MissingChunkList                    ; Points at a missing chunk records
        TEQ     r7, #NIL
        BEQ     TxThanks
        MOV     r1, r3                                  ; Not all loaded,  so open the Control Rx again
        MOV     r2, r4                                  ; Copy station and network from read of Rx
        BL      OpenControlClientRx
        MOV     r3, r2                                  ; Restore register arrangement for the Tx
        MOV     r2, r1
        LDR     r0, [ r7, #Chunk_StartOffset ]
        LDR     r1, [ r7, #Chunk_EndOffset ]
        [       Debug
        DREG    r0, "Chunk start &", cc
        DREG    r1, " chunk end &"
        ]
        SUB     r1, r1, r0                              ; Calculate the length
        ADR     r14, TxControlBuffer
        STMIA   r14, {r0, r1}                           ; Send offset and length
        MOV     r0, #Type_Request
        MOV     r5, #8
        [       Debug
        DLINE   "Sending: Type_Request"
        ]
        B       TxToServer                              ; Send request for more data off to the server

        ;       All loaded,  so send 'Thanks' to Server
        ;       Control Rx is now closed
TxThanks
        MOV     r0, #Type_Ack
        MOV     r5, #0
        MOV     r2, r3
        MOV     r3, r4
        [       Debug
        DLINE   "Sending: Type_Ack"
        ]
TxToServer
        MOV     r1, #Port_BroadcastControl
        ADR     r4, TxControlBuffer
        BL      Tx
        B       Exit    

IgnoreChunkOver
        BL      OpenControlServerRx
        B       Exit    

Thanks
        [       Debug
        DREG    r3, "Type_Ack from &"
        ]
        ADR     r6, ClientTable                         ; Remove this station, R3, from table
        AND     r5, r3, #2_11100000                     ; Get just the word offset (0..7)*2^5
        LDR     r0, [ r6, r5, ASR #3 ] !                ; Pickup the word with the right offset (0,4...28)
        MOV     r1, #1                                  ; Set the bottom bit
        AND     r5, r3, #2_00011111                     ; Get bit within the word (0..31)
        BIC     r0, r0, r1, LSL r5                      ; Get bit to position for this station, and clear it
        STR     r0, [ r6 ]                              ; Store it back in the table
        BL      ConnectedTotal
        [       Debug
        BREG    r0, "ConnectedTotal is now &"
        ]
        TEQ     r0, #0
        BNE     ThereIsSomeoneElse
        ;       Remove event waiting to do 'ChunkOverAgain'
        [       Debug
        ADRL    r0, StartNextBroadcast
        |
        ADR     r0, StartNextBroadcast
        ]
        MOV     r1, r12
        SWI     XOS_RemoveTickerEvent
        ;       and set flag saying finished
        MOV     r14, #Mode_Served
        STRVCB  r14, Mode
        B       Exit    

ThereIsSomeoneElse
        BL      OpenControlServerRx
        B       Exit    

ChunkRequest
        LDR     r0, [ r8, #4 ]                          ; Offset of the chunk requested
        [       Debug
        BREG    r3, "Type_Request from &", cc
        DREG    r0, "; for offset &"
        ]
        LDR     r1, FileLength
        CMP     r0, r1
        BHS     ChunkRequestError
        LDR     r2, [ r8, #8 ]                          ; Size requested
        [       Debug
        DREG    r2, "Length is &"
        ]
        ADD     r0, r0, r2                              ; The offset of the end of the request
        CMP     r0, r1
        BHI     ChunkRequestError
        [       Debug
        DLINE   "Length OK."
        ]
        BL      OpenControlServerRx                     ; Open Server Rx again
        BVS     Exit    
        LD      r0, BroadcastingData
        TEQ     r0, #BooleanFalse
        BNE     AlreadyDoingChunk
        ;       Remove event waiting to do 'ChunkOverAgain'
        [       Debug
        ADRL    r0, StartNextBroadcast
        |
        ADR     r0, StartNextBroadcast
        ]
        MOV     r1, r12
        SWI     XOS_RemoveTickerEvent
        BVS     Exit    
        ;       and start transmitting the requested chunk
        LDR     r0, [ r8, #4 ]
        STR     r0, TxPtr                               ; Read Chunk limits from RxBuffer
        LDR     r1, [ r8, #8 ]
        ADD     r0, r0, r1
        STR     r0, TxEnd
        ;       Set flag to say I'm broadcasting data
        MOV     r0, #:NOT: BooleanFalse
        ST      r0, BroadcastingData
        B       SetUpNextBroadcast

ErrorFromServer
        BL      CheckServerStation
        BNE     IgnoreChunkOver
        [       Debug
        BREG    r3, "Type_Error from &"
        ]
        BL      UnSetRxTimeoutCallBack                  ; Ignore error since we have
        ADRL    r0, ErrorBroadcastServerDead            ; a more important error
        [       UseMsgTrans
        BL      MessageTransErrorLookup
        |
        SETV
        ]
        B       Exit    

ChunkRequestError
        [       Debug
        LDR     r0, [ r8, #4 ]
        BREG    r0, "Chunk request error from &", cc
        DREG    r3, "; R3 = &"
        ]
        BL      OpenControlServerRx                     ; Open Server Rx again
AlreadyDoingChunk
        B       Exit    

DoneTxControl
        Push    "r3-r9"
        LDRB    r2, [ r0, #Tx_Type ]                    ; Find out what it was
        LDRB    r3, [ r0, #Tx_Station ]                 ; And to whom it went
        [       Debug
        DREG    r0, "Control transmitted on handle at &"
        LDRB    r1, [ r0, #Tx_Network ]
        BREG    r1, "Station &", cc
        LDRB    r1, [ r0, #Tx_Station ]
        BREG    r1, ".&", cc
        BREG    r2, ", Type is &"
        ]
        TEQ     r2, #Type_Grant
        BEQ     GrantCompleted
        TEQ     r2, #Type_Request
        BEQ     RequestCompleted
        TEQ     r2, #Type_Ack
        BEQ     AckCompleted
        BL      AbandonTransmit                         ; Atomicly
IgnoreErrorExit
        MOV     r0, #0
        STR     r0, ErrorBuffer
        CLRV
        B       Exit

GrantCompleted
        BL      AbandonTransmit                         ; Atomicly
        BVS     IgnoreErrorExit
        ADR     r6, ClientTable                         ; Add the station, in R3, to the table
        AND     r5, r3, #2_11100000                     ; Get just the word offset (0..7)*2^5
        LDR     r0, [ r6, r5, ASR #3 ] !                ; Pickup the word with the right offset (0,4...28)
        MOV     r1, #1                                  ; Set the bottom bit
        AND     r5, r3, #2_00011111                     ; Get bit within the word (0..31)
        ORR     r0, r0, r1, LSL r5                      ; Get bit to position for this station, and set it
        STR     r0, [ r6 ]                              ; Store it back in the table
        [       Debug
        BL      ConnectedTotal
        BREG    r0, "ConnectedTotal is now &"
        ]
        LD      r0, Mode
        TEQ     r0, #Mode_Serving
        MOVNE   r0, #Mode_Server
        STRNEB  r0, Mode
        B       IgnoreErrorExit

RequestCompleted
        BL      AbandonTransmit                         ; Atomicly
        B       Exit

AckCompleted
        BL      AbandonTransmit                         ; Atomicly
        MOV     r0, #Mode_Served                        ; So set the mode to Served so the load will finish
        STRB    r0, Mode                                ; for us; the client
        B       IgnoreErrorExit

DoneBroadcast
        [       Debug
        DLINE   "Broadcast completed"
        ]
        Push    "r3-r9"
        ADR     r0, BroadcastHandle                     ; Finish this one off
        BL      AbandonTransmit
        BVS     Exit
SetUpNextBroadcast                                      ; I'm broadcasting data - set a callback to do next packet
        MOV     r2, wp
        ADR     r1, StartNextBroadcast
        LD      r0, Mode                                ; Check to which mode we are in
        TEQ     r0, #Mode_Serving                       ; If we're Serving then this is a
        MOVEQ   r0, #InterDataDelay                     ; DataBroadcast
        MOVNE   r0, #ConnectRepeatDelay                 ; Otherwise it's a ConnectBroadcast
        SWI     XOS_CallAfter                           ; Errors here are fatal
        B       Exit    

BroadcastDataNow                                        ; This subroutine called to start things off
        Push    "r3-r9, lr"                             ; Set up standard stack frame
        B       SetUpNextBroadcast

DoBroadcast                                             ; This subroutine called from the callback
        [       Debug
        DLINE   "Broadcasting"
        ]
        Push    "r10, lr"
        LD      r0, Mode
        TEQ     r0, #Mode_Serving                       ; Are we serving data yet
        BNE     DoConnectBroadcast                      ; No, so maybe we're trying to connect
        LDR     r1, TxPtr
        STR     r1, FileServedLength
        LDR     r0, TxEnd
        SUBS    r5, r0, r1
        BEQ     TxChunkOver
        MOV     r0, #FinalisationRetryCount
        STRB    r0, ChunkOverCount
        LDR     r6, =BroadcastSize
        CMP     r5, r6
        MOVGT   r5, r6
        ADR     r2, TxBuffer
        STR     r1, [ r2 ], #4
        [       Debug
        DREG    r1, "Chunk &"
        ]
        LDR     r4, FileLoadAddress
        ADD     r1, r1, r4
        ADD     r3, r1, r5
        SUB     r0, r3, r4
        STR     r0, TxPtr                               ; new TxPtr to use next time
MoveLoop
        LDRB    r0, [ r1 ], #1
        STRB    r0, [ r2 ], #1
        TEQ     r1, r3
        BNE     MoveLoop
        MOV     r0, #Type_Data                          ; Now broadcast the data
        MOV     r1, #Port_BroadcastData
        ADD     r5, r5, #4
        [       TestRetries
        LDRB    r2, Nasty
        INC     r2
        STRB    r2, Nasty
        ANDS    r2, r2, #3
        MOVEQ   r5, #0
        ]
        ADR     r4, TxBuffer
BroadcastTx
        BL      SetBroadcastRegs
        [       True
        Push    r8
        ADR     r8, BroadcastHandle
        BL      StartTransmit
        Pull    r8
        |
        PHPSEI  r10
        SWI     XEconet_StartTransmit
        STRVC   r0, BroadcastHandle
        PLP     r10                                     ; Preserves V
        ]
        B       ExitDoBroadcast

TxChunkOver
        MOV     r0, #BooleanFalse
        ST      r0, BroadcastingData
        LDRB    r0, ChunkOverCount
        DECS    r0
        STRB    r0, ChunkOverCount
        [       Debug
        DREG    r0, "ChunkOverCount is now &"
        ]
        BEQ     GiveUpChunkOver
        ;       This will transmit chunk over again unless disabled by
        ;       'chunk request' received or no-one connected anymore ('Thanks')
        MOV     r0, #FinalisationRetryDelay
        ADR     r1, StartNextBroadcast
        MOV     r2, wp
        SWI     XOS_CallAfter
        BVS     ExitDoBroadcast
        BL      ConnectedTotal
        [       Debug
        BREG    r0, "Broadcasting: Type_Over to &", cc
        DLINE   " clients."
        ]
        STR     r0, TxControlBuffer
        MOV     r0, #Type_Over
        MOV     r5, #1                                  ; Single byte, never more than 253
        BL      TxBroadcastControl
        B       ExitDoBroadcast

GiveUpChunkOver
        MOV     r0, #Mode_Served
        ST      r0, Mode
        ADR     r0, RxControlHandle1
        BL      AbandonReceive
        ADRVC   r0, RxControlHandle2
        BLVC    AbandonReceive
ExitDoBroadcast
        Pull    "r10, pc"

DoConnectBroadcast
        TEQ     r0, #Mode_Normal                        ; Still un-connected?
        TEQNE   r0, #Mode_Weak                          ; Or destined to be a client?
        BNE     ExitDoBroadcast                         ; No, so nothing to do
        LD      r0, ConnectBroadcastCount               ; Check to see how many we have sent out
        CMP     r0, #ConnectRepeatCount
        BHS     ExitDoBroadcast                         ; Too many, give up
        INC     r0
        ST      r0, ConnectBroadcastCount
        MOV     r0, #Type_Connect                       ; Broadcast UID of file required
        MOV     r1, #Port_BroadcastControl
        ADR     r4, UID
        MOV     r5, #?UID+?RxTimeoutTime                ; Size of the UID + Timeout
        B       BroadcastTx

DoneTxImHere
        Push    "r3-r9"
        ADR     r0, TxImHereHandle
        BL      AbandonTransmit
        BVS     Exit
        LDR     r0, Mode                                ; Am I still the Server?
        CMP     r0, #Mode_Server                        ; Note this clears V, even if NE
        LDREQ   r0, ImHereCallBackTime
        BLEQ    SetImHereCallBack                       ; Yes, so set the event again
        B       Exit

        ;       *******  CallBack routines  *******

StartNextBroadcast                                      ; Entered on a CallAfter (IRQ assumed)
                                                        ; Entered 1 centi-second after last broadcast
                                                        ; or 10 centi-seconds after 'Chunk Over'
        Push    "r0-r8, lr"                             ; Save IRQ return address etc., on IRQ stack
        MOV     r8, psr                                 ; Save the current mode (IRQ) and flags
        TEQP    psr, #(IFlag + SVC_mode)                ; Go to SVC mode, disabling interrupts
        NOP
        Push    lr                                      ; Save Supervisor R14, on SVC stack
        BL      DoBroadcast
        B       ExitCallBack

ImHereCallBack                                          ; Entered on a CallAfter (IRQ assumed)
        Push    "r0-r8, lr"                             ; Save IRQ return address etc., on IRQ stack
        MOV     r8, psr                                 ; Save the current mode (IRQ) and flags
        TEQP    psr, #(IFlag + SVC_mode)                ; Go to SVC mode, disabling interrupts
        NOP
        Push    lr                                      ; Save Supervisor R14, on SVC stack
        [       Debug
        DLINE   "I'm Here CallBack"
        ]
        MOV     r0, #Type_Data
        MOV     r1, #Port_BroadcastData
        BL      SetAllBroadcastRegs                     ; No data, standard retries
        [       True
        Push    r8
        ADR     r8, TxImHereHandle
        BL      StartTransmit
        Pull    r8
        BVS     CallBackError                           ; Record the error
        |
        SWI     XEconet_StartTransmit
        BVS     CallBackError                           ; Record the error
        STR     r0, TxImHereHandle                      ; This is atomic because IRQ is disabled
        ]
        B       ExitCallBack

RxTimeoutCallBack                                       ; Entered on a CallAfter (IRQ assumed)
        Push    "r0-r8, lr"                             ; Save IRQ return address etc., on IRQ stack
        MOV     r8, psr                                 ; Save the current mode (IRQ) and flags
        TEQP    psr, #(IFlag + SVC_mode)                ; Go to SVC mode, disabling interrupts
        NOP
        Push    lr                                      ; Save Supervisor R14, on SVC stack
        [       Debug
        DLINE   "RxTimeout CallBack"
        ]
        MOV     r1, #0                                  ; Use zero to mean no error
        STR     r1, RxTimeoutTime                       ; Mark the event as having happened
        ADR     r0, RxControlHandle1                    ; Then abandon control Rxs so that
        BL      AbandonReceive                          ; we can't be disturbed
        MOVVS   r1, r0
        ADR     r0, RxControlHandle2
        BL      AbandonReceive
        MOVVS   r1, r0
        ADR     r0, RxDataHandle1
        BL      AbandonReceive
        MOVVS   r1, r0
        ADR     r0, RxDataHandle2
        BL      AbandonReceive
        MOVVS   r1, r0
        MOVS    r0, r1                                  ; Test for errors having happened
        BEQ     ExitCallBack                            ; No errors so normal exit
CallBackError
        ADR     r1, ErrorBuffer                         ; See if it is already there
        LDR     r2, [ r1 ]                              ; See if there is already an error
        TEQ     r2, #0                                  ; By checking the error number
        BNE     ExitCallBack                            ; If there is then leave it be
        LDR     r2, [ r0 ], #4                          ; Get the error number (word)
        STR     r2, [ r1 ], #4                          ; Transfer the error number
CallBackErrorLoop
        LDRB    r2, [ r0 ], #1                          ; Get the error string (byte)
        STRB    r2, [ r1 ], #1
        TEQ     r2, #0                                  ; Check for the terminator
        BNE     CallBackErrorLoop                       ; AFTER copying it
ExitCallBack
        Pull    lr                                      ; Restore Supervisor R14
        TEQP    r8, #0                                  ; Return to IRQ mode
        NOP
        Pull    "r0-r8, pc"                             ; Return using state stored on IRQ stack

        ; ******  Subroutines  ******

CompareUID                                              ; Preserves all registers
        Push    "r11, lr"                               ; Get two spare registers
        LDR     r14, UID                                ; Check the current UID
        LDR     r11, [ r8, #4 ]                         ; against the incoming UID
        TEQ     r14, r11
        LDREQ   r14, UID + 4
        LDREQ   r11, [ r8, #8 ]
        TEQEQ   r14, r11
        Pull    "r11, pc"                               ; Return EQ/NE

SetImHereCallBack                                       ; Preserves all registers
        Push    "r0-r2, lr"                             ; R0 is the period in centi-seconds
        [       Debug
        DREG    r0, "Set ImHere CallBack after &", cc
        DLINE   " centi-seconds"
        ]
        ADR     r1, ImHereCallBack
        MOV     r2, wp
        SWI     XOS_CallAfter
        MOVVC   r1, r0                                  ; Keep the delay
        SWIVC   XOS_ReadMonotonicTime
        ADDVC   r0, r1, r0                              ; Calculate when the call back is expected
        STRVC   r0, ImHereCallBackExpectedTime
        STRVS   r0, [ sp, #0 ]                          ; Poke an error into the stack
        Pull    "r0-r2, pc"

UnSetImHereCallBack                                     ; Preserves all registers
        Push    "r0-r1, lr"
        [       Debug
        DLINE   "UnSet ImHere CallBack"
        ]
        ADR     r0, ImHereCallBack
        MOV     r1, wp
        SWI     XOS_RemoveTickerEvent
        MOVVC   r0, #0                                  ; If has been removed then show
        STRVC   r0, ImHereCallBackExpectedTime          ; that no event is expected
        STRVS   r0, [ sp, #0 ]                          ; Poke an error into the stack
        Pull    "r0-r1, pc"

SetRxTimeoutCallBack
        Push    "r0-r2, lr"
        LDR     r0, RxTimeoutTime
        [       Debug
        DREG    r0, "Set RxTimeout CallBack after &", cc
        DLINE   " centi-seconds"
        ]
        ADR     r1, RxTimeoutCallBack
        MOV     r2, wp
        SWI     XOS_CallAfter
        STRVS   r0, [ sp ]
        Pull    "r0-r2, pc"

UnSetRxTimeoutCallBack
        Push    "r0-r1, lr"
        [       Debug
        DLINE   "UnSet RxTimeout CallBack"
        ]
        ADR     r0, RxTimeoutCallBack
        MOV     r1, wp
        SWI     XOS_RemoveTickerEvent
        STRVS   r0, [ sp ]
        Pull    "r0-r1, pc"

UnSetBroadcastCallBack
        Push    "r0-r1, lr"
        [       Debug
        DLINE   "UnSet Broadcast CallBack"
        ]
        ADR     r0, StartNextBroadcast
        MOV     r1, wp
        SWI     XOS_RemoveTickerEvent
        STRVS   r0, [ sp ]
        Pull    "r0-r1, pc"

GetChunkRecord
        Push    "r2-r3,lr"
        MOV     r0, #ModHandReason_Claim
        LDR     r3, =:INDEX: ChunkRecordSize
        SWI     XOS_Module                              ; Claim a record in the RMA
        MOVVC   r0, r2
        LDRVC   r2, =ChunkIdentifier
        LDRVC   r3, =NIL
        ASSERT  (:INDEX: Chunk_Identifier) = 0
        ASSERT  (:INDEX: Chunk_Link) = 4
        STMVCIA r0, { r2, r3 }
        Pull    "r2-r3,pc"

        LTORG

        END
