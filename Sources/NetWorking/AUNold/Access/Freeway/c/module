/* -*-C-*-
 * 
 * $Header: /ax/networking:Starling/Freeway/module.c:networking  1.20  $
 * $Source: /ax/networking:Starling/Freeway/module.c: $
 *
 * Copyright (c) 1995 Acorn Computers Ltd., Cambridge, England
 *
 * $Log:	module.c,v $
 * Revision 1.20  95/03/31  11:04:15  kwelton
 * Two main changes:
 * 
 * 1)  When Paul fixed my inappropriate use of splimp() and splx(), he used
 *     ensure_irqs_on() to replace splimp(); it should have been
 *     ensure_irqs_off().
 * 
 * 2)  All pending callbacks are removed during module finalisation.
 * 
 * Revision 1.19  95/03/30  16:22:50  pwain
 * Changed some splimp() and splx() calls tp
 * ensure_irqs_on and restore_irqs
 * 
 * Revision 1.18  95/03/30  16:14:12  kwelton
 * Three significant changes:
 * 
 * 1)  Error token FWONex should be FWONEx (tokens are case significant)
 * 
 * 2)  Socket descriptors in struct fw should be initialised to -1, this
 *     stops them being erroneously closed in fw_final().
 * 
 * 3)  Internet Event enables are counted - this is some perfectly healthy
 *     paranoia to prevent disabling events that haven't been enabled.
 * 
 * Revision 1.17  95/03/30  15:25:26  pwain
 * Added stacks of debug (more meaningful) for
 * Black Rom problem solving.
 * 
 * Revision 1.16  95/03/30  09:30:38  kwelton
 * fw_final() resets socket descriptors to an invalid number after calling
 * socketclose().
 * 
 * Revision 1.15  95/03/22  15:48:27  kwelton
 * Bugger!  Went through the previous changes with Paul, spotted a small
 * piece of redundant code, and forgot to save my emacs session before
 * checking the new version in.
 * 
 * Revision 1.14  95/03/22  15:42:15  kwelton
 * read_ifs() was not ignoring unwanted interfaces (e.g. Slip) when
 * looking for an interface to set an address on.  This has been
 * fixed by a fairly hefty rewrite of read_device_name().
 * 
 * Revision 1.13  95/03/19  17:58:36  kwelton
 * A number of changes:
 * 
 * 1)  The internet module now issues a service call (Service_InternetStatus)
 *     every time an SIOCSIFFADDR ioctl() is raised.  This is caught and,
 *     provided it was not this module that made the ioctl() call, the
 *     module is restarted which is the easiest way of coping with the
 *     changed Internet address.
 * 
 * 2)  Notice is now taken of the service call issued when the internet
 *     module finalises - this module shuts itself down as well.
 * 
 * 3)  The message file is reinitialised when a Service_MessageFileClosed
 *     is issued.
 * 
 * 4)  Service_DCIDriverStatus is checked to see whether the driver is
 *     initialising, or finalising.
 * 
 * 5)  Some of the functionality of fw_init() has been moved into a
 *     separate function (fw_prime()) for use when the module is about
 *     to be restarted.
 * 
 * Revision 1.12  95/03/10  18:06:06  kwelton
 * Found and plugged a significant number of memory leaks; added range
 * checking on SWI numbers.
 * 
 * Revision 1.11  95/03/07  20:53:10  kwelton
 * Main change is a bugfix in fw_service() where protocol startup messages
 * from the internet module are ignored if the module has already fully
 * initialised.
 * 
 * Also fixed a minor bug (CSD-190207) where *fwshow was producing an
 * inappropriate message; this message has also been internationalised.
 * 
 * Revision 1.10  95/03/05  16:04:00  kwelton
 * Tidied up scope and declarations of both functions and
 * variables; the module now compiles cleanly with -ffah.
 * 
 * Revision 1.9  95/03/01  09:08:28  pwain
 * Fixed a typo. Added Domain disks
 * 
 * Revision 1.8  95/02/16  15:36:43  pwain
 * Added SWI "Freeway_Status". With the reson code 0 in R0 this will 
 * return 1 if Freeway is running and accepting SWIs or 0 if it is
 * dormant in R1.
 * 
 * Revision 1.7  95/02/15  14:14:58  pwain
 * Fixed bug in SWI handler which caused Freeway to data abort
 * when the Internet module was not fully initilised. Basically
 * it was trying to pass back a local pointer to the global
 * environment.
 * 
 * Revision 1.6  95/02/02  08:57:57  pwain
 * Changed pickup point for DCI structures from module.h
 * to "sys/dcistructs.h".
 * 
 * Revision 1.5  95/02/01  19:05:05  pwain
 * Changed function names of callback routines that deal with 
 * additional drivers coming on line.
 * 
 * Revision 1.4  95/02/01  17:57:40  pwain
 * Fixed random-ish generation of IP numbers (reworked
 * read_device_name() and read_ifs). Now uses last 2
 * digits of ether address and last letter of name.
 * 
 * Revision 1.3  95/02/01  15:23:07  pwain
 * Added in more debug Printf()s.
 * Changed the way the internet module is 1st checked for to use a searc
 * on its name. (OS Module 18 call)
 * 
 * Revision 1.2  95/01/26  09:42:12  pwain
 * Added in support for loading from system ROM (unordered startup)
 * Debugging of startup using TML cards (CFLAGS = -DDEBUG)
 * General code tidy up to change DCI2-isms to DCI4
 * Tidy of module header (correct declaration of exit routines)
 * 
 * Revision 1.1  95/01/03  18:57:14  kwelton
 * Initial revision
 * 
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "sys/types.h"
#include "sys/uio.h"
#include "sys/socket.h"
#include "sys/time.h"
#include "sys/ioctl.h"
#include "sys/errno.h"
#include "sys/dcistructs.h"

#include "netinet/in.h"
#include "net/if.h"

#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "stubs.h"

void fw_final(void);

static int is_from_us(u_long src);

static _kernel_oserror *FreewayStatus(_kernel_swi_regs *r);
static _kernel_oserror *init_msgs(char *filename, char *fd);
static _kernel_oserror *fw_evenable(void);

/*
 * declare global variables
 */
struct fw fw = { 0 };
u_long local_adr = 0;

static void *module_wsp = 0;

static struct
{
    int	 e_nbr;
    char e_string[36];
} ebuf = { 0 };

static char msg_fd[16] = { 0 };

static struct eblk error_blocks[15] = {
    { 0, 0 },
    { 0x809f00, "FWType" },
    { 0x809f01, "FWOExt" },
    { 0x809f02, "FWONEx" },
    { 0x809f03, "FWDBuf" },
    { 0x809f04, "FWNBuf" },
    { 0x809f05, "FWNMem" },
    { 0x809f06, "FWOUnk" },
    { 0x809f07, "FWNNet" },
    { 0x809f08, "FWLStr" },
    { 0x809f09, "FWNLoc" },
    { 0x809f0a, "FWNAut" },
    { 0x809f0b, "FWNoInet" },
    { 0x809f0c, "FWStatusMsg" },
    { 0x809f0d, "FWInvalSWI" },
    };

#ifdef OldCode
static u_long auto_adr = 0;
#endif

#define MAXSWI 6

struct swient
{
    _kernel_oserror *(*swi_call)();	    /* swi handler */
};

static struct swient fw_ent[MAXSWI] = {
    RegisterType,
    WriteObject,
    ReadObject,
    EnumerateObjects,
    FreewayStatus,
    0,
};

struct client
{
    int (*cli_call)();	    /* cli handler */
};

#define MAXCLIENT 2

static void fw_show(char *a, int b);

static struct client fw_cli_call[2] = {
    (int (*)())fw_show,
    0,
};

static _kernel_oserror *calleverytick(int (*fun)()), *fw_claimv(void);
static _kernel_oserror *fw_real_init(void);
static int inet_present(void);

static const char protocol_name[] = "Internet";

static int dostart = 0;
static int startup_done = 0;
static int setting_address = 0;

int doobjects = 0;

extern void readdevice_entry(void);

/**********************************************************************
 * This is used to set the environment variables to indicate local
 * addresses.
 */

static void setadrvar(int ifcnt, char *adr)
{
    _kernel_swi_regs r;
    char varname[32];

    /*
     * Is it the 1st usable interface? If not, add a count to the name.
     */
    if( ifcnt == 0 )
	sprintf(varname, "%s", "Inet$LocalAddr");
    else
	sprintf(varname, "%s%d", "Inet$LocalAddr", ifcnt);

#ifdef DEBUG
    Printf("Setting \"%s\" to \"%s\"\n", varname, adr);
#endif /* DEBUG */

    r.r[0] = (int)varname;
    r.r[1] = (int)adr;
    r.r[2] = strlen(adr)+1;
    r.r[3] = 0;
    r.r[4] = 0;
    (void)_kernel_swi(XOS_Bit | OS_SetVarVal, &r, &r);
}

/**********************************************************************/

/*
 * rmafree - return some claimed memory to RMA
 */
static void rmafree(void *mem)
{
    _kernel_swi_regs r;

    r.r[0] = 7;
    r.r[2] = (int)mem;
    (void)_kernel_swi(XOS_Bit | OS_Module, &r, &r);
}

/**********************************************************************
 * This code reads back the DIB for the DCI drivers that are known
 * (the loopback device isnt read) and attempts to work out the
 * device address in order to make up an address for freeway to use
 * on the device.
 */

static void read_device_name(char *buf, char *etheradr)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;
    ChDibRef chd, chdnext;
    struct ifreq ifreq;
    int s;

    /*
     * error "return" is a null string in buf
     */
    buf[0] = '\0';

#ifdef DEBUG
    Printf("RD> Reading device information\n");
#endif

    r.r[0] = NULL;
    r.r[1] = Service_EnumerateNetworkDrivers;

    if( (e = _kernel_swi(XOS_Bit | OS_ServiceCall, &r, &r)) != NULL )
	return;

    if( (chd = (struct chaindib *)(r.r[0])) == NULL )
	return;

    /*
     * open a socket so we can read some interface details
     */
    if( (s = socket(AF_INET, SOCK_DGRAM, 0)) < 0 )
	return;

    /*
     * 950322 KWelton
     *
     * this routine has been restructured so that
     * only "suitable" interfaces are selected to
     * have their address set. "Suitable" means
     *
     * a)  Interface must support broadcast. This
     *     is a standard Freeway requirement.
     *
     * b)  Interface must support ARP.  If the i/f
     *     doesn't support ARP, then the chances
     *     are pretty good that it doesn't have a
     *     "unique" hardware address we can use to
     *     generate an interface address from
     */
    while( chd )
    {
#ifdef DEBUG
	Printf("RD> Reading %s's ether address\n", buf);
	/*
	Printf("RD> Address is %s\n",
	       ether_sprintf(chd->chd_dib->dib_address));
	*/
#endif

	sprintf(ifreq.ifr_name, "%.*s%d",
		sizeof(ifreq.ifr_name) - 2,
		chd->chd_dib->dib_name, chd->chd_dib->dib_unit);

	/*
	 * check that Internet knows about this interface and
	 * that the interface features are acceptable.
	 */
	if( (socketioctl(s, SIOCGIFFLAGS, (caddr_t)&ifreq) == 0 &&
	     (ifreq.ifr_flags & IFF_BROADCAST) &&
	     !(ifreq.ifr_flags & IFF_NOARP)) )
	{
	    int i;

	    strcpy(buf, ifreq.ifr_name);

	    for( i = 0; i < 6; i++ )
		etheradr[i] = chd->chd_dib->dib_address[i];

	    break;
	}

	/*
	 * this interface is no good, free it here and now
	 * and try the next one.
	 */
	chdnext = chd->chd_next;
	rmafree(chd);
	chd = chdnext;
    }

    /*
     * 950308 KWelton
     *
     * As the initiator of Service_EnumerateNetworkDrivers,
     * we have a responsibility to free the RMA claimed
     * during the service call
     */
    while( chd )
    {
	chdnext = chd->chd_next;
	rmafree(chd);
	chd = chdnext;
    }

    /*
     * finished - close the socket and go away
     */
    (void)socketclose(s);
    return;
}

/**********************************************************************
 * This is the main part of the initialisation. It tries to evaluate
 * all know ether drivers and see what if any are suitable for freeway
 * to use. It does this by looking to see if the device is able to
 * broadcast, isnt the loopback device and is able to be configured
 * at the software level to the settings that freeway requires.
 *
 * This routine may be called on many occasions when new drivers start
 * up. In this case it should find the last known suitable driver in the
 * fw structure, then skip down the list that is avaliable from the INET
 * module until it finds that one. Then it should start testing from there
 * since no record is kept of failed interfaces. This is probably the
 * most efficient way of doing this. [ Not Implemented yet ]
 */
static int read_ifs(void)
{
    char buf[512], name[16];
    struct ifconf ifc;
    struct ifreq ifreq, *ifr;
    struct sockaddr_in *sin = NULL;
    int s, n;
    u_long last_bcast;

    char etheradr[6];
    int retried = 0;
    u_char byte0, byte1, byte2;

    extern struct in_addr inet_makeaddr(int net, int host);

    /*
     * Open a socket in order to read back the info from the drivers.
     * This is a UDP based application. If we can't open the socket
     * abort.
     */
#ifdef DEBUG
    Printf("IC> Opening socket....");
#endif

    if( (s = socket(AF_INET, SOCK_DGRAM, 0)) < 0 )
    {
#ifdef DEBUG
	Printf("Failed - aborting\n");
#endif
	return -1;
    }

#ifdef DEBUG
    Printf("Succeeded (temp socket=%d)\n",s);
#endif/* DEBUG */

  again: /* UGHHH! */

    /*
     * Initialise things, including reading back the way that the
     * interface is currently set up.
     */
    ifc.ifc_len = sizeof(buf);
    ifc.ifc_buf = buf;

#ifdef DEBUG
    Printf("IC> Reading Interface(s) config (SIOCGIFCONF)...");
#endif

    if( socketioctl(s, SIOCGIFCONF, (char *)&ifc) < 0 )
    {
#ifdef DEBUG
	Printf("Failed - aborting\n");
#endif
	socketclose(s);
	return -1;
    }

#ifdef DEBUG
   Printf("Succeeded\n");
#endif/* DEBUG */

    ifr = ifc.ifc_req;

    /*
     * Check here to eliminate devices we have already seen.
     * We know if we have seen any by looking at the count.
     */
#ifdef DEBUG
    Printf("IC> Checking for known usable interfaces...");
#endif

    if (fw.fw_ifcnt != 0)
    {
#ifdef DEBUG
	Printf("Found some - skipping %d\n",fw.fw_ifcnt);
#endif

	last_bcast = fw.fw_ifbcast[(fw.fw_ifcnt)];

	for( n = ifc.ifc_len / sizeof (struct ifreq); n > 0; n--, ifr++ )
	{
	    /*
	     * loop around the known interfaces.
	     */
	    ifreq = *ifr;

	    /*
	     * We are just checking for broadcast addresses here 
	     * since we know that if we cant do it, it doesnt
	     * matter, and if we can then all we need to do is compare
	     * against the last known broadcast address.
	     */
	    if( socketioctl(s, SIOCGIFBRDADDR, (char *)&ifreq) < 0 )
		continue;
	    else
	    {
		/* 
		 * Make the address usable.
		 */
		sin = (struct sockaddr_in *)&ifreq.ifr_addr;

		/*
		 * If this address matches the last known one,
		 * move on to finding the new devices
		 */
		if (last_bcast == sin->sin_addr.s_addr)
		{
		    /* 
		     * Since we know this interface we can
		     * skip it.
		     */
#ifdef DEBUG
		    Printf("Found last known interface - evaluating rest\n");
#endif/* DEBUG */

		    ifr++;
		    break;
		}
	    }
	}
    }
#ifdef DEBUG
    else
	Printf("None known - evaluating rest\n");
#endif

    if (ifr == NULL)
    {
#ifdef DEBUG
	Printf("IC> Skipped all known interfaces - aborting\n");
#endif
	return fw.fw_ifcnt;
    }

    /*
     * Loop around the possible devices evaluating each one.
     */
    for( n = ifc.ifc_len / sizeof (struct ifreq); n > 0; n--, ifr++ )
    {
	ifreq = *ifr;

#ifdef DEBUG
	Printf("IC> Evaluating found interface: ");
#endif

	/*
	 * Check to see if its the loop back device. We dont want this
	 */
	if( socketioctl(s, SIOCGIFFLAGS, (char *)&ifreq) < 0 ||
	   ifreq.ifr_flags & IFF_LOOPBACK )
	{
#ifdef DEBUG
	    Printf("loopback device - skipping\n");
#endif
	    continue;
	}

	/*
	 * The card also needs to be able to broadcast
	 */
	if( (ifreq.ifr_flags & (IFF_BROADCAST | IFF_UP ))
	   != (IFF_BROADCAST | IFF_UP ) )
	{
#ifdef DEBUG
	    Printf("device bcast or up failure (flags = %x)\n",
		   ifreq.ifr_flags);
#endif
	    continue;
	}

	/*
	 * Get the address of the interface
	 */
	if( socketioctl(s, SIOCGIFADDR, (char *)&ifreq) < 0 )
	{
#ifdef DEBUG
	    Printf("cant get interface address - skipping\n");
#endif
	    continue;
	}

	/*
	 * If we dont currently know the local address, set it to
	 * the one we just found.
	 */
	if( local_adr == 0 )
	{
	    sin = (struct sockaddr_in *)&ifreq.ifr_addr;
	    local_adr = sin->sin_addr.s_addr;

#ifdef DEBUG
	    Printf("setting local_adr=%x...", sin->sin_addr.s_addr);
#endif/* DEBUG */

	}

#if 0
	/*
	 * I think this would give nicer output, but it is
	 * much too close to freeze to do at the moment
	 */
	sprintf(name, "%s", inet_ntoa(sin->sin_addr));
#else
	sprintf(name, "%lx", sin->sin_addr.s_addr);
#endif

	setadrvar(fw.fw_ifcnt, name);
	fw.fw_ifaddrs[fw.fw_ifcnt] = sin->sin_addr.s_addr;

	/*
	 * Find out the broadcast address. If we cant get it then
	 * we dont want this device so retry from the start skipping
	 * this address.
	 */
	if( socketioctl(s, SIOCGIFBRDADDR, (char *)&ifreq) < 0 )
	{
#ifdef DEBUG
	    Printf("Cant get broadcast address - unsetting local_addr\n");
#endif
	    local_adr = 0;
	    continue;
	}

	/*
	 * Keep account of this card since it meets the requirements.
	 */
#ifdef DEBUG
	Printf("Storing interface info.\n");
#endif
	sin = (struct sockaddr_in *)&ifreq.ifr_addr;
	fw.fw_ifbcast[(fw.fw_ifcnt)++] = sin->sin_addr.s_addr;
    }

    /* 
     * We havent found a valid interface. Make up an address etc.
     * and use that instead (if we can find an ether driver.
     */
    if( fw.fw_ifcnt == 0 && !retried )
    {
#ifdef DEBUG
	Printf("IC> No usable devices found. Trying to make up an address\n");
#endif

	read_device_name(name, etheradr);

#ifdef DEBUG
	Printf("IC> Try using name: %s...",name);
#endif

	if( name[0] != 0 )
	{
	    int retc;
	    int irqstatus;

#ifdef DEBUG
	    Printf("Making up ether address...");
#endif
	    byte0 = (u_char)etheradr[5];
	    byte1 = (u_char)etheradr[4];
	    byte2 = (u_char)name[1];
#ifdef DEBUG
	    Printf("Address derived from: %d %d %d...", byte0, byte1, byte2);
#endif
	    sin = (struct sockaddr_in *)&ifreq.ifr_addr;

	    /* next line modified 25/7/94 gw */
	    sin->sin_addr = inet_makeaddr(1, (byte0 | byte1 << 8 |
					      byte2 << 16));
	    sin->sin_family = AF_INET;

	    strncpy(ifreq.ifr_name, name, sizeof(ifreq.ifr_name));

	    irqstatus = ensure_irqs_off();
	    ++setting_address;
	    restore_irqs(irqstatus);
	    retc = socketioctl(s, SIOCSIFADDR, (caddr_t)&ifreq);
	    irqstatus = ensure_irqs_off();
	    --setting_address;
	    restore_irqs(irqstatus);

	    if( retc >= 0 )
	    {
#ifdef DEBUG
	        Printf("Seeing if this settup works.\n");
#endif
		retried = 1;
		goto again;
	    }
#ifdef DEBUG
	    Printf("Unable to setup address.\n");
#endif
	}
    }

    /*
     * If we have found a valid interface....
     */
    if( fw.fw_ifcnt > 0 )
    {
	_kernel_swi_regs r;
	_kernel_oserror *e;
	struct address_q *q;
	u_long ipadr;

#ifdef DEBUG
	Printf("IC> Found valid interface. Looking at Econet_EnumerateMap:");
#endif/* DEBUG */

	r.r[4] = 0;
	for(;;)
	{
	    e = _kernel_swi(XOS_Bit | Econet_EnumerateMap,&r, &r);
#ifdef DEBUG
	    Printf("r4 = %d",r.r[4]);
#endif/* DEBUG */
	    if (e || r.r[4] == -1) {
#ifdef DEBUG
	        Printf("\n");
#endif/* DEBUG */
		break;
		}

	    q = (struct address_q *)malloc(sizeof(struct address_q));
	    if (!q) {
#ifdef DEBUG
		Printf("No more Found\n");
#endif/* DEBUG */
		break;
		}

	    ipadr = (u_long)r.r[3];
#ifdef DEBUG
	    Printf("Found: %s, adding. ",r.r[3]);
#endif/* DEBUG */
	    q->q_bcast.s_addr = ipadr | 0xffff0000;
	    q->q_next = fw.fw_netadrs;
	    fw.fw_netadrs = q;
	}
    }

    /*
     * Tidy up and return
     */
#ifdef DEBUG
    Printf("IC> Done\n");
#endif/* DEBUG */

    socketclose(s);
    return fw.fw_ifcnt;
}

/**********************************************************************/

static int do_getsock(int port, int inputsocket)
{
    struct sockaddr_in addr;
    int sock, on = 1;

    if( (sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
#ifdef DEBUG
	Printf("DGS> Failed to open a socket - aborting\n");
#endif/* DEBUG */
	return (-1);
	}
#ifdef DEBUG
    Printf("DGS> Opened socket %d - ", sock);
#endif/* DEBUG */

    if( socketioctl(sock, FIONBIO, &on) < 0 ||
       socketioctl(sock, FIOASYNC, &on) < 0 )
    {
#ifdef DEBUG
	Printf("Cannot set FIONBIO and/or FIOASYNC.. Aborting\n");
#endif/* DEBUG */
	socketclose (sock);
	return (-1);
    }
#ifdef DEBUG
    Printf("FIONBIO..FIOASYNC..");
#endif/* DEBUG */


    if( setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &on, sizeof (on)) < 0 )
    {
#ifdef DEBUG
	Printf("Unable to toggle SO_BROADCAST.. Aborting\n");
#endif/* DEBUG */
	socketclose(sock);
	return (-1);
    }
#ifdef DEBUG
    Printf("SO_BROADCAST..");
#endif/* DEBUG */


    if( inputsocket )
    {
	addr.sin_family	     = AF_INET;
	addr.sin_addr.s_addr = htonl(INADDR_ANY);
	addr.sin_port	     = htons((u_short)port);
#ifdef DEBUG
        Printf("Input socket, binding to %d..", port);
#endif/* DEBUG */

	if( bind(sock, (struct sockaddr *)&addr, sizeof (addr)) < 0 )
	{
#ifdef DEBUG
	    Printf("Bind failed - aborting\n");
#endif/* DEBUG */
	    socketclose(sock);
	    return (-1);
	}
    }

#ifdef DEBUG
    Printf("Bound.\n");
#endif/* DEBUG */

    return(sock);
}

/**********************************************************************/

static int callback(void (*func)())
{
    _kernel_swi_regs r;

    r.r[0] = (int)func;
    r.r[1] = (int)module_wsp;
    return(_kernel_swi(XOS_Bit | OS_AddCallBack, &r, &r) != 0 ? -1 : 0);
}

/**********************************************************************/

static void clear_callback(void (*func)())
{
    _kernel_swi_regs r;

    r.r[0] = (int)func;
    r.r[1] = (int)module_wsp;
    (void)_kernel_swi(XOS_Bit | OS_RemoveCallBack, &r, &r);
}

/**********************************************************************/

extern void callb_entry(void);
static volatile int callbackflag = 0;
static volatile int readdevice_callback = 0;
#ifdef OldCode
static volatile int rscallbackflag = 0;
#endif

void setcallback(void)
{
#ifdef DEBUG
    Printf("SCB> setcallback (flag = %d)", callbackflag);
#endif/* DEBUG */

    if( callbackflag == 0 )
    {
	callbackflag = 1;

	if( callback(callb_entry) != 0 ) {
#ifdef DEBUG
	    Printf("Failed\n");
#endif/* DEBUG */
	    callbackflag = 0;
	}
    }

#ifdef DEBUG
    Printf("Ok!\n");
#endif/* DEBUG */

}

/**********************************************************************/

/*
 * fw_prime - prepare module for start/restart
 */
static void fw_prime(void)
{
#ifdef DEBUG
    Printf("FWP> In Freeway Prime\n");
#endif/* DEBUG */

    (void)init_msgs(MSG_FILE, msg_fd);

    /*
     * clear down the main Freeway information structure.
     */
    memset((char *)&fw, 0, sizeof(fw));

    /*
     * we currently have no sockets open
     */
    fw.fw_rssock = fw.fw_rssock1 = -1;

    /*
     * we no longer have a local address
     */
    local_adr = 0;

    /*
     * we have not yet completed a full startup
     */
    startup_done = 0;
}

/**********************************************************************/

/*ARGSUSED*/
_kernel_oserror *fw_init(char *cmd_tail, int pbase, void *pw)
{
    _kernel_oserror *e;
    module_wsp = pw;

    /* shut the compiler up */
    cmd_tail = cmd_tail;
    pbase = pbase;

    fw_prime();

    /*
     * Look to see if the internet modules are present. If so
     * continue with initialisation.
     */
#ifdef DEBUG
    Printf("IN> Attempting to find the Internet module\n");
#endif

    if (inet_present() == 0)
    {
#ifdef DEBUG
	Printf("IN> Returning Internet not found\n");
#endif
        return (_kernel_oserror *)0;
    }

    e = fw_real_init();
    if (e)
	return (e);

    return (_kernel_oserror *)0;
}

/*
 * Set up the various even handlers.
 */
static _kernel_oserror *fw_setup_events(void)
{
    _kernel_oserror *e;

    /*
     * Set up a claim on an event vector (EventV)
     */
#ifdef DEBUG
    Printf("FWE> Looking to claim: EventV...");
#endif/* DEBUG */

    e = fw_claimv();

    if (e)
    {
#ifdef DEBUG
	Printf("Failed.\n");
#endif/* DEBUG */

	fw_final();
	return(e);
    }

    /*
     * Set up a claim on another event vector (Internet_Event)
     * to enable early trapping of read signals on sockets.
     */
#ifdef DEBUG
     Printf("OK.. Internet_Event...");
#endif/* DEBUG */

    e = fw_evenable();

    if (e)
    {
#ifdef DEBUG
        Printf("Failed.\n");
#endif/* DEBUG */

        fw_final();
        return(e);
    }

    /*
     * Set up a claim on an event vector (TickerV)
     * to be called every 10ms
     */
#ifdef DEBUG
    Printf("OK.. TickerV...");
#endif/* DEBUG */

    e = calleverytick(tick_entry);

    if (e)
    {
#ifdef DEBUG
        Printf("Failed\n");
#endif/* DEBUG */

        fw_final();
        return(e);
    }

#ifdef DEBUG
    Printf("Ok.\n");
#endif/* DEBUG */
    return(_kernel_oserror *) 0;
}

/**********************************************************************
 * This routine gets called once Internet has started. There is either
 * no point in doing some of these things before then (event handling)
 * or we cant do it (Device Driver evaluation). This can be called
 * from one of 2 places. Either the fw_init() if FW is initialising 
 * after Internet and the DDs have loaded, or else from a SWI handle
 * when the required modules have been loaded.
 */
static _kernel_oserror *fw_real_init(void)
{
    _kernel_oserror *e;

    /*
     * Look to see what (if any) suitable DD are present.
     */
    fw.fw_ifcnt = 0;

#ifdef DEBUG
    Printf("RI> Doing interface count\n");
#endif

    read_ifs();
    if (fw.fw_ifcnt == 0)
    {
	/*
	 * Internet has started, but no device drivers are present so
	 * we should wait until some are.
	 */
	return((_kernel_oserror *)0);
    }

    /*
     * Now set up event handlers
     */
#ifdef DEBUG
    Printf("RI> Setting up event handlers\n");
#endif

    e = fw_setup_events();
    if (e)
	goto out;

    /*
     * If we found no suitable interfaces or cannot open the required
     * socket, abort here.
     */

    if( fw.fw_ifcnt <= 0 || (fw.fw_rssock = do_getsock(FWPORT, 1)) < 0 )
    {
	e = fw_error(Err_FWNNet);
	goto out;
    }
#ifdef DEBUG
    Printf("RI> Opened Socket (Unauth socket) - %d\n", fw.fw_rssock);
#endif/* DEBUG */

    /*
     * Again, if we cant open the required socket, abort.
     */
    if( (fw.fw_rssock1 = do_getsock(FWPORT1, 1)) < 0 )
    {
	socketclose(fw.fw_rssock);
	e = fw_error(Err_FWNNet);
	goto out;
    }
#ifdef DEBUG
    Printf("RI> Opened Socket1 (Auth Socket) - %d\n", fw.fw_rssock1);
#endif/* DEBUG */

    /*
     * Notify that we have started.
     */
#ifdef DEBUG
    Printf("RI> Initialisation succeded\n");
#endif
    dostart = 1;
    startup_done = 1;
    setcallback();
    return((_kernel_oserror *)0);

out:
#ifdef DEBUG
    Printf("RI> Initialisation failed\n");
#endif
    fw_final();
    return(e);
}

/**********************************************************************
 * Notify an interest in the main event vector.
 */
static _kernel_oserror *fw_claimv(void)
{
    _kernel_swi_regs r;

    r.r[0] = EventV;
    r.r[1] = (int)fw_event_entry;
    r.r[2] = (int)module_wsp;
#ifdef DEBUG
    Printf(":FWC: Claiming EventV..");
#endif/* DEBUG */
    return(_kernel_swi(XOS_Bit | OS_Claim, &r, &r));
}

/*
 * 950330 KWelton
 *
 * Keep a count of event enables
 */
static volatile int nenables = 0;

/**********************************************************************
 * Lookout for Internet based Events. (SIGIO, SIGPIPE etc).
 */
_kernel_oserror *fw_evenable(void)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    r.r[0] = Event_Enable;
    r.r[1] = Internet_Event;
#ifdef DEBUG
    Printf(":FEV: Enabling Internet_Events..");
#endif/* DEBUG */

    if( (e = _kernel_swi(XOS_Bit | OS_Byte, &r, &r)) == NULL )
    {
	int s = ensure_irqs_off();
	++nenables;
	restore_irqs(s);
    }

    return(e);
}

/**********************************************************************
 * Release event handlers
 */
static void fw_releasev(void)
{
    _kernel_swi_regs r;

#ifdef DEBUG
    Printf("FWR> Releasing Internet_event (nenables = %d)...", nenables);
#endif/* DEBUG */

    r.r[0] = Event_Disable;

    while( nenables > 0 )
    {
	r.r[1] = Internet_Event;

	if( _kernel_swi(OS_Byte, &r, &r) == NULL )
	{
	    int s = ensure_irqs_off();
	    --nenables;
	    restore_irqs(s);
	}
	else
	{
	    /*
	     * make the best of a very bad job
	     */
	    nenables = 0;
	    continue;				/* XXX */
	}
    }

#ifdef DEBUG
    Printf("EventV\n");
#endif/* DEBUG */

    r.r[0] = EventV;
    r.r[1] = (int)fw_event_entry;
    r.r[2] = (int)module_wsp;
    (void)_kernel_swi(XOS_Bit | OS_Release, &r, &r);
}

/**********************************************************************
 * Attempt to open the message file.
 */

_kernel_oserror *init_msgs(char *filename, char *fd)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    /*
     * Look to see if the messages file exists. If it doesnt,
     * there isnt much point in continuing.
     */
    r.r[1] = (int)filename;
    e = _kernel_swi(XOS_Bit | MessageTrans_FileInfo, &r, &r);
    if (e)
	return (e);

    /*
     * If we can get file information then we should be able to open it
     * so look to see if we can.
     */
    r.r[0] = (int)fd;
    r.r[1] = (int)filename;
    r.r[2] = 0;
    e = _kernel_swi(XOS_Bit | MessageTrans_OpenFile, &r, &r);
    return (e);
}

/**********************************************************************
 * Close the messages file
 */

static void release_msgs(char *fd)
{
    _kernel_swi_regs r;

    if (fd!=(char *)0) {
        r.r[0] = (int)fd;
        (void)_kernel_swi(XOS_Bit | MessageTrans_CloseFile, &r, &r);
	}
}

/**********************************************************************
 * Error handler
 */

_kernel_oserror *fw_error(int error)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    if( !error )
	return((_kernel_oserror *)0);

    ebuf.e_nbr = error_blocks[error].err_nbr;
    strcpy(ebuf.e_string, error_blocks[error].err_token);
    memset ((char *)&r, 0, sizeof(r));
    r.r[0] = (int)&ebuf;
    r.r[1] = (int)msg_fd;
    e = _kernel_swi(XOS_Bit | MessageTrans_ErrorLookup, &r, &r);
    return(e ? e : (_kernel_oserror *)&ebuf);
}

/**********************************************************************
 * Command line interface handler... just *fwshow
 */

/*ARGSUSED*/
_kernel_oserror *fw_cli_handler(char *arg_string, int arg_count,
				int cmd_no, void *pw)
{
    struct client *callp;
    _kernel_oserror *error = NULL;

    /* shut the compiler up */
    pw = pw;

    if (startup_done)
    {
        callp = &fw_cli_call[cmd_no];
        (*(callp->cli_call))(arg_string, arg_count);
    }
    else 
	error = fw_error(Err_FWNoInet);

    return(error);
}

/**********************************************************************
 * FWShow command. This lists all known access hosts and disks that
 * can be shared. -- Added in the definitions of DOMAIN_DISK and 
 * DOMAIN_HOST (PWain).
 */

/*ARGSUSED*/
static void fw_show(char *a, int b)
{
    struct fwtype *f;
    struct object_q *rl;
    struct address_q *q;

    /* shut the compiler up */
    a = a;
    b = b;

    /*
     * printf("Interfaces found: %d\n\n",fw.fw_ifcnt);
     *
     * Display any remote networks known about.
     */
    if( fw.fw_netadrs == 0 )
	printf("No remote nets\n");
    else
    {
	printf("net addresses:\n");
	for( q = fw.fw_netadrs; q; q = q->q_next )
	    printf("%s\n", inet_ntoa(q->q_bcast));
    }
    printf("\n");

    /*
     * Display information about Freeway types that are known.
     */
    for( f = fw.fw_types; f; f = f->fw_next )
    {
	if (f->fw_number == DOMAIN_DISK) 
	     printf("Type %d: (Discs)\n", DOMAIN_DISK);
	else if (f->fw_number == DOMAIN_HOST) 
	     printf("Type %d: (Hosts)\n", DOMAIN_HOST);
	else if (f->fw_number == DOMAIN_PRINTER) 
	     printf("Type %d: (Printers)\n", DOMAIN_PRINTER);
	else printf("Type %d:\n", f->fw_number);

	for( rl = f->fw_remobj; rl; rl = rl->r_next )
	{
	    /*
	     * If this entry isnt in use ignore it.
	     */
	    if( !rl->r_inuse )
		continue;

	    /*
	     * Show entry. Local ones are prefixed with a "*"
	     */
	    if( rl->r_local )
		printf("   *Name=%-10s Holder=%s\n",
		       rl->r_title, inet_ntoa(rl->r_ip));
	    else
		printf("    Name=%-10s Holder=%s\n",
		       rl->r_title, inet_ntoa(rl->r_ip));
	}

	if( f->fw_next )
	    printf("\n");
    }
}

/**********************************************************************/

static void fw_servicecall(int sc)
{
    _kernel_swi_regs r;

#ifdef DEBUG
    Printf("FSC> Sending service call: %x\n",sc);
#endif
    r.r[1] = sc;
    (void) _kernel_swi(XOS_Bit | OS_ServiceCall, &r, &r);
}

/**********************************************************************/

void fw_upcall(int upc, int type, struct object_q *rq)
{
    _kernel_swi_regs r;

#ifdef DEBUG
    switch(upc) {
	case FW_ADDED: Printf("FWU> Upcall: added "); break;
	case FW_REMOVED: Printf("FWU> Upcall: removed "); break;
	case FW_CHANGED: Printf("FWU> Upcall: changed "); break;
	case FW_DELETED: Printf("FWU> Upcall: deleted "); break;
	default: Printf("FWU> Upcall: operation: %d ",upc); break;
	}
    switch(type) {
	case DOMAIN_DISK: Printf("disc "); break;
	case DOMAIN_HOST: Printf("host "); break;
	case DOMAIN_PRINTER: Printf("printer "); break;
	default: Printf("type=%d",type); break;
	}
    Printf("Name: %s, Address: %x\n", rq->r_title , rq->r_ip.s_addr);
#endif/* DEBUG */

    r.r[0] = UpCall_Freeway;
    r.r[1] = upc;
    r.r[2] = type;
    r.r[3] = (int)rq->r_title;
    r.r[4] = rq->r_desclen;
    r.r[5] = (int)rq->r_desc;
    r.r[6] = (u_int)rq->r_ip.s_addr;
    (void)_kernel_swi(XOS_Bit | OS_UpCall, &r, &r);
}

/**********************************************************************
 * The main SWI handler. This basically looks up and calls the desired
 * (real) handler.
 */
_kernel_oserror *fw_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
    struct swient *callp;

    /* shut the compiler up */
    pw = pw;

    /* range check the SWI number */
    if( swinum >= (sizeof(fw_ent) / sizeof(fw_ent[0])) )
	return(fw_error(Err_FWInvalSWI));

    if (startup_done || (swinum == 4) )
    {
        /*
         * Call the desired SWI handler.
         */
#ifdef DEBUG
	switch(swinum) {
	    case 0: Printf("FWS> Handling SWI: Freeway_Register\n"); break;
	    case 1: Printf("FWS> Handling SWI: Freeway_Write\n"); break;
	    case 2: Printf("FWS> Handling SWI: Freeway_Read\n"); break;
	    case 3: Printf("FWS> Handling SWI: Freeway_Enumerate\n"); break;
	    case 4: Printf("FWS> Handling SWI: Freeway_Status\n"); break;
	    default: Printf("FWS> Handling SWI: %d\n", swinum); break;
	    }
#endif
        callp = &fw_ent[swinum];
        return((_kernel_oserror *)((callp->swi_call)(r)));
    }

    /*
     * Note: if we had done startup, a return would have been
     * encountered by this point so we can safely do the rest
     * without needing to test. This removes a compiler warning.
     * (No return from function)
     */
    return(fw_error(Err_FWNoInet));
}

/**********************************************************************/

struct fwtype *gettype(int type)
{
    struct fwtype *f;

    for( f = fw.fw_types; f != 0; f = f->fw_next )
	if( f->fw_number == type )
	    return(f);

    return ((struct fwtype *)0);
}

/**********************************************************************/

int type_id(char *str)
{
    int type = atoi(str);

    if (type > 0)
	return(type);

    return(-1);
}

/**********************************************************************/

int callb_handler(void)
{
#ifdef DEBUG
    Printf("CBH> In callback handler: ");
#endif/* DEBUG */

    if( callbackflag == 0 ) {
#ifdef DEBUG
        Printf("No callbacks to do - aborting\n");
#endif/* DEBUG */
	return (1);
	}

    callbackflag = 0;

    if( dostart )
    {
	dostart = 0;
#ifdef DEBUG
	Printf("Send FreewayStarting service call..\n");
#endif
	fw_servicecall(Service_FreewayStarting);
    }

    if( doobjects )
    {
#ifdef DEBUG
        Printf("Calling do_objects_on_callback.\n");
#endif/* DEBUG */

	doobjects = 0;
	do_objects_on_callback();
    }

#ifdef DEBUG
    Printf("\n");
#endif/* DEBUG */

    return (1);
}

/**********************************************************************/

static _kernel_oserror *calleverytick(int (*fun)())
{
    _kernel_oserror *e;
    _kernel_swi_regs r;

    r.r[0] = TickerV;
    r.r[1] = (int)fun;
    r.r[2] = (int)module_wsp;
    e = _kernel_swi(XOS_Bit | OS_Claim, &r, &r);
    if (e)
	return (e);

    return((_kernel_oserror *)0);
}

/**********************************************************************/

static void removetickerevent(int (*fun)())
{
    _kernel_swi_regs r;

    r.r[0] = TickerV;
    r.r[1] = (int)fun;
    r.r[2] = (int)module_wsp;
    (void)_kernel_swi(XOS_Bit | OS_Release, &r, &r);
}

/**********************************************************************/

int tick_handler(void)
{
    struct fwtype *f;

/* 
 * This produces WAY too much stuff
 *
#ifdef DEBUG
    Printf("FTH> In tickerV handler. Checking all objects.\n");
#endif
 */


    for( f = fw.fw_types; f != 0; f = f->fw_next )
	check_objects(f);

    return (1);
}

/**********************************************************************/

void fw_final(void)
{
    struct fwtype *f;
    struct address_q *q, *qnext;

#ifdef DEBUG
    Printf("FWF> In freeway finalisation. Closing down: Messages..");
#endif/* DEBUG */

    release_msgs(msg_fd);

    for( f = fw.fw_types; f != 0; f = f->fw_next )
    {
#if 0
	do_protocol(f, INADDR_BROADCAST, 0, REMOVE);
#else
	/*
	 * XXX - the wrong number of parameters are passed
	 * in the version above: make a *guess* at passing
	 * it the correct values.
	 */
#ifdef DEBUG
	switch(f->fw_number) {
	    case DOMAIN_DISK: Printf("Discs.."); break;
	    case DOMAIN_PRINTER: Printf("Printers.."); break;
	    case DOMAIN_HOST: Printf("Hosts.."); break;
	    default: Printf("type: %d.."); break;
	    }
#endif /* DEBUG */
	do_protocol(f, INADDR_BROADCAST, 0, REMOVE, 0, 0, 1);
#endif
    }

#ifdef DEBUG
    Printf("Events...\n");
#endif/* DEBUG */
    fw_releasev();

    if( fw.fw_rssock >= 0 )
    {
#ifdef DEBUG
        Printf("FWF> Closing: Socket..");
#endif/* DEBUG */
	socketclose(fw.fw_rssock);
	fw.fw_rssock = -1;
    }

    if( fw.fw_rssock1 >= 0 )
    {
#ifdef DEBUG
        Printf("Socket1..");
#endif/* DEBUG */
	socketclose(fw.fw_rssock1);
	fw.fw_rssock1 = -1;
    }

#ifdef DEBUG
    Printf("Ticker events..");
#endif/* DEBUG */
    removetickerevent(tick_entry);

#ifdef DEBUG
    Printf("Sending termination call\n");
#endif/* DEBUG */
    fw_servicecall(Service_FreewayTerminating);

    /*
     * 950331 KWelton
     *
     * clear any pending callbacks
     */
    if( callbackflag != 0 )
    {
	clear_callback(callb_entry);
	callbackflag = 0;
    }

    if( readdevice_callback != 0 )
    {
	clear_callback(readdevice_entry);
	readdevice_callback = 0;
    }

    /*
     * 950308 KWelton
     *
     * free the structures malloc'ed by read_ifs()
     */
#ifdef DEBUG
    Printf("FWF> Freeing memory\n");
#endif/* DEBUG */

    for( q = fw.fw_netadrs; q; q = qnext )
    {
	qnext = q->q_next;
	(void)free(q);
    }
}

/**********************************************************************/

static void rs_process_input(int format)
{		 
    struct sockaddr_in from;
    int fromlen, r;
    char inbuf[1024];

#ifdef DEBUG
    Printf("RPI> Reading network activity (%s):-\n", format == 0 ? "unauth" :
		"auth");
#endif/* DEBUG */

    for(;;)
    {
	fromlen = sizeof (from);
	r = recvfrom(format == 0 ? fw.fw_rssock : fw.fw_rssock1,
		     inbuf, sizeof(inbuf), 0,
		     (struct sockaddr *)(&from), &fromlen);

	if( r < 0 || fromlen != sizeof(struct sockaddr_in) ) {
#ifdef DEBUG
	    Printf("RPI: read failed. r=%d, errno=%d\n", r, errno);
#endif/* DEBUG */
	    break;
	    }

#ifdef DEBUG
       Printf("RPI: read %d bytes from %x\n", r, from.sin_addr.s_addr);
#endif/* DEBUG */

	if( !is_from_us(from.sin_addr.s_addr) )
	    process_message(from.sin_addr.s_addr, (struct rs_msg *)inbuf,
			    r, format);
    }
}

/**********************************************************************/

int fw_event_handler(int *r)
{
    int s, format;

#ifdef DEBUG
    Printf("FEH> r0=%s r1=%s ",
   	 r[0]==Internet_Event ? "Internet_Event" : "Other Event" ,
	 r[1]==SocketIO ? "SIGIO" : "SIGOther");

    if (r[2]==fw.fw_rssock) {
	Printf("r2=Socket(unauth) "); 
	}
    else if (r[2]==fw.fw_rssock1) {
	Printf("r2=Socket1(auth) "); 
	}
    else Printf("r2=%d ",r[2]); 
#endif/* DEBUG */

    if( r[0] == Internet_Event && r[1] == SocketIO )
    {
	if( r[2] == fw.fw_rssock )
	    format = 0;
	else if( r[2] == fw.fw_rssock1 )
	    format = 1;
	else
	    return (1);

#ifdef DEBUG
	Printf("Format=%s\n", format==0 ? "Unauth" : "Auth");
#endif/* DEBUG */

	s = ensure_irqs_on();
	rs_process_input(format);
	restore_irqs(s);
	return(0);
    }

    return(1);
}

/**********************************************************************/

static int is_from_us(u_long src)
{
    int i;

    for( i = 0; i < fw.fw_ifcnt; i++ )
	if( fw.fw_ifaddrs[i] == src )
	    return (1);

    return (0);
}

/**********************************************************************
 * To see if the Internet module is present do a lookup on its name.
 * This will succeed if it is loaded :) Much simpler than the old
 * method.
 */
static int inet_present(void)
{
    _kernel_swi_regs r;
    _kernel_oserror *err;

#ifdef DEBUG
    Printf("IP>> Looking for module: %s\n", protocol_name);
#endif
    r.r[0] = 18;
    r.r[1] = (int)protocol_name;
    err = _kernel_swi(XOS_Bit | OS_Module, &r, &r);

    if (!err)
    {
#ifdef DEBUG
	Printf("IP>> Found Internet module!\n");
#endif
	return 1;
    }

#ifdef DEBUG
    Printf("IP>> Found error : %s\n",err->errmess);
    Printf("IP>> Found error : %x\n",err->errnum);
#endif

    return 0;
}

/*
 * This is the main entry point that we have for picking up if new
 * devices come on line. DCI4 has service calls that announce them
 * for us. Other events may (or maynot) be worth watching for.
 */
void fw_service(int service_number, _kernel_swi_regs *r, void *pw)
{
    /* shut the compiler up */
    pw = pw;

    switch( service_number )
    {
      case Service_MessageFileClosed:
	(void)init_msgs(MSG_FILE, msg_fd);
	break;

	/*
	 * If we get a device driver status call we need to update
	 * our own count of the drivers present and see if its one
	 * that we are going to use.
	 */
      case Service_DCIDriverStatus:
#ifdef DEBUG
	Printf("DD> Received Driver status request\n");
	Printf("DD> Device: %s\n", ((struct dib *)r->r[0])->dib_name);
#endif
	/*
	 * 950315 KWelton
	 *
	 * we are only interested in device
	 * drivers that are starting up
	 */
	if( r->r[2] == 0 )
	{
	    readdevice_callback = 1;
	    callback(readdevice_entry);
	}

	break;

	/*
	 * DCIProtocol calls are done when any protocol (eg internet)
	 * startup.
	 */
      case Service_DCIProtocolStatus:
	/*
	 * we are only interested in the internet module
	 */
	if( !strncmp((char *)r->r[4], (char *)protocol_name,
		     sizeof(protocol_name) + 1) )
	{
	    /*
	     * it's internet - check its status
	     */
	    if (r->r[2] == 0)
	    {
		/* internet is starting */
#ifdef DEBUG
		Printf("PP> Internet startup\n");
#endif

		/*
		 * 950306 KWelton
		 *
		 * we don't need to worry if we have already initialised
		 */
		if( startup_done )
		    break;

#ifdef DEBUG
		Printf("PP> Looking to start up Freeway.\n");
#endif

		(void)fw_real_init();
	    }
	    else if( r->r[2] == 1 )
	    {
		/*
		 * internet is terminating - shut freeway
		 * down, then prepare it for restart
		 */
#ifdef DEBUG
		Printf("PP> Internet termination\n");
#endif
		fw_final();
		fw_prime();
	    }
	}

	break;

      case Service_InternetStatus:
#ifdef DEBUG
	Printf("Service_InternetStatus: reason %d (setting_address = %d)\n",
	       r->r[0], setting_address);
#endif

	switch( r->r[0] )
	{
	  case InternetStatus_AddressChanged:
	    /*
	     * an internet interface has had its address
	     * changed - shutdown and restart Freeway as
	     * long as it's not us that set the address.
	     */
	    if( !setting_address )
	    {
		fw_final();
		fw_prime();
		fw_real_init();
	    }

	    break;

	  default:
	    break;
	}

	break;

      default:
	break;
    }

    return;
}

int readdevice_handler(void)
{


    if (startup_done == 0) {
	/*
	 * This is the 1st interface we know of that we can use so
	 * we should try and finish the initialisation.
	 */
#ifdef DEBUG
        Printf("CB> Calling reall initialisation.\n");
#endif
        (void)fw_real_init();
	}
    else {
	/*
	 * Otherwise just add the interface to the list.
	 */
#ifdef DEBUG
        Printf("CB> Calling interface count\n");
#endif
        (void)read_ifs();
	}
    return 1;
}

/*
 * FreewayStatus added 16-02-95. Status request is:
 *
 * calling:
 *
 * r0 == reason code.
 * all other registers reserved.
 * 
 * return
 *
 * if r0 = 0  status request 
 *
 * r1 = 0 freeway loaded but idle - eg no ether drivers
 * r1 = 1 freeway running.
 * all other registers reserved.
 *
 */
static _kernel_oserror *FreewayStatus(_kernel_swi_regs *r)
{
    switch(r->r[0])
    {
      case 0:
	/* status request - return startup flag */
	r->r[1] = startup_done;
	return(NULL);

	/*NOTREACHED*/
	break;

      default:
	return(fw_error(Err_FWStatus));
    }
}

/**********************************************************************/

/* EOF module.c */
