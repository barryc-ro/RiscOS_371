/* -*-C-*-
 *
 * $Header: /ax/networking:Internet/riscos/module.c:networking  1.13  $
 * $Source: /ax/networking:Internet/riscos/module.c: $
 *
 * module.c - RISC OS front end for Internet protocol module.
 *
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
 *
 * $Log:	module.c,v $
 * Revision 1.13  95/03/31  14:04:48  kwelton
 * Two more changes:
 * 
 * 1)  builderrmess() only tries to lookup a tag if that tag does not
 *     contain any spaces.
 * 
 * 2)  do_instats() uses the message buffer within the global error
 *     blockfor formatting the panic message.
 * 
 * Revision 1.12  95/03/31  12:00:58  kwelton
 * Two main changes:
 * 
 * 1)  Callback scheme has changed - see log for ../lib/unixenv.c.
 * 
 * 2)  Debugging control is now initialised by reading some user bytes from
 *     CMOS RAM.
 * 
 * Revision 1.11  95/03/19  18:13:58  kwelton
 * Added new function sc_addrchanged(), which issues the InternetStatus
 * service call.
 * 
 * Revision 1.10  95/03/15  15:07:59  kwelton
 * Although the Internet module is now DCI version 4.02, it will
 * accept device drivers build against version 4.01 (the changes
 * between 4.01 and 4.02 do not affect this module).
 * 
 * Revision 1.9  95/03/10  17:32:21  kwelton
 * Added a new *-command InetChecksum which {en,dis}ables IP, UDP, and
 * TCP checksums.  Tidied *-command messages up a bit.
 * 
 * Revision 1.8  95/03/07  16:02:01  kwelton
 * Looks like I was a bit over-zealous with the internationalisation - the
 * syntax of *-commands should *not* be internationalised so that Obey
 * files will work on all territories.  This also allows invalid-syntax
 * entries in the cmhg header file.
 * 
 * Revision 1.7  95/03/01  11:52:22  kwelton
 * A number of changes:
 * 
 * 1)  Added support for the new InetGateway *-command.
 * 
 * 2)  claim_frames() now preserves the error code from the filter call
 *     to interfaces that do not support ARP (i.e. those with IFF_NOARP
 *     set).
 * 
 * 3)  SWI calls are now range checked
 * 
 * 4)  inet_error() can handle "tunnelled" error messages.
 * 
 * 5)  The format of per-protocol statistics printed in do_instats()
 *     has been *completely* overhauled - it now follows the style
 *     of the UNIX netstat -s command.
 * 
 * Revision 1.6  95/02/21  11:30:50  kwelton
 * Two changes:
 * 
 * 1)  The module should still initialise, even if it cannot locate
 *     the messages file in ResourceFS.
 * 
 * 2)  Fixed a couple of bugs concerned with initialising point-to-point
 *     interfaces: claim_frames() now makes the SWI call it has so
 *     carefully set the registers for; dib_register() only sets the
 *     IFF_BROADCAST flag for those interfaces which are not
 *     point-to-point.
 * 
 * Revision 1.5  95/02/01  17:35:09  kwelton
 * Care is taken in inet_final() to flush input queues and to bring
 * interfaces down neatly before the mbuf manager session is closed.
 * Note that killing the Internet module is still a failrly drastic
 * operation - no attempt is made, e.g., to free the mbufs held in
 * routing tables, or to shut down sockets gracefully.
 * 
 * Revision 1.4  95/01/30  18:39:58  kwelton
 * Fixed a couple of bugs, one of them rather unpleasant:
 * 
 * 1)  dib_register() should malloc() some space to hold the device name
 *     from a struct dib: the dib_name is constant only over the life of
 *     the driver to which it belongs; this may be shorter than the life
 *     of the struct ifnet which dib_register() is filling in.
 * 
 * 2)  When handle_dcidriverstatus() detects a driver starting up, it
 *     should only call dib_register() if the the driver has not been
 *     previously registered.
 * 
 * Revision 1.3  95/01/24  16:13:38  kwelton
 * Two changes:
 * 
 * 1)  claim_frames() is a bit more careful about what frame types, and
 *     what address levels are claimed: it does not bother trying to
 *     claim ARP and REVARP frames on those interfaces that do not
 *     support ARP; furthermore, it does not bother asking for broadcast
 *     frames from Point-to-Point interfaces, which have no concept of a
 *     broadcast address.
 * 
 * 2)  sock_swi_handler still needs to return 0 in r0, even when a SWI is
 *     marked as not returning a value.
 * 
 * Revision 1.2  95/01/03  14:07:19  kwelton
 * Two major changes made:
 * 
 * 1)  The new (v4.01) DCI version of DCIProtocolStatus (previously called
 * DCIProtocolDying) service call has been implemented.
 * 
 * 2)  Help on *-commands, and all informational messages have been
 * internationalised.
 * 
 * Revision 1.1  94/12/02  11:44:39  kwelton
 * Initial revision
 * 
 */
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"
#include "int_hndlr.h"

#include "sys/param.h"
#include "sys/errno.h"
#include "sys/dcistructs.h"
#include "sys/types.h"
#include "sys/socket.h"
#include "sys/mbuf.h"

#include "net/if.h"
#include "net/route.h"
#include "net/netisr.h"

#include "netinet/in.h"
#include "netinet/ip.h"
#include "netinet/ip_icmp.h"
#include "netinet/if_ether.h"
#include "netinet/udp.h"
#include "netinet/in_pcb.h"
#include "netinet/tcp.h"
#include "netinet/tcp_timer.h"
#include "netinet/in_var.h"
#include "netinet/icmp_var.h"

#include "module.h"
#include "instats.h"
#include "svcdebug.h"
#include "debug.h"

/*
 * declare the minimum DCI version this module will accept
 * from device drivers.
 */
#if 0
# define DCIMINIMUM	DCIVERSION
#else
# define DCIMINIMUM	401			/* XXX this is exceptional */
#endif

struct swient
{
    int swi_rval;
    int (*swi_call)();
};

int socket(), bind(), listen(), accept();
int connect(), recv(), recvfrom(), recvmsg();
int send(), sendto(), sendmsg(), shutdown();
int setsockopt(), getsockopt(), getpeername();
int getsockname(), socketclose();
int socketselect(), socketioctl(), sendtosm();
int socketread(), socketwrite(), socketstat();
int socketreadv(), socketwritev(), getstablesize();

char *berkeley_copyright = "Copyright (c) 1982, 1986 Regents of the University of California. All rights reserved.";

static struct swient sock_ent[26] =
{
    1, socket,
    0, bind,
    0, listen,
    1, accept,
    0, connect,
    1, recv,
    1, recvfrom,
    1, recvmsg,
    1, send,
    1, sendto,
    1, sendmsg,
    0, shutdown,
    0, setsockopt,
    0, getsockopt,
    0, getpeername,
    0, getsockname,
    0, socketclose,
    1, socketselect,
    0, socketioctl,
    1, socketread,
    1, socketwrite,
    0, socketstat,
    1, socketreadv,
    1, socketwritev,
    1, getstablesize,
    0, sendtosm,
};

struct client
{
    _kernel_oserror *(*cli_call)(int argc, char **argv);
};

static _kernel_oserror *do_instats(int argc, char **argv);
static _kernel_oserror *do_gateway(int argc, char **argv);
static _kernel_oserror *do_checksum(int argc, char **argv);
static _kernel_oserror *do_indebug(int argc, char **argv);

struct client inet_cli_call[] =
{
    do_instats,
    do_gateway,
    do_checksum,
    do_indebug
};

void *module_wsp = 0;
static _kernel_oserror _inet_errblk = { 0 };

static int inactive = 1;
static int finalising = 0;

static const char MsgFile[] = "Resources:$.Resources.Internet.Messages";
static u_long msgfd[4] = { 0 };
static int msgs_active = 0;

extern int ipcksum, udpcksum, tcpcksum;

int paniced = 0;
char panicbuf[PANICBUFLEN] = { 0 };

/*
 * declare some constant strings used as
 * tags for looking up error messages
 */
static const char TagModName[] = "ModName";
static const char TagIntErr[] = "IntErr";
static const char TagPaniced[] = "Paniced";
static const char TagHInGate[] = "HInGate";
static const char TagIsAct[] = "IsAct";
static const char TagNotAct[] = "NotAct";
static const char TagOn[] = "on";
static const char TagOff[] = "off";

static const char SynGateway[] = "Syntax: InetGateway [on|off]";
static const char SynChecksum[] = "Syntax: InetChecksum [i|u|t on|off]";

extern int tick_entry();
extern int inet_event_entry();
extern int startup_entry();

extern _kernel_oserror *inet_error(), *inet_claimv(), *calleverytick();

extern int ipforwarding;
extern char *malloc();

/**********************************************************************/

/*
 * init_msgs - initialise MessageTrans by opening resource file
 */
static _kernel_oserror *init_msgs(const char *filename, u_long *fd)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;

    /*
     * this code was ripped off from SCormie, guess this first
     * call is to check that the messages file is present.
     */
    r.r[1] = (int)filename;
    if( (e = _kernel_swi(XOS_Bit | MessageTrans_FileInfo, &r, &r)) != NULL )
    {
	msgs_active = 0;
	return(e);
    }

    /*
     * this is a bit unpleasant, but necessary - there *may* be
     * errors returned (e.g. file already open) returned from the
     * OpenFile call, *assume* that the message system is active,
     * despite any errors returned.
     */
    msgs_active = 1;

    /*
     * now really do it (r1 is preserved from previous call)
     */
    r.r[0] = (int)fd;
    r.r[1] = (int)filename;
    r.r[2] = 0;
    return(_kernel_swi(XOS_Bit | MessageTrans_OpenFile, &r, &r));
}

/**********************************************************************/

/*
 * release_msgs - close MessageTrans resource file
 */
static void release_msgs(u_long *fd)
{
    _kernel_swi_regs r;

    msgs_active = 0;

    r.r[0] = (int)fd;
    (void)_kernel_swi(XOS_Bit | MessageTrans_CloseFile, &r, &r);
}

/**********************************************************************/

/*
 * lookup_tag - try to look up message tag via MessageTrans
 */
static char *lookup_tag(char *tag)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;
    static char msgbuf[128] = { 0 };

    if( !msgs_active )
	return(tag);

    /*
     * set all registers to zero - this prevents
     * unwanted parameter substitution
     */
    memset((char *)&r, 0, sizeof(r));

    r.r[0] = (int)msgfd;
    r.r[1] = (int)tag;
    r.r[2] = (int)msgbuf;
    r.r[3] = sizeof(msgbuf);

    if( (e = _kernel_swi(XOS_Bit | MessageTrans_Lookup, &r, &r)) == NULL )
	return((char *)(r.r[2]));
    else
	return(tag);
}

/**********************************************************************/

/*
 * handle_messagefile - MessageFileClosed service call has been
 * received, so re-open the file if necssary.
 */
static void handle_messagefile(_kernel_swi_regs *r)
{
    (void)init_msgs(MsgFile, msgfd);
}

/**********************************************************************/

/*
 * builderrmess - build an internationalised error message
 */
static void builderrmess(char *dest, char *preamble,
			 const char *tag, char **tail)
{
    if( preamble )
	dest += strlen(strcpy(dest, preamble));

    /*
     * 950331 KWelton
     *
     * any messages with colons in them will confuse MessageTrans,
     * therefore assume that, if the "tag" contains any spaces, then
     * it is a plain string.
     */
    if( !strchr(tag, ' ') )
	strcpy(dest, lookup_tag((char *)tag));
    else
	strcpy(dest, tag);

    if( tail )
	*tail = dest + strlen(dest);
}

/**********************************************************************/

/*
 * malloc_failure - build an error message reporting malloc failure
 */
static _kernel_oserror *malloc_failure(void)
{
	char *tail;

	_inet_errblk.errnum = INETERR_MLCFAIL;
	builderrmess(_inet_errblk.errmess, NULL, TagModName, &tail);
	builderrmess(tail, ": ", TagIntErr, &tail);
	builderrmess(tail, ": ", "MlcFail", NULL);

	return (&_inet_errblk);
}

/**********************************************************************/

/*
 * init_loopback - initialise internal loopback "driver". returns
 * 1 if loopback successfully initialised, else 0 (this will be
 * because of a malloc failure).
 */
static int init_loopback(void)
{
    extern struct ifnet loif;
    struct ifnet *ifp = &loif;
    static char lbname[] = "lo";

    ifp->if_name = lbname;
    ifp->if_unit = 0;
    ifp->if_mtu = ETHERMTU;
    ifp->if_flags = (IFF_NOTRAILERS | IFF_LOOPBACK);

    ifp->if_init = if_module_null;
    ifp->if_output = looutput;
    ifp->if_ioctl = loioctl;
    ifp->if_reset = if_module_null;

    /* add this to ifnet */
    if_attach(ifp);
    return(1);
}

/**********************************************************************/

/*
 * sc_addrchanged - issue InternetStatus service call
 */
void sc_addrchanged(void)
{
    _kernel_swi_regs r;

    r.r[0] = InternetStatus_AddressChanged;
    r.r[1] = Service_InternetStatus;
    (void)_kernel_swi(XOS_Bit | OS_ServiceCall, &r, &r);
}

/**********************************************************************/

/*
 * sc_protostatus - issue DCIProtocolStatus service call
 */
static void sc_protostatus(int status)
{
    /*
     * XXX
     *
     * declare __module_header as an external *function*
     * -- this stops it being incorrectly relocated
     */
    extern void __module_header(void);
    u_int *address = (u_int *)__module_header;
    _kernel_swi_regs r;
    u_char *titlestring;

    /*
     * calculate pointer to title string (this is messy)
     */
    titlestring = (u_char *)(address + 4);
    titlestring = ((u_char *)address + *titlestring);

    /*
     * we use our private workspace pointer as a Protocol Handle
     */
    r.r[0] = (int)module_wsp;
    r.r[1] = Service_DCIProtocolStatus;
    r.r[2] = status;
    r.r[4] = (int)titlestring;
    r.r[3] = DCIVERSION;
    (void)_kernel_swi(XOS_Bit | OS_ServiceCall, &r, &r);
}

/**********************************************************************/

/*
 * dib_register - add the unit described by dib to ifnet chain. returns
 * 1 if unit attached OK, else 0 (this will be because of a malloc failure)
 */
static int dib_register(DibRef dib)
{
    struct arpcom *ac;
    struct ifnet *ifp;
    u_int driver_flags;
    _kernel_swi_regs r;
    _kernel_oserror *e;
    int s = splimp();

#ifdef DEBUG
    if( DODEBUG(DBGSTARTUP) )
	Printf("dib_register: new unit %s%d (dib %x)\n",
	       dib->dib_name, dib->dib_unit, dib);
#endif

    /*
     * only pay attention to those drivers which can handle
     * the required version of DCI 4.
     */
    r.r[0] = 0;
    if( (e = _kernel_swi(XOS_Bit | (dib->dib_swibase + DCI4Version),
			 &r, &r)) != NULL || r.r[1] < DCIMINIMUM )
    {
#ifdef DEBUG
	if( DODEBUG(DBGSTARTUP) )
	    Printf("dib_register: DCI version (%d) is too old\n", r.r[1]);
#endif

	/*
	 * failed to read DCI version, or it is
	 * too old, silently ignore this unit
	 */
	splx(s);
	return(1);
    }

    /*
     * claim another structure to hold this driver
     */
    if( (ac = (struct arpcom *)malloc(sizeof(*ac))) == NULL )
    {
#ifdef DEBUG
	if( DODEBUG(DBGSTARTUP) )
	    Printf("dib_register: failed to claim space for struct arpcom\n");
#endif
	splx(s);
	return(0);
    }

    /*
     * clear the buffer
     */
    memset((caddr_t)ac, 0, sizeof(*ac));

    ifp = &ac->ac_if;

    /*
     * we need struct dib in ifnet for quick comparisons against
     * name & unit, also keep dib_swibase to prevent an extra
     * dereference every time a SWI is raised (e.g. for transmit)
     */
    ifp->if_swibase = dib->dib_swibase;
    ifp->if_dib = dib;
    ifp->if_unit = dib->dib_unit;
    ifp->if_flags = IFF_NOTRAILERS;

    /*
     * have to be a bit more careful with device names
     */
    if( (ifp->if_name = malloc(strlen((char *)dib->dib_name) + 1)) == NULL )
    {
#ifdef DEBUG
	if( DODEBUG(DBGSTARTUP) )
	    Printf("dib_register: failed to claim space for if_name\n");
#endif
	splx(s);
	return(0);
    }
    strcpy(ifp->if_name, (char *)dib->dib_name);

    /*
     * initialise function pointers
     */
    ifp->if_init = if_module_null;
    ifp->if_output = if_module_output;
    ifp->if_ioctl = if_module_ioctl;
    ifp->if_reset = if_module_null;

    /*
     * read driver specific features - MTU ...
     */
    r.r[0] = 0;
    r.r[1] = dib->dib_unit;
    (void)_kernel_swi(XOS_Bit | (dib->dib_swibase + DCI4GetNetworkMTU),
		      &r, &r);
    ifp->if_mtu = (short)r.r[2];

    /*
     * ... and various Inquiry information
     */
    (void)_kernel_swi(XOS_Bit | (dib->dib_swibase + DCI4Inquire), &r, &r);
    driver_flags = r.r[2];

    /*
     * "standard" ethernet devices have a unique hardware address,
     * and use ARP protocol to ascertain hardware <-> newtrok
     * address mapping, other devices (e.g. PPP/SLIP) have no hardware
     * address, and do not use ARP.
     */
    if( driver_flags & INQ_HWADDRVALID )
	memcpy((caddr_t)ac->ac_enaddr, (caddr_t)dib->dib_address,
	       sizeof(ac->ac_enaddr));
    else
	ifp->if_flags |= IFF_NOARP;

    if( driver_flags & INQ_POINTOPOINT )
	ifp->if_flags |= IFF_POINTOPOINT;
    else
	ifp->if_flags |= IFF_BROADCAST;

    if( driver_flags & INQ_CANREFLECT )
	ifp->if_flags |= IFF_CANREFLECT;

    /*
     * that's all - attach and return
     */
#ifdef DEBUG
    if( DODEBUG(DBGSTARTUP) )
	Printf("dib_register: all OK, calling if_attach(%x)\n", ifp);
#endif
    if_attach(ifp);
    splx(s);
    return(1);
}

/**********************************************************************/

/*
 * enumerate_drivers - build a list of all device drivers, and
 * if_attach() them.  returns NULL if all OK, else pointer to
 * standard error block.
 */
static _kernel_oserror *enumerate_drivers(void)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;
    ChDibRef chd, chdnext;

    /*
     * ensure that ifnet is currently empty
     */
    if( ifnet != NULL )
    {
	char *tail;

	_inet_errblk.errnum = INETERR_IFBAD;
	builderrmess(_inet_errblk.errmess, NULL, TagModName, &tail);
	builderrmess(tail, ": ", TagIntErr, &tail);
	builderrmess(tail, ": ", "IfBad", NULL);
	return (&_inet_errblk);
    }

    /*
     * the first entry is *always* the loopback
     * driver - fill it in by hand
     */
    if( !init_loopback() )
	return(malloc_failure());

    /*
     * now use service call to obtain a list of all
     * device drivers in the system.
     */
    r.r[0] = NULL;
    r.r[1] = Service_EnumerateNetworkDrivers;
    if( (e = _kernel_swi(XOS_Bit | OS_ServiceCall, &r, &r)) != NULL )
	return(e);

    /*
     * loop over all units, and register them
     */
    for( chd = (ChDibRef)r.r[0]; chd != NULL; chd = chdnext )
    {
#ifdef DEBUG
	if( DODEBUG(DBGSTARTUP) )
	    Printf("enumerate_drivers: dib_register %s%d\n",
		   chd->chd_dib->dib_name, chd->chd_dib->dib_unit);
#endif

	if( !dib_register(chd->chd_dib) )
	    /*
	     * dib_register failed, this *must*
	     * have been a malloc failure
	     */
	    return(malloc_failure());

	/*
	 * it is our responsibility to free the chaining
	 * structures back into RMA, so do so.
	 */
	chdnext = chd->chd_next;

	r.r[0] = 7;
	r.r[2] = (int)chd;
	(void)_kernel_swi(XOS_Bit | OS_Module, &r, &r);
    }

    /*
     * all finished
     */
    return(NULL);
}

/**********************************************************************/

/*
 * claim_frames - claim/release all Internet frame types from unit: if
 * claim is 0 then release frame types, else claim frame types. returns
 * error block from Filter SWI, or NULL if no errors.
 */
_kernel_oserror *claim_frames(struct ifnet *ifp, int claim)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;
    u_int swinum = XOS_Bit | (ifp->if_swibase + DCI4Filter);
    int i;
    unsigned int typenlevel;
    extern int rxf_entry();

    /*
     * the set of frames claimed depends upon the
     * type of interface - those interfaces which
     * do not support ARP, should not be expected
     * to filter ARP & REVARP frame types for us
     */
    if( (ifp->if_flags & IFF_NOARP) )
    {
	/*
	 * fill in standard registers
	 */
	r.r[0] = (claim) ? (FILTER_CLAIM | FILTER_NO_UNSAFE) : FILTER_RELEASE;
	r.r[1] = ifp->if_unit;
	SET_FRAMELEVEL(r.r[2], FRMLVL_E2SPECIFIC);
	SET_FRAMETYPE(r.r[2], ETHERTYPE_IP);

	/*
	 * point-to-point interfaces have no concept of broadcast,
	 * only ask for specific frames to be filtered
	 */
	r.r[3] = (ifp->if_flags & IFF_POINTOPOINT) ?
	    ADDRLVL_SPECIFIC : ADDRLVL_NORMAL;
	r.r[4] = ERRLVL_NO_ERRORS;			/* error level */
	r.r[5] = (int)module_wsp;			/* Protocol Handle */
	r.r[6] = (int)rxf_entry;			/* Rx frame handler */

	e = _kernel_swi(swinum, &r, &r);
    }
    else
    {
	static int frame_types[] =
	{
	    ETHERTYPE_IP,
	    ETHERTYPE_ARP,
	    ETHERTYPE_REVARP
	};

	/*
	 * fill in standard registers
	 */
	r.r[0] = (claim) ? (FILTER_CLAIM | FILTER_NO_UNSAFE) : FILTER_RELEASE;
	r.r[1] = ifp->if_unit;
#if 1
	r.r[3] = ADDRLVL_NORMAL;			/* address level */
#else
	/*
	 * TRACE
	 *
	 * only accept directly addressed packets - this will force
	 * remote machines to have hard-wired ARP tables before they
	 * can talk to the local machine (among other things)
	 */
	r.r[3] = ADDRLVL_SPECIFIC;
#endif /* 0/1 */
	r.r[4] = ERRLVL_NO_ERRORS;			/* error level */
	r.r[5] = (int)module_wsp;			/* Protocol Handle */
	r.r[6] = (int)rxf_entry;			/* Rx frame handler */

	/*
	 * frame level is the same for all types
	 */
	SET_FRAMELEVEL(typenlevel, FRMLVL_E2SPECIFIC);

	/*
	 * claim all required frame types
	 */
	for( i = 0; i < (sizeof(frame_types) / sizeof(frame_types[0])); ++i )
	{
	    SET_FRAMETYPE(typenlevel, frame_types[i]);
	    r.r[2] = typenlevel;

	    if( (e = _kernel_swi(swinum, &r, &r)) )
		break;
	}

	/*
	 * release all claimed frame types if an error occured
	 */
	if( e && claim )
	{
	    r.r[0] = FILTER_RELEASE;

	    while( --i >= 0 )
	    {
		SET_FRAMETYPE(typenlevel, frame_types[i]);
		r.r[2] = typenlevel;

		(void)_kernel_swi(swinum, &r, &r);
	    }
	}
    }

    return(e);
}

/**********************************************************************/

/*
 * ifq_flush - empty all frames on ifqueue queues
 */
static void ifq_flush(struct ifqueue *ifq)
{
    struct mbuf *m;

    for(;;)
    {
	IF_DEQUEUE(ifq, m);

	if( m )
	    FREEM(m);
	else
	    break;
    }
}

/**********************************************************************/

_kernel_oserror *inet_final(void)
{
    int s = splhi();
    struct ifnet *ifp;

    finalising = 1;

    /*
     * issue service calls to let other modules know we are dying
     */
    sc_protostatus(1);

    /*
     * release timeout handler
     */
    removetickerevent(tick_entry);

    /*
     * bring all the interfaces down
     */
    for( ifp = ifnet; ifp; ifp = ifp->if_next )
	if_down(ifp);

    ifq_flush(&ipintrq);
    ifq_flush(&rawintrq);

    /*
     * finish session with mbuf manager, ignore any
     * errors (they don't mean much, since session
     * *may* still be closed, despite any errors
     * returned
     */
    (void)mb_closesession();

    /*
     * shutdown MessageTrans
     */
    release_msgs(msgfd);

    /*
     * clear any outstanding callbacks that we may still have
     */
    callback_finalise();

    /*
     * 940816 KWelton
     *
     * I don't think this is necessary for the DCI 4 version
     * of the Internet module, but I will leave it here for
     * the time being.
     */
    user_mode_donothing();

    splx(s);
    return(NULL);
}

/**********************************************************************/

/*
 * finish_init - perform second phase of module initialisation, i.e.
 * those operations which need the mbuf manager to be active.
 */
static _kernel_oserror *finish_init(void)
{
    _kernel_oserror *e;

    /*
     * this routine should only do anything the
     * first time it is called.
     */
    if( !inactive )
	return(NULL);

    /*
     * initialise mbuf system
     */
    if( (e = mb_entryinit()) != NULL )
    {
	char *tail;
	int msglen;

	_inet_errblk.errnum = INETERR_MMBAD;

	builderrmess(_inet_errblk.errmess, NULL, TagModName, &tail);
	builderrmess(tail, ": ", TagIntErr, &tail);
	builderrmess(tail, ": ", "MmBad", &tail);

	tail += strlen(strcpy(tail, ": "));
	msglen = tail - _inet_errblk.errmess;
	strncpy(tail, e->errmess, sizeof(_inet_errblk.errmess) - msglen);

	e = &_inet_errblk;
	goto out;
    }

    /*
     * no longer inactive
     */
    inactive = 0;

    /*
     * final Internet initialisation
     */
    domaininit();

    /*
     * nearly all done - start calling timer interrupts
     */
    e = calleverytick(tick_entry);

  out:
    /*
     * if something went wrong with initialisation then
     * finalise module before returning error to caller
     */
    if( e != NULL )
	(void)inet_final();
    else
	/*
	 * set a callback to issue a DCIProtocolStatus service
	 * call that announces our presence
	 */
	(void)callback(CALLB_STARTUP);

    return(e);
}

/**********************************************************************/

/*
 * handle_dcidriverstatus - cope with a DriverStatus service call
 */
static void handle_dcidriverstatus(_kernel_swi_regs *r)
{
    DibRef dib = (DibRef)r->r[0];
    struct ifnet *ifp;
    int s = splimp();

#ifdef DEBUG
    if( DODEBUG(DBGSTARTUP) )
	Printf("handle_driverstatus: (dib %x) device %s%d %sting\n",
	       dib, dib->dib_name, dib->dib_unit,
	       r->r[2] ? "termina" : "star");
#endif

    /*
     * check DCI version of driver, reject
     * incompatible versions.
     */
    if( r->r[3] < DCIMINIMUM )
    {
#ifdef DEBUG
	if( DODEBUG(DBGSTARTUP) )
	    Printf("handle_driverstatus: module version (%d) is too old\n",
		   r->r[3]);
#endif

	/* ignore this driver */
	return;
    }

    /*
     * find the ifnet structure for this unit
     */
    for( ifp = ifnet; ifp; ifp = ifp->if_next )
	/*
	 * since this is an initialise/finalise call, we cannot
	 * use the standard shortcut of simply comparing dib
	 * addresses, but must compare name and unit to uniquely
	 * identify an interface.
	 */
	if( !strcmp(ifp->if_name, (char *)dib->dib_name) &&
	   ifp->if_unit == dib->dib_unit )
	    break;

#ifdef DEBUG
    if( DODEBUG(DBGSTARTUP) )
    {
	Printf("handle_driverstatus: ifp = %x", ifp);
	if( ifp )
	    Printf(" (%s%d) flags = %x\n",
		   ifp->if_name, ifp->if_unit, ifp->if_flags);
	else
	    Printf("\n");
    }
#endif

    /*
     * check driver status (held in r2)
     */
    if( r->r[2] == 1 )
    {
	/*
	 * driver is terminating. this is slightly problematic, as
	 * the Berkeley Internet code (on which this module is based)
	 * does not expect (and cannot cope) with a driver disappearing.
	 * the best we can do here is to mark the interface as down, and
	 * flag it as missing a driver.	 the driver startup case (below)
	 * should first check whether it service call is from a previously
	 * existing driver, or a completely new startup.
	 */
	if( ifp )
	{
	    ifp->if_flags |= IFF_NODRIVER;
	    ifp->if_flags &= ~IFF_RUNNING;

	    /*
	     * output and ioctl routines now have no meaning,
	     * as the driver does not exist any more
	     */
	    ifp->if_output = if_module_none;
	    ifp->if_ioctl = if_module_none;
	}
	else
	    /*
	     * this should never happen, as we should know about
	     * *all* active drivers in the system.  all we can
	     * do is ignore the dying driver.
	     */
	    ;
    }
    else
    {
	/*
	 * driver is starting up.  as described above, this is
	 * either an old driver re-appearing, or a completely
	 * new driver.
	 *
	 * 941219 KWelton
	 *
	 * device drivers issue this service call under callback,
	 * therefore it can take a *long* time to appear - this
	 * means that the call it not necessarily an old driver
	 * re-appearing, so use IFF_NODRIVER to check whether it
	 * is or not.
	 */
	if( ifp && (ifp->if_flags & IFF_NODRIVER) )
	{
	    ifp->if_flags &= ~IFF_NODRIVER;

	    /*
	     * restore the standard output and ioctl routines
	     */
	    ifp->if_output = if_module_output;
	    ifp->if_ioctl = if_module_ioctl;

	    /*
	     * record the new dib address
	     */
	    ifp->if_dib = dib;

	    /*
	     * if the driver was previously up, then we
	     * should take it back up again.
	     */
	    if( (ifp->if_flags & IFF_UP) )
	    {
		/*
		 * we will need to claim all relevant
		 * frame types from the driver
		 */
		if( claim_frames(ifp, 1) == NULL )
		{
		    /*
		     * we have no means of reporting errors
		     * that occured while claiming frames,
		     * but only mark the interface as running
		     * if no such errors occured.
		     */
		    ifp->if_flags |= IFF_RUNNING;
		}
	    }
	}
	else if( !ifp )
	    /*
	     * unfortunately, there is no way to report any
	     * errors (i.e. malloc failures) that occured
	     * while registering this new interface
	     */
	    (void)dib_register(dib);
    }

    /*
     * finished - restore spl and return
     */
    splx(s);
}

/**********************************************************************/

/*
 * handle_managerstatus - cope with an MbufManagerStatus service call
 */
static void handle_managerstatus(_kernel_swi_regs *r)
{
    _kernel_oserror *e;

    switch(r->r[0])
    {
      case MbufManagerStatus_Started:
	/*
	 * cannot return any error from this call,
	 * so panic if something goes wrong
	 */
	if( (e = finish_init()) != NULL )
	    panic(e->errmess);

	break;

      case MbufManagerStatus_Stopping:
	/*
	 * should only ever see this message if we are
	 * finalising our own module, otherwise something
	 * has gone terribly wrong (the mbuf manager should
	 * only stop when all its clients have closed their
	 * sessions)
	 */
	if( !finalising )
	    panic("Mbuf manager has stopped");

	break;

      case MbufManagerStatus_Scavenge:
	/*
	 * nothing we can do to help
	 */
	break;

      default:
	break;
    }
}

/**********************************************************************/

/*
 * startup_handler - callback routine used to issue a service call
 * announcing the arrival of the Internet module
 */
int startup_handler(void)
{
    callback_entered(CALLB_STARTUP);

    /*
     * issue the call
     */
    sc_protostatus(0);

    /*
     * finished - return a non-zero value so
     * the cmhg veneers take the correct exit
     */
    return(1);
}

/**********************************************************************/

#ifdef DEBUG

#define CMOSRead	161
#define CMOSStartByte	31
/*
 * init_debug - use 4 bytes of USER CMOS starting at byte 31
 * to initialise debugctrl
 */
static void init_debug(void)
{
    _kernel_swi_regs r;
    _kernel_oserror *e;
    int i;

    r.r[0] = CMOSRead;
    debugctrl = 0;

    for( i = 0; i < 4; ++i )
    {
	r.r[1] = CMOSStartByte + i;

	if( (e = _kernel_swi(XOS_Bit | OS_Byte, &r, &r)) != NULL )
	    break;

	debugctrl |= ((r.r[2] & 0xff) << (i * 8));
    }

    /*
     * default is all debug bits on if CMOS read fails
     */
    if( e )
	debugctrl = ~0;
}

#endif

/**********************************************************************/

/*
 * inet_init - module initialisation code
 */
_kernel_oserror *inet_init(char *cmd_tail, int pbase, void *pw)
{
    _kernel_oserror *e;

    module_wsp = pw;
    ipforwarding = is_gateway_configured();

#ifdef DEBUG
    /*
     * load debug state from CMOS RAM
     */
    init_debug();

    if( DODEBUG(DBGSTARTUP) )
	Printf("inet_init: ipforwarding %sabled\n",
	       ipforwarding ? "en" : "dis");
#endif

    /*
     * open MessageTrans file
     */
#ifdef OldCode
    if( (e = init_msgs(MsgFile, msgfd)) != NULL )
	return(e);
#else
    /*
     * 950213 KWelton
     *
     * It is *not* a fatal error if the messages file cannot be opened
     */
    (void)init_msgs(MsgFile, msgfd);
#endif

    /*
     * initialise u-area and struct proc (these are Unix
     * features which are emulated under RISC OS).
     */
    u_init();

    /*
     * initialise callout structures
     */
    init_callout();

    /*
     * initialise Internet protocol structures
     */
    in_proto_init();

    /*
     * initialise callback recording system
     */
    callback_init();

    /*
     * generate list of existing device drivers
     */
    if( (e = enumerate_drivers()) != NULL )
	return(e);

    /*
     * initialise sleep management scheme
     */
    sleeptabinit();

    /*
     * some more internet initialisations
     */
    socktabinit();
    ifinit();

    /*
     * check whether the mbuf manager is loaded
     */
    if( mb_present() )
	return(finish_init());
    else
	/*
	 * must return an OK status to allow
	 * any chance of running later
	 */
	return(NULL);
}

/**********************************************************************/

/*
 * sc_handler - top level handler for service calls
 */
void sc_handler(int sn, _kernel_swi_regs *r)
{
    switch(sn)
    {
      case Service_PreReset:
	inet_final();
	break;

      case Service_MessageFileClosed:
	handle_messagefile(r);
	break;

      case Service_DCIDriverStatus:
	handle_dcidriverstatus(r);
	break;

      case Service_MbufManagerStatus:
	handle_managerstatus(r);
	break;
    }
}

/**********************************************************************/

/*
 * rxf_handler - received frame handler. called from CMHG veneers.
 */
int rxf_handler(_kernel_swi_regs *r, void *pw)
{
    DibRef dib = (DibRef)(r->r[0]);
    struct mbuf *m0 = (struct mbuf *)(r->r[1]);
    struct ifnet *ifp;
    int s = splhi();

#ifdef DEBUG
    if( DODEBUG(DBGINPUT) )
	Printf("\nRXF: (dib %x) ", dib);
#endif

    /*
     * try to find the struct ifnet for the unit
     * which is passing these frames in
     */
    for( ifp = ifnet; ifp; ifp = ifp->if_next )
	/*
	 * Driver Information Blocks are static, so their addresses
	 * can be used to uniquely identify an interface
	 */
	if( ifp->if_dib == dib )
	    break;

    /*
     * no interface, no frames recognised
     */
    if( !ifp )
    {
#ifdef DEBUG
	if( DODEBUG(DBGINPUT) )
	    Printf("no ifp\n\n");
#endif
	splx(s);
	return(1);
    }

#ifdef DEBUG
    if( DODEBUG(DBGINPUT) )
	Printf("device %s%d\n", ifp->if_name, ifp->if_unit);
#endif

    /*
     * loop over all received frames, enqueuing them separately
     *
     * XXX TRACE XXX
     *
     * It would be nice if, at a later point, we could pass the
     * entire block over in one fell swoop.
     */
    while( m0 )
    {
	/*
	 * some hacky messing around with the mbuf length here;
	 * would be nice if this can be avoided in the future.
	 */
	RxHdrRef rx = mtod(m0, RxHdrRef);
	struct mbuf *m;

	/* TRACE */
	if( 0 )
	{
	    struct mbuf *m1 = m0;

	    Printf("\021\002RXF: hdr @%x", m1);
	    for( m1 = m1->m_next; m1; m1 = m1->m_next )
		Printf("-->%x(%d, %d)", m1, m1->m_type, m1->m_len);
	    Printf("-->(NULL)\n\021\007");

	    if( DODEBUG((1 << 16)) )
	    {
		int i = 0;

		Printf("\021\005Packet Dump:\n");

		for( m1 = m0->m_next; m1; m1 = m1->m_next )
		{
		    int j;
		    u_char *cptr = mtod(m1, u_char *);

		    for( j = 0; j < m1->m_len; ++j )
		    {
			Printf("%02x", *cptr++);

			if( !(++i % 32) )
			    Printf("\n");
			else if( !(i % 4) )
			    Printf("  ");
		    }
		}

		if( (i % 32) )
		    Printf("\021\007\n");
	    }
	}

	rx->rx_ptr = ifp;
	m0->m_len = rx->rx_frame_type;

#ifdef DEBUG
	if( DODEBUG(DBGINPUT) )
	{
	    Printf("src %s, ", ether_sprintf(rx->rx_src_addr));
	    Printf("dst %s, type %x\n",
		   ether_sprintf(rx->rx_dst_addr), rx->rx_frame_type);
	}
#endif

	/*
	 * move along the frame list, before it is broken below
	 */
	m = m0->m_list;

	/*
	 * add this to the queue of input frames, then
	 * move m0 along to next frame in the chain
	 *
	 * XXX
	 *
	 * this macro will clear the m_list field,
	 * breaking the list of frame chains
	 */
	IF_ENQUEUE(&ipintrq, m0);
	m0 = m;
    }

    /*
     * all done, schedule the soft interrupt and return
     */
    schednetisr(NETISR_IP);

#ifdef DEBUG
    if( DODEBUG(DBGINPUT) )
	Printf("RXF: complete\n");
#endif
    splx(s);
    return(1);
}

/**********************************************************************/

/*
 * sock_swi_handler - top level handler for SWI calls
 */
_kernel_oserror *sock_swi_handler(int swinum, _kernel_swi_regs *r,
				  void *pw)
{
    struct swient *callp;
    int rval = 0, error, oldstate;
    char *tail;

    /*
     * range check SWI number
     */
    if( swinum >= sizeof(sock_ent) / sizeof(sock_ent[0]) )
    {
#ifdef DEBUG
	if( DODEBUG(DBGUSER) )
	    Printf("\021\01Bad SWI: %d\021\07\n", swinum);
#endif

	_inet_errblk.errnum = INETERR_INVALIDSWI;
	builderrmess(_inet_errblk.errmess, NULL, TagModName, &tail);
	builderrmess(tail, ": ", "InvalSWI", NULL);

	return(&_inet_errblk);
    }

#ifdef DEBUG
{
    static char *swinames[26] =
    {
	"socket",
	"bind",
	"listen",
	"accept",
	"connect",
	"recv",
	"recvfrom",
	"recvmsg",
	"send",
	"sendto",
	"sendmsg",
	"shutdown",
	"setsockopt",
	"getsockopt",
	"getpeername",
	"getsockname",
	"socketclose",
	"socketselect",
	"socketioctl",
	"socketread",
	"socketwrite",
	"socketstat",
	"socketreadv",
	"socketwritev",
	"getstablesize",
	"sendtosm"
    };

    if( DODEBUG(DBGUSER) )
	Printf("\021\005>%s<...\021\007", swinames[swinum]);
}
#endif

    if( inactive || paniced )
    {
	if( inactive )
	{
	    _inet_errblk.errnum = INETERR_NOMM;
	    builderrmess(_inet_errblk.errmess, NULL, TagModName, &tail);
	    builderrmess(tail, ": ", "NoMm", NULL);

#ifdef DEBUG
	    if( DODEBUG(DBGUSER) )
		Printf("\021\01module is inactive\021\07\n");
#endif

	    return(&_inet_errblk);
	}
	else
	{
	    _inet_errblk.errnum = INETERR_PANICED;

	    builderrmess(_inet_errblk.errmess, NULL, TagModName, &tail);
	    builderrmess(tail, ": ", TagPaniced, &tail);
	    builderrmess(tail, ": ", panicbuf, NULL);

#ifdef DEBUG
	    if( DODEBUG(DBGUSER) )
		Printf("\021\01panicing with error %d (%s)\021\07\n",
		       _inet_errblk.errnum, _inet_errblk.errmess);
#endif

	    return (&_inet_errblk);
	}
    }

    callp = &sock_ent[swinum];
    oldstate = ensure_irqs_on();

    if (callp->swi_rval)
	error = (*(callp->swi_call))(r, &rval);
    else
	error = (*(callp->swi_call))(r);

    if( !error )
	r->r[0] = rval;

    restore_irqs(oldstate);

#ifdef DEBUG
    if( DODEBUG(DBGUSER) )
    {
	if( error )
	{
	    _kernel_oserror *fail = inet_error(error);

	    Printf("\021\01failing with error %d (%s) (error %d)\021\07\n",
		   fail->errnum, fail->errmess, error);
	    return(fail);
	}
	else
	    Printf("\021\05OK\021\07\n");
    }
#endif
    return(inet_error(error));
}

/**********************************************************************/

_kernel_oserror *sock_cli_handler(char *arg_string, int arg_count,
				  int cmd_no, void *pw)
{
    struct client *callp;
    int margc;
    char *margv[20];
    char *cp;
    char **argp = margv;

    if( cmd_no >= sizeof(inet_cli_call) / sizeof(inet_cli_call[0]) )
    {
	char *tail;

	_inet_errblk.errnum = INETERR_BADCLI;

	builderrmess(_inet_errblk.errmess, NULL, TagModName, &tail);
	builderrmess(tail, ": ", TagIntErr, &tail);
	builderrmess(tail, ": ", "BadCli", NULL);

	return(&_inet_errblk);
    }

    /*
     * YEURGH!
     *
     * This time it is RISC OS and cmhg conspiring to necessitate
     * more grungy code: if the arg_count is "too large", assume
     * that this is a help request, rather than a *-command, in
     * which case arg_string is a text buffer, and arg_count is
     * the buffer length, and breaking the string up is a bad idea.
     * The "too large" level is set at 128, on the assumption that
     * the max. length of a command line is 256 bytes which gives a
     * (theoritical) maximum of 128 arguments
     */
    if( arg_count < 128 )
    {
	if( arg_count > 20 )
	    /* limit set by size of margv array */
	    arg_count = 20;

	margc = 0;
	cp = arg_string;
	while (*cp && arg_count-- > 0)
	{
	    while (*cp == ' ' || *cp == '\t')
		cp++;

	    if (*cp == '\0')
		break;

	    *argp++ = cp;
	    margc++;
	    while (*cp != '\0' && *cp != ' ' && *cp != '\t')
		cp++;

	    if (*cp == '\0')
		break;

	    *cp++ = '\0';
	}

	*argp++ = 0;
    }
    else
    {
	/* its a help request */
	margc = arg_count;
	margv[0] = arg_string;
    }

    callp = &inet_cli_call[cmd_no];
    return(callp->cli_call(margc, margv));
}

/**********************************************************************/

_kernel_oserror *inet_error(int error)
{
    static char *_sys_errlist[] =
    {
	"NONE",
	"PERM",
	"NOENT",
	"SRCH",
	"INTR",
	"IO",
	"NXIO",
	"2BIG",
	"NOEXEC",
	"BADF",
	"CHILD",
	"AGAIN",
	"NOMEM",
	"ACCES",
	"FAULT",
	"NOTBLK",
	"BUSY",
	"EXIST",
	"XDEV",
	"NODEV",
	"NOTDIR",
	"ISDIR",
	"INVAL",
	"NFILE",
	"MFILE",
	"NOTTY",
	"TXTBSY",
	"FBIG",
	"NOSPC",
	"SPIPE",
	"ROFS",
	"MLINK",
	"PIPE",
	"DOM",
	"RANGE",
	"WOULDBLOCK",
	"INPROGRESS",
	"ALREADY",
	"NOTSOCK",
	"DESTADDRREQ",
	"MSGSIZE",
	"PROTOTYPE",
	"NOPROTOOPT",
	"PROTONOSUPPORT",
	"SOCKTNOSUPPORT",
	"OPNOTSUPP",
	"PFNOSUPPORT",
	"AFNOSUPPORT",
	"ADDRINUSE",
	"ADDRNOTAVAIL",
	"NETDOWN",
	"NETUNREACH",
	"NETRESET",
	"CONNABORTED",
	"CONNRESET",
	"NOBUFS",
	"ISCONN",
	"NOTCONN",
	"SHUTDOWN",
	"TOOMANYREFS",
	"TIMEDOUT",
	"REFUSED",
	"LOOP",
	"NAMETOOLONG",
	"HOSTDOWN",
	"HOSTUNREACH",
	"NOTEMPTY",
	"PROCLIM",
	"USERS",
	"DQUOT",
	"STALE",
	"REMOTE",
	"NOSTR",
	"TIME",
	"NOSR",
	"NOMSG",
	"BADMSG",
	"IDRM",
	"DEADLK",
	"NOLCK",
	"NOMSG",
	"IDRM",
	"LIBVER",
	"LIBACC",
	"LIBLIM",
	"LIBNOENT",
	"LIBNOEXEC",
	"NOSYS",
    };
    static int _sys_nerr = sizeof(_sys_errlist) / sizeof(_sys_errlist[0]);

    /*
     * 950227 KWelton
     *
     * make a special case out of
     * tunnelled error messages
     */
    if( error == ETUNNEL )
	return(&errtunnel);

    if (error > _sys_nerr || paniced)
	error = EFAULT;

    if (error)
    {
	SETDCI4ERRNO(_inet_errblk.errnum, error);
	strncpy(_inet_errblk.errmess,
		lookup_tag(_sys_errlist[error]),
		sizeof(_inet_errblk.errmess));
	return(&_inet_errblk);
    }

    return ((_kernel_oserror *)0);
}

/**********************************************************************/

static char *plural(int n)
{
    return (n != 1 ? "s" : "");
}

/**********************************************************************/

extern int callbackerr;
extern struct ipstat ipstat;
extern struct udpstat udpstat;
extern struct tcpstat tcpstat;

static const char *icmpnames[] = {
	"echo reply",
	"#1",
	"#2",
	"destination unreachable",
	"source quench",
	"routing redirect",
	"#6",
	"#7",
	"echo",
	"#9",
	"#10",
	"time exceeded",
	"parameter problem",
	"time stamp",
	"time stamp reply",
	"information request",
	"information request reply",
	"address mask request",
	"address mask reply",
};

_kernel_oserror *do_instats(int argc, char **argv)
{
    /*
     * see the comments in sock_cli_handler for
     * an explanation of what is happening here
     */
    if( argc < 128 )
    {
	int sockstats();
#ifdef OLDMBUFSTATS
	struct mbstat *m = mbstat;
#endif
	int res = 0;
	int prot = 0;
	int ifaces = 0;
	int n = 0;

	if( paniced )
	{
	    char *tail;

	    /*
	     * 940331 KWelton
	     *
	     * use message block within _inet_errblk as this is a
	     * convenient buffer of suitable size.
	     */
	    builderrmess(_inet_errblk.errmess, NULL, TagModName, &tail);
	    builderrmess(tail, ": ", TagPaniced, &tail);
	    builderrmess(tail, ": ", panicbuf, NULL);
	    printf("%s\n", _inet_errblk.errmess);
	}

	if (argc > 0)
	{
	    while (argc-- > 0)
	    {
		switch (**argv)
		{
		  case 'r':
		    res = 1;
		    break;

		  case 'p':
		    prot = 1;
		    break;

		  case 'i':
		    ifaces = 1;
		    break;

		  default:
		    break;
		}
		argv++;
	    }
	}
	else
	    res = 1;

	if (res)
	{
	    printf("\%s:\n\n", lookup_tag("ResUse"));
	    printf("Sockets\n	 Active %d\n", sockstats());

#ifdef OLDMBUFSTATS
	    printf("Data buffers\n	  Total %ld, InUse %ld, Hiwat %ld, ",
		   m->m_mbufs, m->m_inuse, m->m_hiwat);
	    for (m0 = *mfree; m0; m0 = m0->m_next)
		n++;
	    printf("Mfree %d, ", n);
#endif

	    n = 0;
	    printf("\n");
	}

	if (prot)
	{
	    int first, i;

	    printf("\%s:\n\n", lookup_tag("ProtStat"));

	    printf("IP\n");
#if BSD>=43
	    printf("%ld total packets received\n", ipstat.ips_total);
#endif
	    printf("    %ld bad header checksum%s\n",
		   ipstat.ips_badsum, plural(ipstat.ips_badsum));
	    printf("    %ld with size smaller than minimum\n",
		   ipstat.ips_toosmall);
	    printf("    %ld with data size < data length\n",
		   ipstat.ips_tooshort);
	    printf("    %ld with header length < data size\n",
		   ipstat.ips_badhlen);
	    printf("    %ld with data length < header length\n",
		   ipstat.ips_badlen);
#if BSD>=43
	    printf("    %ld fragment%s received\n",
		   ipstat.ips_fragments, plural(ipstat.ips_fragments));
	    printf("    %ld fragment%s dropped (dup or out of space)\n",
		   ipstat.ips_fragdropped, plural(ipstat.ips_fragdropped));
	    printf("    %ld fragment%s dropped after timeout\n",
		   ipstat.ips_fragtimeout, plural(ipstat.ips_fragtimeout));
	    printf("    %ld packet%s forwarded\n",
		   ipstat.ips_forward, plural(ipstat.ips_forward));
	    printf("    %ld packet%s not forwardable\n",
		   ipstat.ips_cantforward, plural(ipstat.ips_cantforward));
	    printf("    %ld redirect%s sent\n",
		   ipstat.ips_redirectsent, plural(ipstat.ips_redirectsent));
#endif

	    printf("ICMP:\n");
	    printf("    %u call%s to icmp_error\n",
		   icmpstat.icps_error, plural(icmpstat.icps_error));
	    printf("    %u error%s not generated 'cuz old message was icmp\n",
		   icmpstat.icps_oldicmp, plural(icmpstat.icps_oldicmp));
	    for (first = 1, i = 0; i < ICMP_MAXTYPE + 1; i++)
		if (icmpstat.icps_outhist[i] != 0)
		{
		    if (first)
		    {
			printf("    Output histogram:\n");
			first = 0;
		    }
		    printf("        %s: %u\n", icmpnames[i],
			   icmpstat.icps_outhist[i]);
		}
	    printf("    %u message%s with bad code fields\n",
		   icmpstat.icps_badcode, plural(icmpstat.icps_badcode));
	    printf("    %u message%s < minimum length\n",
		   icmpstat.icps_tooshort, plural(icmpstat.icps_tooshort));
	    printf("    %u bad checksum%s\n",
		   icmpstat.icps_checksum, plural(icmpstat.icps_checksum));
	    printf("    %u message%s with bad length\n",
		   icmpstat.icps_badlen, plural(icmpstat.icps_badlen));
	    for (first = 1, i = 0; i < ICMP_MAXTYPE + 1; i++)
		if (icmpstat.icps_inhist[i] != 0)
		{
		    if (first)
		    {
			printf("    Input histogram:\n");
			first = 0;
		    }
		    printf("        %s: %u\n", icmpnames[i],
			   icmpstat.icps_inhist[i]);
		}
	    printf("    %u message response%s generated\n",
		   icmpstat.icps_reflect, plural(icmpstat.icps_reflect));

	    printf("TCP:\n");
#define	p(f, m)		printf(m, tcpstat.f, plural(tcpstat.f))
#define	p2(f1, f2, m)	printf(m, tcpstat.f1, plural(tcpstat.f1), tcpstat.f2, plural(tcpstat.f2))

	    p(tcps_sndtotal, "    %ld packet%s sent\n");
	    p2(tcps_sndpack,tcps_sndbyte,
	       "        %ld data packet%s (%ld byte%s)\n");
	    p2(tcps_sndrexmitpack, tcps_sndrexmitbyte,
	       "        %ld data packet%s (%ld byte%s) retransmitted\n");
	    p2(tcps_sndacks, tcps_delack,
	       "        %ld ack-only packet%s (%ld packet%s delayed)\n");
	    p(tcps_sndurg, "        %ld URG only packet%s\n");
	    p(tcps_sndprobe, "        %ld window probe packet%s\n");
	    p(tcps_sndwinup, "        %ld window update packet%s\n");
	    p(tcps_sndctrl, "        %ld control packet%s\n");
	    p(tcps_rcvtotal, "    %ld packet%s received\n");
	    p2(tcps_rcvackpack, tcps_rcvackbyte,
	       "        %ld ack%s (for %ld byte%s)\n");
	    p(tcps_rcvdupack, "        %ld duplicate ack%s\n");
	    p(tcps_rcvacktoomuch, "        %ld ack%s for unsent data\n");
	    p2(tcps_rcvpack, tcps_rcvbyte,
	       "        %ld packet%s (%ld byte%s) received in-sequence\n");
	    p2(tcps_rcvduppack, tcps_rcvdupbyte,
	       "        %ld completely duplicate packet%s (%ld byte%s)\n");
	    p2(tcps_rcvpartduppack, tcps_rcvpartdupbyte,
	       "        %ld packet%s with some dup data (%ld byte%s duped)\n");
	    p2(tcps_rcvoopack, tcps_rcvoobyte,
	       "        %ld out-of-order packet%s (%ld byte%s)\n");
	    p2(tcps_rcvpackafterwin, tcps_rcvbyteafterwin,
	       "        %ld packet%s (%ld byte%s) of data after window\n");
	    p(tcps_rcvwinprobe,
	      "        %ld window probe%s\n");
	    p(tcps_rcvwinupd,
	      "        %ld window update packet%s\n");
	    p(tcps_rcvafterclose,
	      "        %ld packet%s received after close\n");
	    p(tcps_rcvbadsum, "        %ld discarded for bad checksum%s\n");
	    p(tcps_rcvbadoff,
	      "        %ld discarded for bad header offset field%s\n");
	    p(tcps_rcvshort,
	      "        %ld discarded because packet%s too short\n");
	    p(tcps_connattempt, "    %ld connection request%s\n");
	    p(tcps_accepts, "    %ld connection accept%s\n");
	    p(tcps_connects,
	      "    %ld connection%s established (including accepts)\n");
	    p2(tcps_closed, tcps_drops,
	       "    %ld connection%s closed (including %ld drop%s)\n");
	    p(tcps_conndrops, "    %ld embryonic connection%s dropped\n");
	    p2(tcps_rttupdated, tcps_segstimed,
	       "    %ld segment%s updated rtt (of %ld attempt%s)\n");
	    p(tcps_rexmttimeo, "    %ld retransmit timeout%s\n");
	    p(tcps_timeoutdrop,
	      "        %ld connection%s dropped by rexmit timeout\n");
	    p(tcps_persisttimeo, "    %ld persist timeout%s\n");
	    p(tcps_keeptimeo, "    %ld keepalive timeout%s\n");
	    p(tcps_keepprobe, "        %ld keepalive probe%s sent\n");
	    p(tcps_keepdrops,
	      "        %ld connection%s dropped by keepalive\n");
#undef p
#undef p2

	    printf("UDP:\n");
	    printf("    %u incomplete header%s\n",
		   udpstat.udps_hdrops, plural(udpstat.udps_hdrops));
	    printf("    %u bad data length field%s\n",
		   udpstat.udps_badlen, plural(udpstat.udps_badlen));
	    printf("    %u bad checksum%s\n",
		   udpstat.udps_badsum, plural(udpstat.udps_badsum));
	}

	if( ifaces )
	{
	    struct ifnet *ifp = ifnet;

	    if( ifnet )
	    {
		printf("Name  Mtu	 Flags	    (ifp)\n");

		while( ifp )
		{
		    printf("%.2s%d	 %-4d  %08x  %08p\n",
			   ifp->if_name, ifp->if_unit,
			   ifp->if_mtu, ifp->if_flags,
			   ifp);

		    ifp = ifp->if_next;
		}
	    }
	    else
		printf("%s\n", "NoIf");
	}

	printf("\n%s\n",
	       lookup_tag((char *)((ipforwarding) ? TagIsAct : TagNotAct)));

	return(NULL);
    }
    else
    {
	printf("%s\n", lookup_tag("HInInfo"));
	printf("Syntax: *InetInfo [r] [i] [p]");
	return(NULL);
    }
}

/**********************************************************************/

_kernel_oserror *do_gateway(int argc, char **argv)
{
    /*
     * see the comments in sock_cli_handler for
     * an explanation of what is happening here
     */
    if( argc < 128 )
    {
	/*
	 * is a command, not a help request - argc
	 * will be either 0 or 1
	 */
	if( argc == 0 )
	{
	    /*
	     * print current status
	     */
	    printf("%s\n",
		   lookup_tag((char *)((ipforwarding) ?
				       TagIsAct : TagNotAct)));
	}
	else
	{
	    int i;
	    char shortbuf[5];
	    char *cptr = *argv;

	    for( i = 0; i < sizeof(shortbuf); ++i, ++cptr )
	    {
		/*
		 * don't increment cptr in tolower()
		 * as it may be a macro
		 */
		shortbuf[i] = tolower(*cptr);

		/*
		 * The poxy heap of shite that comprises RISC OS
		 * allows any control character to be used as a
		 * string terminator.  The person responsible for
		 * this scheme needs to be taken out and maimed.
		 */
		if( shortbuf[i] < ' ' )
		{
		    shortbuf[i] = '\0';
		    *cptr = '\0';
		    break;
		}
	    }

	    if( i == sizeof(shortbuf) )
		shortbuf[i - 1] = '\0';

	    /*
	     * XXX
	     *
	     * backwards compatibility - "1" is a
	     * synonym for "on", and "0" equates
	     * to "off"
	     */
	    if( !strcmp(shortbuf, "on") || !strcmp(shortbuf, "1") )
		ipforwarding = 1;
	    else if( !strcmp(shortbuf, "off") || !strcmp(shortbuf, "0") )
		ipforwarding = 0;
	    else
		printf("\n%s\n", SynGateway);
	}
	return(NULL);
    }
    else
    {
	/*
	 * is a help request
	 */
	printf("%s\n", lookup_tag((char *)TagHInGate));
	printf("%s", SynGateway);
	return(NULL);
    }
}

/**********************************************************************/

_kernel_oserror *do_checksum(int argc, char **argv)
{
    /*
     * see the comments in sock_cli_handler for
     * an explanation of what is happening here
     */
    if( argc < 128 )
    {
	/*
	 * is a command, not a help request - argc
	 * will be either 0 or 1
	 */
	if( argc == 0 )
	{
	    printf("IP checksums are %s, "
		   "UDP checksums are %s, "
		   "TCP checksums are %s\n",
		   (ipcksum) ? TagOn : TagOff,
		   (udpcksum) ? TagOn : TagOff,
		   (tcpcksum) ? TagOn : TagOff);
	}
	else
	{
	    int i;
	    char shortbuf[5];
	    char *cptr = *(argv + 1);
	    int *iptr;

	    /*
	     * check the first argument
	     */
	    switch( **argv )
	    {
	      case 'i':
	      case 'I':
		iptr = &ipcksum;
		break;

	      case 'u':
	      case 'U':
		iptr = &udpcksum;
		break;

	      case 't':
	      case 'T':
		iptr = &tcpcksum;
		break;

	      default:
		iptr = NULL;
		break;
	    }

	    if( iptr != NULL )
	    {
		/*
		 * 1st arg is OK, wrestle once again with
		 * RISC OS to get a usable form of the
		 * second arg
		 */
		for( i = 0; i < sizeof(shortbuf); ++i, ++cptr )
		{
		    /*
		     * don't increment cptr in tolower()
		     * as it may be a macro
		     */
		    shortbuf[i] = tolower(*cptr);

		    /*
		     * XXX (I hate RISC OS!)
		     */
		    if( shortbuf[i] < ' ' )
		    {
			shortbuf[i] = '\0';
			*cptr = '\0';
			break;
		    }
		}

		if( i == sizeof(shortbuf) )
		    shortbuf[i - 1] = '\0';

		/*
		 * it won't hurt to once again treat "1" as
		 * a synonym for "on", and "0" for "off"
		 */
		if( !strcmp(shortbuf, "on") || !strcmp(shortbuf, "1") )
		{
		    *iptr = 1;
		    return(NULL);
		}
		else if( !strcmp(shortbuf, "off") || !strcmp(shortbuf, "0") )
		{
		    *iptr = 0;
		    return(NULL);
		}
	    }

	    /*
	     * to get here, means we failed!
	     */
	    printf("\n%s\n", SynChecksum);
	}
	return(NULL);
    }
    else
    {
	/*
	 * is a help request
	 */
	printf("%s\n", lookup_tag("HInCksum"));
	printf("%s", SynChecksum);
	return(NULL);
    }
}

/**********************************************************************/

_kernel_oserror *do_indebug(int argc, char **argv)
{
#ifdef DEBUG
    /*
     * see the comments in sock_cli_handler for
     * an explanation of what is happening here
     */
    if( argc < 128 )
    {
	if( argc == 1 )
	{
	    /*
	     * want to set a new value for debugctrl
	     */
	    int newval = strtol(*argv, NULL, 0x10);

	    if( newval == 0 && **argv != '0' )
	    {
		_inet_errblk.errnum = DCI4ERRORBLOCK + 0x82;
		sprintf(_inet_errblk.errmess,
			"bad debug value '%s'", *argv);
		return(&_inet_errblk);
	    }
	    else
		debugctrl = newval;
	}

	printf("debug control set to 0x%02x\n", debugctrl);
    }
    else
	printf("*InetDebug can be used to control debug areas\n");

    return(NULL);
#else
    printf("%s\n", lookup_tag("DbgOff"));
    return(NULL);
#endif
}

/**********************************************************************/

static int is_gateway_configured()
{
    _kernel_swi_regs r;
    char namebuf[32];

    r.r[0] = (int)"Inet$IsGateway";
    r.r[1] = (int)namebuf;
    r.r[2] = sizeof(namebuf);
    r.r[3] = 0; r.r[4] = 0;
    return((_kernel_swi(XOS_Bit | OS_ReadVarVal, &r, &r) == 0 &&
	    r.r[2] == 3) ? 1 : 0);
}

/**********************************************************************/

/* EOF module.c */
